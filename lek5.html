<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>file_1678813623389</title><meta name="author" content="Quốc Van"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 .s1 { color: #F00; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 16pt; }
 .s2 { color: #2D74B5; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 .p, p { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; margin:0pt; }
 .s3 { color: #00F; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s4 { color: black; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s6 { color: #808080; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s7 { color: #008000; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .h3, h3 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 .s8 { color: #008000; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s9 { color: black; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s10 { color: #2B91AE; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s12 { color: #1F4D78; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s13 { color: black; font-family:Consolas, monospace; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 .s14 { color: #2D74B5; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 16pt; }
 .s16 { color: #2D74B5; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 16pt; }
 .s17 { color: black; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s19 { color: #2B91AE; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s20 { color: #00F; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 .s21 { color: #00F; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s22 { color: #2E4F4F; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s23 { color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s24 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s25 { color: #2D74B5; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 .s26 { color: #212121; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s27 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 .s28 { color: #2D74B5; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 h1 { color: #365F91; font-family:Cambria, serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 .h2 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s29 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s30 { color: #333; font-family:Georgia, serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 .s31 { color: #333; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s32 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 .h4 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s33 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s34 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s35 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 .s36 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s37 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 1; }
 #l2> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 li {display: block; }
 #l3 {padding-left: 0pt; }
 #l3> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 li {display: block; }
 #l4 {padding-left: 0pt; }
 #l4> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 li {display: block; }
 #l5 {padding-left: 0pt;counter-reset: g1 1; }
 #l5> li>*:first-child:before {counter-increment: g1; content: counter(g1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l5> li:first-child>*:first-child:before {counter-increment: g1 0;  }
 li {display: block; }
 #l6 {padding-left: 0pt;counter-reset: h1 1; }
 #l6> li>*:first-child:before {counter-increment: h1; content: counter(h1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l6> li:first-child>*:first-child:before {counter-increment: h1 0;  }
 li {display: block; }
 #l7 {padding-left: 0pt; }
 #l7> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l8 {padding-left: 0pt;counter-reset: j1 1; }
 #l8> li>*:first-child:before {counter-increment: j1; content: counter(j1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l8> li:first-child>*:first-child:before {counter-increment: j1 0;  }
 li {display: block; }
 #l9 {padding-left: 0pt;counter-reset: k1 1; }
 #l9> li>*:first-child:before {counter-increment: k1; content: counter(k1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l9> li:first-child>*:first-child:before {counter-increment: k1 0;  }
 #l10 {padding-left: 0pt;counter-reset: k2 1; }
 #l10> li>*:first-child:before {counter-increment: k2; content: counter(k2, lower-latin)". "; color: black; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 #l10> li:first-child>*:first-child:before {counter-increment: k2 0;  }
 #l11 {padding-left: 0pt;counter-reset: k2 1; }
 #l11> li>*:first-child:before {counter-increment: k2; content: counter(k2, lower-latin)". "; color: black; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 #l11> li:first-child>*:first-child:before {counter-increment: k2 0;  }
 li {display: block; }
 #l12 {padding-left: 0pt;counter-reset: l1 1; }
 #l12> li>*:first-child:before {counter-increment: l1; content: counter(l1, lower-latin)". "; color: black; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 #l12> li:first-child>*:first-child:before {counter-increment: l1 0;  }
 li {display: block; }
 #l13 {padding-left: 0pt;counter-reset: m1 1; }
 #l13> li>*:first-child:before {counter-increment: m1; content: counter(m1, lower-latin)". "; color: black; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 #l13> li:first-child>*:first-child:before {counter-increment: m1 0;  }
 li {display: block; }
 #l14 {padding-left: 0pt; }
 #l14> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 li {display: block; }
 #l15 {padding-left: 0pt;counter-reset: o1 1; }
 #l15> li>*:first-child:before {counter-increment: o1; content: counter(o1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 #l15> li:first-child>*:first-child:before {counter-increment: o1 0;  }
 #l16 {padding-left: 0pt; }
 #l16> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 li {display: block; }
 #l17 {padding-left: 0pt;counter-reset: p1 1; }
 #l17> li>*:first-child:before {counter-increment: p1; content: counter(p1, lower-latin)". "; color: #808080; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 #l17> li:first-child>*:first-child:before {counter-increment: p1 0;  }
 li {display: block; }
 #l18 {padding-left: 0pt;counter-reset: q1 1; }
 #l18> li>*:first-child:before {counter-increment: q1; content: counter(q1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l18> li:first-child>*:first-child:before {counter-increment: q1 0;  }
 li {display: block; }
 #l19 {padding-left: 0pt;counter-reset: r1 43; }
 #l19> li>*:first-child:before {counter-increment: r1; content: counter(r1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l19> li:first-child>*:first-child:before {counter-increment: r1 0;  }
 li {display: block; }
 #l20 {padding-left: 0pt;counter-reset: s1 1; }
 #l20> li>*:first-child:before {counter-increment: s1; content: counter(s1, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l20> li:first-child>*:first-child:before {counter-increment: s1 0;  }
 #l21 {padding-left: 0pt;counter-reset: t1 1; }
 #l21> li>*:first-child:before {counter-increment: t1; content: counter(t1, decimal)". "; color: #333; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l21> li:first-child>*:first-child:before {counter-increment: t1 0;  }
 #l22 {padding-left: 0pt;counter-reset: u1 1; }
 #l22> li>*:first-child:before {counter-increment: u1; content: counter(u1, decimal)" "; color: #333; font-family:Georgia, serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 #l22> li:first-child>*:first-child:before {counter-increment: u1 0;  }
 li {display: block; }
 #l23 {padding-left: 0pt;counter-reset: v1 1; }
 #l23> li>*:first-child:before {counter-increment: v1; content: counter(v1, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l23> li:first-child>*:first-child:before {counter-increment: v1 0;  }
 #l24 {padding-left: 0pt;counter-reset: w1 1; }
 #l24> li>*:first-child:before {counter-increment: w1; content: counter(w1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l24> li:first-child>*:first-child:before {counter-increment: w1 0;  }
 li {display: block; }
 #l25 {padding-left: 0pt;counter-reset: x1 1; }
 #l25> li>*:first-child:before {counter-increment: x1; content: counter(x1, decimal)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l25> li:first-child>*:first-child:before {counter-increment: x1 0;  }
 li {display: block; }
 #l26 {padding-left: 0pt;counter-reset: y1 4; }
 #l26> li>*:first-child:before {counter-increment: y1; content: counter(y1, decimal)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l26> li:first-child>*:first-child:before {counter-increment: y1 0;  }
 li {display: block; }
 #l27 {padding-left: 0pt;counter-reset: z1 1; }
 #l27> li>*:first-child:before {counter-increment: z1; content: counter(z1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l27> li:first-child>*:first-child:before {counter-increment: z1 0;  }
 li {display: block; }
 #l28 {padding-left: 0pt;counter-reset: c1 1; }
 #l28> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l28> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 li {display: block; }
 #l29 {padding-left: 0pt;counter-reset: d1 1; }
 #l29> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l29> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 table, tbody {vertical-align: top; overflow: visible; }
</style></head><body><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s1" style=" background-color: #0F0;">Лекция 1. Новое в C++</span></p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Задание параметров функции по умолчанию</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">При объявлении или определении функций существует возможность задавать параметрам функций значения по умолчанию.</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>say_hello(<span style=" color: #00F;">const char </span>* name, <span style=" color: #00F;">const char </span>* greeting = <span style=" color: #A21515;">&quot;Hello&quot;</span>, <span style=" color: #00F;">const char </span>* title = <span style=" color: #A21515;">&quot;Mr&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>say_hello(<span style=" color: #00F;">const char </span>* <span style=" color: #808080;">name</span>, <span style=" color: #00F;">const char </span>* <span style=" color: #808080;">greeting</span>, <span style=" color: #00F;">const char </span>* <span style=" color: #808080;">title</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%s, %s %s!\n&quot;</span>, <span style=" color: #808080;">greeting</span>, <span style=" color: #808080;">title</span>, <span style=" color: #808080;">name</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">say_hello(</span>const char <span style=" color: #000;">* name, </span>const char <span style=" color: #000;">* greeting, </span>const char <span style=" color: #000;">* title);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>say_hello(<span style=" color: #00F;">const char </span>* <span style=" color: #808080;">name</span>, <span style=" color: #00F;">const char </span>* <span style=" color: #808080;">greeting </span>= <span style=" color: #A21515;">&quot;Hello&quot;</span>, <span style=" color: #00F;">const char </span>* <span style=" color: #808080;">title </span>= <span style=" color: #A21515;">&quot;Mr&quot;</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%s, %s %s!\n&quot;</span>, <span style=" color: #808080;">greeting</span>, <span style=" color: #808080;">title</span>, <span style=" color: #808080;">name</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Общим правилом является то, что если у функции есть параметры со значениями по умолчанию и без таковых, то</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">параметры по умолчанию должны быть расположены в конце списка параметров, так, например, такое объявление функции будет ошибочным:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>say_hello(<span style=" color: #00F;">const char </span>* greeting = <span style=" color: #A21515;">&quot;Hello&quot;</span>, <span style=" color: #00F;">const char </span>* title = <span style=" color: #A21515;">&quot;Mr.&quot;</span>, <span style=" color: #00F;">const char </span>* name);</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">При вызове таких функций все или часть параметров, имеющих значения по умолчанию могут не указываться, в этом случае они будут принимать значения по умолчанию. Если функция имеет несколько параметров по умолчанию, то незаданными всегда считаются последние в списке.</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">say_hello(<span style=" color: #A21515;">&quot;Smith&quot;</span>); <span style=" color: #008000;">//Hello, Mr Smith!</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">say_hello(<span style=" color: #A21515;">&quot;Smith&quot;</span>, <span style=" color: #A21515;">&quot;Good morning&quot;</span>); <span style=" color: #008000;">//Good morning, Mr Smith! </span>say_hello(<span style=" color: #A21515;">&quot;Smith&quot;</span>, <span style=" color: #A21515;">&quot;Welcome&quot;</span>, <span style=" color: #A21515;">&quot;Mrs&quot;</span>); <span style=" color: #008000;">//Welcome, Mrs Smith!</span></p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Перегрузка функций</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Перегруженными называют функции, объявленные в одной области видимости и имеющими одинаковые имена. при этом функции должны различаться типом, количеством или наличием неопределенного числа параметров.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Возможность перегрузки дает программисту именовать однотипные функции одинаково и не запоминать множество названий.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">print(</span>int <span style=" color: #000;">ival);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">print(</span>int <span style=" color: #000;">value); </span><span style=" color: #008000;">// совпадает с первой</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">print(</span>double <span style=" color: #000;">dval);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">print(</span>double <span style=" color: #000;">dval, </span>int <span style=" color: #000;">prec); </span>void <span style=" color: #000;">print(</span>const char <span style=" color: #000;">* sval);</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">При вызове функции компилятор осуществляет поиск наиболее подходящей по совокупности фактических параметров функции из числа перегруженных. При этом подходящая функция может быть не найдена, либо возможно возникновение неоднозначности.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Работа с динамической памятью в C++</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Выделение памяти производится посредством вызова функции new, для освобождения памяти соответственно delete.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Для выделения памяти под одиночные элементы и массивы синтаксис различен. Для одиночных лементов следующий синтаксис:</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">&lt;имя&gt; = new &lt;тип&gt; <b>[</b>(&lt;инициализатор&gt;)<b>]</b>;</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">delete &lt;имя&gt;;</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Здесь &lt;имя&gt; - название переменной-указателя, &lt;тип&gt; - тип элемента.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">*ptr1 = </span>new int<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, *ptr1); <span style=" color: #008000;">// -842150451 </span><span style=" color: #00F;">delete </span>ptr1;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">int </span>*ptr2 = <span style=" color: #00F;">new int</span>(); printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, *ptr2); <span style=" color: #008000;">// 0 </span><span style=" color: #00F;">delete </span>ptr2;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">int </span>*ptr3 = <span style=" color: #00F;">new int</span>(28); printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, *ptr3); <span style=" color: #008000;">// 28</span></p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">delete <span style=" color: #000;">ptr3;</span></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Для массивов:</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">&lt;имя&gt; = new &lt;тип&gt; [&lt;выражение&gt;] <b>[</b>(&lt;инициализатор&gt;)<b>]</b>;</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">delete [] &lt;имя&gt;;</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Здесь &lt;имя&gt; - название переменной-указателя, &lt;тип&gt; - тип элемента в массиве, &lt;выражение&gt; - выражение определяющее размерность массива.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">size = 5;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">*ptr4 = </span>new int<span style=" color: #000;">[size];</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; size; i++) printf(<span style=" color: #A21515;">&quot;%d &quot;</span>, ptr4[i]);</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//-842150451 -842150451 -842150451 -842150451 -842150451</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>); <span style=" color: #00F;">delete </span>[] ptr4;</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">*ptr5 = </span>new int<span style=" color: #000;">[size]();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; size; i++) printf(<span style=" color: #A21515;">&quot;%d &quot;</span>, ptr5[i]);</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//0 0 0 0 0</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>); <span style=" color: #00F;">delete </span>[] ptr5;</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Поддерживается только один тип инициализатора (), поэтому можно создать только обнуленный массив, а</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">инициализировать списком значений – нельзя. Для создания многомерных массивов есть два подхода: создание массива массивов фиксированной (константной) размерности, либо посредством создания массива указателей. Т.к. в первом подходе только одна (первая) размерность может быть нефиксированной</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">size = 5; </span>int <span style=" color: #000;">(*ptr6) [8];</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">ptr6 = <span style=" color: #00F;">new int </span>[size][8](); <span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; size; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>j = 0; j &lt; 8; j++) printf(<span style=" color: #A21515;">&quot;%d &quot;</span>, ptr6[i][j]); printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-bottom: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><table style="border-collapse:collapse;margin-left:5.3pt" cellspacing="0"><tr style="height:11pt"><td style="width:21pt"><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">//0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td></tr><tr style="height:12pt"><td style="width:21pt"><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">//0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td></tr><tr style="height:12pt"><td style="width:21pt"><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">//0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td></tr><tr style="height:12pt"><td style="width:21pt"><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">//0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">0</p></td></tr><tr style="height:11pt"><td style="width:21pt"><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">//0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">0</p></td></tr></table><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">delete <span style=" color: #000;">[] ptr6;</span>int <span style=" color: #000;">N=4, M=6; </span>int<span style=" color: #000;">** ptr7 = </span>new int<span style=" color: #000;">* [N]; </span>for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i&lt;N; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">ptr7[i] = <span style=" color: #00F;">new int </span>[M];</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for<span style=" color: #000;">(</span>int <span style=" color: #000;">j = 0; j &lt; M; j++) ptr7[i][j] = i+j;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt; N; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>j = 0; j &lt; M; j++) printf(<span style=" color: #A21515;">&quot;%d &quot;</span>, ptr7[i][j]); printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-bottom: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><table style="border-collapse:collapse;margin-left:5.3pt" cellspacing="0"><tr style="height:11pt"><td style="width:21pt"><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">//0</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">1</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">2</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">3</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">4</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">5</p></td></tr><tr style="height:12pt"><td style="width:21pt"><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">//1</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">2</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">3</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">4</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">5</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">6</p></td></tr><tr style="height:12pt"><td style="width:21pt"><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">//2</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">3</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">4</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">5</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">6</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 10pt;text-align: center;">7</p></td></tr><tr style="height:11pt"><td style="width:21pt"><p class="s8" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">//3</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">4</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">5</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">6</p></td><td style="width:11pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">7</p></td><td style="width:10pt"><p class="s8" style="text-indent: 0pt;line-height: 9pt;text-align: center;">8</p></td></tr></table><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i&lt;N; i++) </span>delete <span style=" color: #000;">[] ptr7[i]; </span>delete <span style=" color: #000;">[] ptr7;</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Есть ряд преимуществ использования new перед использованием malloc(). Во-первых, оператор new автоматически вычисляет размер необходимой памяти. Нет необходимости в использовании оператора sizeof(). Во-вторых, оператор new автоматически возвращает указатель требуемого типа, так что нет необходимости в использовании оператора</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">преобразования типа. В-третьих имеется возможность инициализации объекта при использовании оператора new. Функции динамического выделения памяти malloc/calloc/realloc/free и соответствующие операции new/delete являются механизмами разных уровней и не сводятся один к другому. Функции malloc/free/realloc представляют</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">собой библиотеку «классического» Си и транслятором не</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">контролируются. С их помощью можно работать с обычными динамическими переменными и массивами, но никак не с объектами. Операции new/delete используют собственную систему контроля данных в динамической памяти,</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">кроме непосредственно выделения/освобождения памяти вызывают конструкторы и деструкторы, поэтому при работе с объектами необходимо использовать исключительно их.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Ссылки</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Ссылки – особый тип данных, являющийся скрытой формой указателя, который при использовании автоматически разыменовывается. Часто говорят, что ссылка — это псевдоним (альтернативное имя) уже существующего объекта. Определяются ссылки следующим образом:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">&lt;тип&gt; &amp;&lt;имя ссылки&gt; = &lt;имя объекта&gt;;</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">При объявлении ссылки перед её именем ставится символ амперсанда &amp;, сама же ссылка должна быть</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">проинициализирована некоторым существующим объектом (то есть ссылка не может быть нулевой). После</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">инициализации ссылки не могут быть изменены. Тип данных, на который указывает ссылка, может быть любым, но должен совпадать с объектом, на который ссылается, то есть с типом данных ссылочной переменной. Для удобства, будем называть переменную, на которую ссылается ссылка «ссылочной переменной». Любое изменение значения, содержащегося в ссылке, повлечёт за собой изменение этого значения в переменной, на которую ссылается ссылка. <span class="s3">int </span><span class="s4">value = 5;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">&amp;ref = value; value++;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, value); <span style=" color: #008000;">// 6 </span>ref++;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, value); <span style=" color: #008000;">// 7</span><span style=" color: #00F;">int </span>&amp;invalidRef; <span style=" color: #008000;">// для ссылки переменная &quot;invalidRef&quot; требуется инициализатор</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">value2 = 10;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">ref = value2; <span style=" color: #008000;">// ссылка не изменится, изменится значение value, запись аналогична</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">value = value2</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Ссылки могут быть константными и не константными. В случае с константными ссылками нет возможности изменить значение «ссылочной переменной» используя ссылку.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">value = 5;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">const int <span style=" color: #000;">&amp;ref = value; value++;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">ref++; <span style=" color: #008000;">// выражение должно быть допустимым для изменения левосторонним значением</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Также стоить учитывать, что нельзя проинициализировать не константную ссылку константным значением.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">const int <span style=" color: #000;">value = 5;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">&amp;ref = value; </span><span style=" color: #008000;">// отброшены квалификаторы в ссылке, привязывающей тип &quot;int &amp;&quot; к инициализатору типа &quot;const int&quot;</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Ссылки, как правило, в большинстве случаев используют в функциях как ссылки-параметры. В языке С++, в отличии от C параметры функции могут передаваться по значению или по ссылке. Так вот, когда происходит передача по</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">значению, те данные, которые необходимо передать, нужно сначала скопировать на стек, а когда передаётся</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">большой объём данных, то только на передачу затрачивается большое количество времени и ресурсов. В таком случае необходимо использовать</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">передачу по ссылке<b>, </b>в этом случае данные копировать нет необходимости, так как к ним обеспечен прямой доступ. Передачу по ссылке используют тогда, когда необходимо, что бы значения аргументов могли изменяться:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>swap_ptr (<span style=" color: #00F;">int </span>*<span style=" color: #808080;">a</span>, <span style=" color: #00F;">int </span>*<span style=" color: #808080;">b</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">int </span>tmp = *<span style=" color: #808080;">a</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">*<span style=" color: #808080;">a </span>= *<span style=" color: #808080;">b</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">*<span style=" color: #808080;">b </span>= tmp;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>swap_ref (<span style=" color: #00F;">int </span>&amp;<span style=" color: #808080;">a</span>, <span style=" color: #00F;">int </span>&amp;<span style=" color: #808080;">b</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">int </span>tmp = <span style=" color: #808080;">a</span>;</p><p class="s6" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">a <span style=" color: #000;">= </span>b<span style=" color: #000;">;</span></p><p class="s6" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">b <span style=" color: #000;">= tmp;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">a = 5, b = 7;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;a=%d; b=%d;\n&quot;</span>, a, b); <span style=" color: #008000;">//a=5; b=7; </span>swap_ptr(&amp;a, &amp;b);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;a=%d; b=%d;\n&quot;</span>, a, b); <span style=" color: #008000;">//a=5; b=7; </span>swap_ref(a, b);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;a=%d; b=%d;\n&quot;</span>, a, b); <span style=" color: #008000;">//a=5; b=7; </span>getchar();</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">}<span class="p">Также для оптимизации, при передаче объемных данных:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">struct <span style=" color: #2B91AE;">Student</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">char <span style=" color: #000;">FirstName[20]; </span><span style=" color: #008000;">//поле &quot;имя&quot;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">char <span style=" color: #000;">LastName[20]; </span><span style=" color: #008000;">//поле &quot;фамилия&quot; </span>unsigned short <span style=" color: #000;">Group; </span><span style=" color: #008000;">//поле &quot;группа&quot; </span>unsigned char <span style=" color: #000;">Scores [5]; </span><span style=" color: #008000;">//поле &quot;оценки&quot;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>printStudent(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Student </span>&amp;<span style=" color: #808080;">student</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%-20s&quot;</span>, <span style=" color: #808080;">student</span>.FirstName); printf(<span style=" color: #A21515;">&quot;%-20s&quot;</span>, <span style=" color: #808080;">student</span>.LastName); printf(<span style=" color: #A21515;">&quot;%-10u&quot;</span>, <span style=" color: #808080;">student</span>.Group); printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Оценки: &quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>j = 0; j&lt;5; j++) printf(<span style=" color: #A21515;">&quot;%2d&quot;</span>, <span style=" color: #808080;">student</span>.Scores[j]); printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">setlocale(<span style=" color: #6E0089;">LC_ALL</span>, <span style=" color: #A21515;">&quot;&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Student </span>student = {<span style=" color: #A21515;">&quot;John&quot;</span>, <span style=" color: #A21515;">&quot;Лесин&quot;</span>, 6111, {4, 4, 3, 5, 3}}; printStudent(student);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Если нет необходимости изменить передаваемое значение в ссылочной переменной, но нужно выиграть в скорости, используйте спецификатор const в объявлении параметров функций. Такой прием позволит защитить данные от</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">непреднамеренного изменения. Так, например, при попытке модификации структуры student в приведенной выше функции возникнет ошибка компиляции:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>printStudent(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Student </span>&amp;<span style=" color: #808080;">student</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s6" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">student<span style=" color: #000;">.Group = 6111; </span><span style=" color: #008000;">// &quot;Group&quot; не может быть изменен, поскольку доступ к нему осуществляется через константный объект</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//...</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Также иногда ссылки используют для доступа ко вложенным данным. В этом случае использование ссылок является</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">«синтаксическим сахаром» - не дает никаких преимуществ, но позволяет сделать код менее громоздким.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">struct <span style=" color: #2B91AE;">Node</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Student <span style=" color: #000;">data; </span><span style=" color: #008000;">// структура Student объявлена выше</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Node <span style=" color: #000;">*next;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Node <span style=" color: #000;">* head;</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">...</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned short <span style=" color: #000;">&amp;ref = head-&gt;data.Group;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">ref = 6112; <span style=" color: #008000;">// идентично head-&gt;data.Group = 6112... </span>ref = 6111;</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">...</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">В приведенном примере громоздкое обращение head-&gt;data.Group можно заменить на ref. Такое использование ссылок целесообразно, при необходимости многократного обращения к вложенным данным.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Можно подытожить разницу между указателями и ссылками: Основное назначение указателя – это организация динамических объектов, и работа с ними, так, например, есть арифметика указателей, но арифметики ссылок не бывает. Ссылки предназначены для организации прямого доступа к тому, или иному объекту. Главное отличие</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">состоит во внутреннем механизме работы. Указатели ссылаются на участок в памяти, используя его адрес. А ссылки ссылаются на объект, по</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">его имени. Также, поскольку ссылка всегда инициализируется не может быть нулевой, то в некотором смысле</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">использование ссылок безопаснее чем использование указателей, т.к. отпадает проблема разыменования нулевого указателя. Если задачу можно решить при помощи ссылок, предпочтительнее использовать их.</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s1" style=" background-color: #0F0;">Лекция 2. Введение в объектно-ориентированное программирование (ООП)</span></p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Основные понятия</p><ul id="l1"><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;line-height: 14pt;text-align: left;">ООП</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;text-align: left;">Класс</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;text-align: left;">Свойства</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;text-align: left;">Методы</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;line-height: 14pt;text-align: left;">Интерфейс</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;line-height: 14pt;text-align: left;">Объект</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Объектно-ориентированное программирование (ООП) <span class="p">— методология программирования, основанная на</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Класс <span class="p">– это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт). С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов). С точки</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">зрения структуры программы, класс является сложным типом данных.</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Поле (атрибут) <span class="p">– это физически хранимый в экземплярах класса элемент данных. Набор полей и их значений отражает состояние объекта.</span></h3><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Метод <span class="p">– описанная внутри класса и связанная с экземплярами класса (т.е. имеющая доступ ко всем элементам класса) процедура или функция. Совокупность методов, описанных в классе (а также и унаследованных) отражает поведение экземпляров класса</span></h3><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Интерфейс <span class="p">– это набор полей и методов класса, доступных для использования другими классами. Очевидно, что</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных полей. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним.</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Объект (экземпляр класса) <span class="p">– это отдельный представитель класса, имеющий конкретное состояние и поведение,</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">полностью определяемое классом. Говоря простым языком, объект имеет конкретные значения атрибутов и методы, работающие с</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">этими значениями на основе правил, заданных в классе.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Основные принципы ООП</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;line-height: 14pt;text-align: left;">Абстракция</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;text-align: left;">Инкапсуляция</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;text-align: left;">Наследование</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;text-align: left;">Полиморфизм</p></li></ul><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Абстрагирование <span class="p">– это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция – это набор всех таких характеристик.</span></h3><h3 style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Инкапсуляция <span class="p">– это свойство системы, позволяющее объединить данные и методы, работающие</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">с ними, в классе и скрыть детали реализации от пользователя.В программировании термин «инкапсуяция» относится к одной или обеим одновременно следующим нотациям:</p><ol id="l2"><li data-list-text="1."><p style="padding-left: 18pt;text-indent: -10pt;text-align: left;">Механизм языка, позволяющий ограничить доступ одних компонентов программы к другим.</p></li><li data-list-text="2."><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Языковая конструкция, позволяющая связать данные с методами, предназначенными для обработки этих данных. <b>Наследование </b>– это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется</p></li></ol><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">базовым или родительским. Новый класс – потомком, наследником или производным классом.</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Полиморфизм <span class="p">– это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.</span></h3><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Классы и объекты в C++</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Рассмотрим основы использования классов и объектов в языке C++ на примере такого типа данных как дата.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Поставим задачу следующим образом: реализовать хранение трех компонент даты: день, месяц и год, а также функционал вывода даты на печать в формате dd.mm.yyyy. Прежде чем приступать к объектному решению, рассмотрим классическое (процедурное) этой</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">задачи.</p><p class="s12" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Процедурное решение</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В классическом C для решения поставленной задачи целесообразно использовать такой производный тип данных как структура. Определим тип данных DateStruct и функцию вывода даты на экран в стиле C (для экономии памяти на</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">стеке будем передавать указатель на структуру, а в соответствии с правилами хорошего тона оформим его как указатель на константу):</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">struct <span style=" color: #2B91AE;">DateStruct</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">day; </span>unsigned <span style=" color: #000;">month; </span>unsigned <span style=" color: #000;">year;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>PrintDate(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">DateStruct </span>*<span style=" color: #808080;">date</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%02u.%02u.%u&quot;</span>, <span style=" color: #808080;">date</span>-&gt;day, <span style=" color: #808080;">date</span>-&gt;month, <span style=" color: #808080;">date</span>-&gt;year);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">DateStruct <span style=" color: #000;">ds; ds.day = 10;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">ds.month = 5;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">ds.year = 2021; PrintDate(&amp;ds); <span style=" color: #008000;">//10.05.2021 </span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">В таком решении есть одна проблема, данные хранятся отдельно от функций их обработки, и поэтому в функцию</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">печати необходимо передавать указатель на структуру, данные которой будут выведены на экран. Если понадобится реализовать еще ряд функций, например, задание значений дня, года и месяца с контролем значений, или какой-то другой функционал, то во всех функциях будет присутствовать аргумент, определяющий конкретный экземпляр</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">структуры с которым требуется выполнить какое-то действие.</p><p class="s12" style="padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">Основы работы с классами и объектами</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Класс <span class="p">это производный структурированный тип данных, содержащий совокупность данных и функций их обработки. Синтаксис описания класса следующий:</span></h3><p class="s9" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class &lt;имя класса&gt; : <b>[</b>&lt;список базовых классов&gt;<b>]</b></p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">{</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">&lt;список членов класса&gt;</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">} <b>[</b>&lt;список переменных&gt;<b>]</b>;</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">&lt;имя класса&gt; - корректный идентификатор, &lt;список базовых классов&gt; - один или несколько базовых классов от которых наследуется определяемый класс, &lt;список членов класса&gt; - описывает поля и методы класса.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Необязательный параметр &lt;список переменных&gt; позволяет описать переменные класса непосредственно при определении, аналогично как рассматривали ранее со структурами.</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Поле <span class="p">– это физически хранимый в экземплярах класса элемент данных. Набор полей и их значений отражает состояние объекта. Синтаксис объявления полей класса аналогичен объявлению полей типа структура.</span></h3><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Метод <span class="p">– описанная внутри класса и связанная с экземплярами класса (т.е. имеющая доступ ко всем элементам класса) процедура или функция. Совокупность методов, описанных в классе (а также и унаследованных) отражает поведение экземпляров класса. Объявление методов класса практически аналогично объявлению обычных функций. за</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">исключением используемых спецификаторов, о которых будет рассказано далее. Методы могут быть определены, как внутри,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">так и вне класса. Пока что мы будем определять их внутри класса (для простоты), как определить их вне класса — рассмотрим позже. Важно понимать разницу между, такими понятиями как класс и объект. Класс — это тип данных, то есть описание некоторого вида объектов, в некотором смысле класс является шаблоном для создания объектов. Класс определяет переменные и константы для хранения состояния объекта и функции для определения поведения объекта. <b>Объектом </b>или <b>экземпляром класса </b>будем называть переменную типа класс, то есть конкретную его</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">реализацию, имеющую <b>конкретное</b></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">состояние и поведение. В языке C++ создание объектов возможно, как на стеке, так и в динамической памяти. Пока</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">ограничимся рассмотрением объектов на стеке. Аналогично структурам, обращение к членам экземпляра объекта (и к полям, и к методам) осуществляется с использованием оператора “.” после имени объекта, если необходимо работать с указателем на экземпляр объекта, то следует использовать оператор “-&gt;”.</p><p class="s12" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Объектное решение</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Рассмотренную ранее задачу можно решить, используя объектный подход. В отличии от структур, которые</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">представляют просто некоторый конгломерат данных, позволяющий работать с ними как с единым целым, классы</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">позволяют привязать к этим данным определенные функции. Рассмотрим простейшую реализацию класса DateClass:</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">class </span>DateClass <span style=" color: #008000;">// DateClass </span>- <span style=" color: #008000;">класс</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">day; </span>unsigned <span style=" color: #000;">month;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">year;</span>void <span style=" color: #000;">Print()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%02u.%02u.%u&quot;</span>, day, month, year);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">DateClass <span style=" color: #000;">dc1, dc2; </span><span style=" color: #008000;">// dc1 и dc2 - экземпляры класса</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">dc1.day = 10;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">dc1.month = 5;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">dc1.year = 2021;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">dc2.day = 25;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">dc2.month = 3;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">dc2.year = 1996; dc1.Print(); <span style=" color: #008000;">//10.05.2021 </span>printf(<span style=" color: #A21515;">&quot;\n&quot;</span>); dc2.Print(); <span style=" color: #008000;">//25.03.1996 </span>printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">year = dc1.year; </span><span style=" color: #008000;">//обращение к полю данных через экземпляр класса</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;year is: %u&quot;</span>, year); <span style=" color: #008000;">//year is: 2021 </span>printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">DateClass <span style=" color: #000;">*pdc = &amp;dc1;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">month = pdc-&gt;month; </span><span style=" color: #008000;">//обращение к полю данных через указатель на экземпляр класса</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;month is: %u&quot;</span>, month); <span style=" color: #008000;">//month is: 5</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Если проанализировать код метода Print и сопоставить его с описанной выше функцией Print, то найдем два отличия: исчез параметр определяющий указатель на структуру, а также в коде функции уточненные обращения к полям (например date-&gt;day) заменены на неуточненные. На самом деле, аргумент, определяющий адрес структуры никуда не делся, просто он передается в функцию неявным образом в виде указателя на объект (функция должна иметь</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">возможность работать с конкретным экземпляром класса), а при компиляции происходит автоматическое уточнение всех обращений к членам класса. Поэтому внутри методов класса возможно обращение к его членам просто по</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">имени. Таким образом достигается связь данных и функций их обработки. Именно поэтому, поэтому при вызове функции печати, не требуется указывать никаких</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">параметров и для каждого экземпляра класса эта функция выведет на печать именно его конкретные значения дня, месяца и года. Таким образом у каждого объекта <b>появилось </b>определенное <b>поведение </b>– он может вывести на печать своё состояние. Фактически в данном примере мы рассмотрели первый постулат <b>инкапсуляции </b>– объединение</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">данных и методов их</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">обработки в одной сущности.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s14" style=" background-color: #0F0;">Лекция 3 Спецификаторы доступа. Конструкторы.</span></p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Спецификаторы доступа</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">В примерах список членов класса предваряла синтаксическая конструкция «public:» которая называется</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">спецификатором доступа<span class="p">. Если бы не был указан спецификатор доступа public, то класс фактически оказался бы</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">бесполезным, т.к. все члены этого класса были бы недоступны для использования. Ниже приведен пример, который иллюстрирует невозможность компиляции кода, содержащего обращения к недоступным членам класса.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">DateClass</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">day; </span>unsigned <span style=" color: #000;">month; </span>unsigned <span style=" color: #000;">year;</span></p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">Print()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%02u.%02u.%u&quot;</span>, day, month, year);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">DateClass <span style=" color: #000;">dc;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">dc.day = 10; <span style=" color: #008000;">// DateClass::day: невозможно обратиться к private член, объявленному в классе &quot;DateClass&quot;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">dc.month = 5; <span style=" color: #008000;">// DateClass::month: невозможно обратиться к private член, объявленному в классе &quot;DateClass&quot;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">dc.year = 2021; <span style=" color: #008000;">// DateClass::year: невозможно обратиться к private член, объявленному в классе &quot;DateClass&quot;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">dc.Print(); <span style=" color: #008000;">// DateClass::Print: невозможно обратиться к private член, объявленному в классе &quot;DateClass&quot;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Такое поведение обусловлено тем, что по умолчанию, все члены классов считаются закрытыми, а доступ к членам класса регулируется спецификаторами доступа, которые определяют уровень доступа к тем или иным членам класса. Спецификаторы доступа указываются в описании класса с использованием следующего синтаксиса:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">&lt;спецификатор доступа&gt;: <span class="p">Действие спецификатора доступа распространяется до следующего спецификатора или до конца описания класса. В языке C++ есть три спецификатора доступа:</span></p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private <span class="p">– закрытый член класса, доступ к такому члену класса имеют только члены-функции этого же класса, а также дружественные функции, методы и классы;</span></h3><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">protected <span class="p">– защищённый член класса, доступ к такому члену класса имеют члены-функции этого же класса, дружественные функции, методы и классы, а также члены-функции классов наследников;</span></h3><h3 style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">public <span class="p">– открытый член класса, доступ к такому члену класса имеется всюду, где есть доступ к самому классу;</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В описании классов для различных членов можно использовать различные спецификаторы доступа. Порядок, в котором указываются члены класса с различными спецификаторами не имеет значения.Разделять члены класса на открытые закрытые, и защищенные имеет смысл для реализации второй ключевой идеи инкапсуляции – разделение класса на интерфейс и реализацию. В рассмотренном ранее примере, когда члены-данные были открытыми, у нас</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">есть возможность</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">задать произвольные значения, удовлетворяющие типу данных для дня, месяца и года, что противоречит логике класса:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">DateClass</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">day; </span>unsigned <span style=" color: #000;">month; </span>unsigned <span style=" color: #000;">year; </span>void <span style=" color: #000;">Print()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%02u.%02u.%u&quot;</span>, day, month, year);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">DateClass <span style=" color: #000;">dc; dc.day = 56;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">dc.month = 22;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">dc.year = 1000000;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">dc.Print(); <span style=" color: #008000;">// 56.22.1000000 </span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Для того, чтобы организовать контроль значений на уровне класса необходимо члены-данные сделать закрытыми. а для задания значений реализовать отдельную функцию, в которой будет присутствовать логика проверки значений на принадлежность допустимому диапазону.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">DateClass</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">day; </span>unsigned <span style=" color: #000;">month; </span>unsigned <span style=" color: #000;">year; </span>public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">SetDate(</span>unsigned <span style=" color: #808080;">day</span><span style=" color: #000;">, </span>unsigned <span style=" color: #808080;">month</span><span style=" color: #000;">, </span>unsigned <span style=" color: #808080;">year</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if</span>(<span style=" color: #808080;">day </span>&gt; 0 &amp;&amp; <span style=" color: #808080;">day </span>&lt;= 31) <span style=" color: #00F;">this</span>-&gt;day = <span style=" color: #808080;">day</span>; <span style=" color: #00F;">if</span>(<span style=" color: #808080;">month </span>&gt; 0 &amp;&amp; <span style=" color: #808080;">month </span>&lt;= 12) <span style=" color: #00F;">this</span>-&gt;month = <span style=" color: #808080;">month</span>; <span style=" color: #00F;">if</span>(<span style=" color: #808080;">year </span>&lt;= 9999) <span style=" color: #00F;">this</span>-&gt;year = <span style=" color: #808080;">year</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">Print()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%02u.%02u.%04u&quot;</span>, day, month, year);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">DateClass <span style=" color: #000;">dc; dc.SetDate(25, 6, 2000);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">dc.Print(); <span style=" color: #008000;">// 25.06.2000</span>printf(<span style=" color: #A21515;">&quot;\n&quot;</span>); dc.SetDate(45, 11, 20000);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">dc.Print(); <span style=" color: #008000;">// 25.11.2000 </span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Таким образом мы выделили внутреннюю реализацию (поля –данные day, month и year) и интерфейс (методы SetDate и Print). Как правило в достаточно сложных классах, где есть необходимость разделения на интерфейс и</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">реализацию так и поступают: членам-данным класса устанавливают спецификаторы private или protected, тогда как членам-функциям пецификатор public.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Примечание о структурах в C++</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В классическом языке Cи структуры обеспечивают только хранение данных и не могут иметь связанных методов. В языке С++ понятие структур было фактически расширено до классов, лишь с той разницей, что в классах все члены по умолчанию закрытые (private), а в структурах – открытые (public). В приведенных выше примерах можно заменить ключевое слово class на struct, и получим компилируемый и работоспособный код. Во избежание путаницы</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">предлагается использовать структуры в стиле классического Си – для хранения данных, а также допускается их использование для реализации простейших спомогательных классов, не требующих разделения на интерфейс и реализацию, для проектирования более сложных сущностей будем использовать классы.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Плюсы инкапсуляции</p><h3 style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Инкапсулированные классы проще в использовании и уменьшают сложность программ. <span class="p">С грамотно</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">инкапсулированными классами достаточно знать только то, какие методы являются общедоступными, каковы</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">параметры их вызова и какие значения они возвращают. При работе с такими классами нет необходимости вникать в особенности внутренней реализации класса и в вопросы взаимодействия и согласованности членов класса.</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Инкапсулированные классы помогают защитить данные и предотвращают их неправильное использование. <span class="p">Также, как и глобальные переменные опасны, так как нет строгого контроля над тем, кто имеет к ним доступ и как их</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">используют, так и открытые члены классов представляют подобную угрозу, правда в несколько меньших масштабах. работа с данными строго через методы позволяет защитить целостность класса. Допустим мы хотим реализовать класс «строка», очевидно в данном классе будут такие члены- данные как: хранилище для строки, в приведенном</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">примере это динамический массив типа char и</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">целочисленная переменная для хранения длины строки.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">MyString</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">char <span style=" color: #000;">*string; </span><span style=" color: #008000;">// динамически выделяемая строка</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">length; </span><span style=" color: #008000;">// переменную для хранения длины строки</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">...</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">По логике этого класса значение переменной length должно соответствовать длине строки, хранимой в динамической переменной string.Если оба этих члена-данных будут открытыми, то пользователь класса может изменить значение длины строки без изменения размера содержимого string, что очевидно, при работе с объектом приведет к</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">проблеме. Что бы не нарушить согласованность членов класса стоит реализовать доступ к длине строки посредством метода.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">MyString</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">char <span style=" color: #000;">*string; </span><span style=" color: #008000;">// динамически выделяемая строка</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">length; </span><span style=" color: #008000;">// переменную для хранения длины строки</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">getLength() { </span>return <span style=" color: #000;">length; } </span><span style=" color: #008000;">// функция доступа для получения значения длины строки</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//...</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Инкапсулированные классы проще поддерживать. <span class="p">Если в классе четко выделены интерфейс и реализация, то</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">возможно изменение реализации, без изменения интерфейса, что в свою очередь позволяет не изменять код работы с объектами.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Допустим есть простейший класс и некоторый код работы с объектом этого класса:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Values</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">int <span style=" color: #000;">number1; </span>int <span style=" color: #000;">number2; </span>int <span style=" color: #000;">number3;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Values <span style=" color: #000;">value; value.number1 = 7;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, value.number1); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Что произойдет. если мы захотим переименовать член класса number1 например в Number1. В данном случае придется переписывать весь код работы с объектом, имеющий отношение к этому члену класса.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Values</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">int <span style=" color: #000;">number1; </span>int <span style=" color: #000;">number2; </span>int <span style=" color: #000;">number3; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>setNumber1(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) { number1 = <span style=" color: #808080;">value</span>; } <span style=" color: #00F;">int </span>getNumber1() { <span style=" color: #00F;">return </span>number1; }</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Values <span style=" color: #000;">value; value.setNumber1(7);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, value.getNumber1()); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}<span class="p">Если доступ к этому члену класса предоставить с помощью соответствующих методов, то при изменении деталей реализации придется переписать только код этих методов, а код работы с объектами останется корректным, т.к. интерфейс класса остался неизменным.</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Values</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">numbers[3]; </span><span style=" color: #008000;">// изменяем реализацию этого класса</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// Нам нужно обновить реализацию методов</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>setNumber1(<span style=" color: #00F;">int </span><span style=" color: #808080;">number</span>) { numbers[0] = <span style=" color: #808080;">number</span>; } <span style=" color: #00F;">int </span>getNumber1() { <span style=" color: #00F;">return </span>numbers[0]; }</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Values <span style=" color: #000;">value;</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">value.setNumber1(7);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, value.getNumber1()); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Инкапсулированные классы проще отлаживать. <span class="p">Инкапсуляция упрощает отладку программ, если в этом возникает необходимость. Причиной неправильной работы программы может быть некорректное значение какого-либо члена-данных класса. Если в классах реализован прямой доступ к членам-данным, то отследить код, который меняет этот</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">член-данных, может быть достаточно трудно. Однако, если класс инкапсулирован и изменение значения возможно только в посредством вызова определенных методов, то достаточно установить точки останова для этих методов и проконтролировать изменение интересующего значения.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: justify;">Функции доступа</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В зависимости от класса, может потребоваться возможность получать/устанавливать значения закрытым членам-данных класса.</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Функция доступа <span class="p">— это короткая открытая функция, задачей которой является получение или изменение значения закрытой переменной-члена класса. В зависимости от решаемых задач их разделяют на </span>сеттеры <span class="p">и </span>геттеры.</h3><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">геттеры <span class="p">— это функции, которые возвращают значения закрытых переменных-членов класса;</span></h3><h3 style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">сеттеры <span class="p">— это функции, которые позволяют присваивать значения закрытым переменным- членам класса.</span></h3><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">MyString</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">char <span style=" color: #000;">*string; </span><span style=" color: #008000;">// динамически выделяемая строка</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">length; </span><span style=" color: #008000;">// переменную для хранения длины строки</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">getLength() { </span>return <span style=" color: #000;">length; } </span><span style=" color: #008000;">// функция доступа для получения значения длины строки</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//...</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Здесь функция Getlength() является геттером – возвращает значение закрытой переменной length, поскольку не реализована функция доступа сеттер, то можно сказать, что закрытый член класса length имеет доступ только на чтение.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Date</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">day; </span>int <span style=" color: #000;">month; </span>int <span style=" color: #000;">year; </span>public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">getDay() { </span>return <span style=" color: #000;">day; } </span><span style=" color: #008000;">// геттер для day</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>setDay(<span style=" color: #00F;">int </span><span style=" color: #808080;">day</span>) {<span style=" color: #00F;">if</span>(<span style=" color: #808080;">day </span>&gt; 0 &amp;&amp; <span style=" color: #808080;">day </span>&lt;= 31) <span style=" color: #00F;">this</span>-&gt;day = <span style=" color: #808080;">day</span>; } <span style=" color: #008000;">// сеттер для day</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">getMonth() { </span>return <span style=" color: #000;">month; } </span><span style=" color: #008000;">// геттер для month</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>setMonth(<span style=" color: #00F;">int </span><span style=" color: #808080;">month</span>) { <span style=" color: #00F;">if</span>(<span style=" color: #808080;">month </span>&gt; 0 &amp;&amp; <span style=" color: #808080;">month </span>&lt;= 12) <span style=" color: #00F;">this</span>-&gt;month = <span style=" color: #808080;">month</span>; } <span style=" color: #008000;">//</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">сеттер для month</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">getYear() { </span>return <span style=" color: #000;">year; } </span><span style=" color: #008000;">// геттер для year</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>setYear(<span style=" color: #00F;">int </span><span style=" color: #808080;">year</span>) { <span style=" color: #00F;">if</span>(<span style=" color: #808080;">year </span>&lt;= 9999) <span style=" color: #00F;">this</span>-&gt;year = <span style=" color: #808080;">year</span>; } <span style=" color: #008000;">// сеттер для year</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Здесь для всех закрытых членов класса реализована пара методов и сеттер и геттер, поэтому можно сказать, что все члены-данные класса имеют доступ и на чтение, и на запись.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: justify;">Указатель this</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">При компиляции методов, компилятор неявно добавляет к нему параметр *this. <b>Указатель *this </b>— это скрытый <b>константный указатель</b>, содержащий адрес объекта, который вызывает метод класса. Как правило его используют если есть необходимость разрешить конфликт имен. например если параметр метода и член класса к которому</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">обращаются в теле этого метода имеют одинаковые имена, то в этом случае. для явной адресации члена класса используют запись</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">this-&gt;<b>&lt;</b>имя члена класса<b>&gt;</b></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">DateClass</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">: </span>unsigned <span style=" color: #000;">day; </span>unsigned <span style=" color: #000;">month; </span>unsigned <span style=" color: #000;">year;</span></p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">SetDate(</span>unsigned <span style=" color: #808080;">day</span><span style=" color: #000;">, </span>unsigned <span style=" color: #808080;">month</span><span style=" color: #000;">, </span>unsigned <span style=" color: #808080;">year</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if</span>(<span style=" color: #808080;">day </span>&gt; 0 &amp;&amp; <span style=" color: #808080;">day </span>&lt;= 31) <span style=" color: #00F;">this</span>-&gt;day = <span style=" color: #808080;">day</span>; <span style=" color: #00F;">if</span>(<span style=" color: #808080;">month </span>&gt; 0 &amp;&amp; <span style=" color: #808080;">month </span>&lt;= 12) <span style=" color: #00F;">this</span>-&gt;month = <span style=" color: #808080;">month</span>; <span style=" color: #00F;">if</span>(<span style=" color: #808080;">year </span>&lt;= 9999) <span style=" color: #00F;">this</span>-&gt;year = <span style=" color: #808080;">year</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">Print()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%02u.%02u.%04u&quot;</span>, day, month, year);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Конструкторы</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Когда все члены <b>класса </b>(или <b>структуры</b>) являются открытыми, то мы можем инициализировать класс (или структуру) напрямую, используя список инициализации.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">DateClass</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">day; </span>unsigned <span style=" color: #000;">month; </span>unsigned <span style=" color: #000;">year;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">Print()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%02u.%02u.%04u&quot;</span>, day, month, year);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">DateClass <span style=" color: #000;">dc = {3, 11, 2001};</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">dc.Print(); <span style=" color: #008000;">// 03.11.2001 </span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Однако, как у нас появляются закрытые члены-данные класса, то их инициализировать напрямую нельзя, т.к. к ним нет прямого доступа. Для инициализации объектов таких классов используют конструкторы. <b>Конструктор </b>— это особый тип метода класса, который автоматически вызывается при создании объекта этого класса. Конструкторы обычно используются для инициализации переменных- членов класса значениями, которые предоставлены по</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">умолчанию или пользователем, или для выполнения некоторых предварительных действий необходимых для работы экземпляров данного класса (например, открыть определенный файл, установить соединение с базой данных и т.д.). В отличие от обычных методов, <b>конструкторы имеют определенные правила их именования</b>:</p><ul id="l3"><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;line-height: 14pt;text-align: left;">конструкторы всегда должны иметь то же имя, что и класс;</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;line-height: 14pt;text-align: left;">конструкторы не имеют <b>типа возврата </b>(даже <b>void</b>).</p></li></ul><p class="s12" style="padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Конструкторы по умолчанию</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Конструктор, который не имеет параметров (или содержит параметры, которые все имеют <b>значения по умолчанию</b>),</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">называется <b>конструктором по умолчанию</b>. Он вызывается, если пользователем не указаны явные значения для инициализации:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">DateClass</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">day; </span>unsigned <span style=" color: #000;">month; </span>unsigned <span style=" color: #000;">year; </span>public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">SetDay(</span>unsigned <span style=" color: #808080;">day</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if</span>(<span style=" color: #808080;">day </span>&gt; 0 &amp;&amp; <span style=" color: #808080;">day </span>&lt;= 31) <span style=" color: #00F;">this</span>-&gt;day = <span style=" color: #808080;">day</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetDay()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">return <span style=" color: #000;">day;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">SetMonth(</span>unsigned <span style=" color: #808080;">month</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{<span style=" color: #00F;">if</span>(<span style=" color: #808080;">month </span>&gt; 0 &amp;&amp; <span style=" color: #808080;">month </span>&lt;= 12) <span style=" color: #00F;">this</span>-&gt;month = <span style=" color: #808080;">month</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetMonth()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">return <span style=" color: #000;">month;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">SetYear(</span>unsigned <span style=" color: #808080;">year</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if</span>(<span style=" color: #808080;">year </span>&lt;= 9999) <span style=" color: #00F;">this</span>-&gt;year = <span style=" color: #808080;">year</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetYear()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">year;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">Print()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%02u.%02u.%u&quot;</span>, day, month, year);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">DateClass()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">day = 1;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">month = 1;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">year = 1900;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">DateClass <span style=" color: #000;">dc;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">dc.Print(); <span style=" color: #008000;">// 01.01.1900 </span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s12" style="padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Конструкторы с параметрами</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Хотя конструктор по умолчанию отлично подходит для обеспечения инициализации наших объектов значениями по умолчанию, часто может быть нужно, чтобы экземпляры нашего класса имели определенные значения, которые</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">предоставляются пользователем, вместо последующей замены ими значений по умолчанию. Для этого используют конструкторы с параметрами.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">DateClass</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">day; </span>unsigned <span style=" color: #000;">month; </span>unsigned <span style=" color: #000;">year;</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// вспомогательная функция используемая в конструкторах</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">Init()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">SetDay(1); SetMonth(1); SetYear(1990);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">SetDay(</span>unsigned <span style=" color: #808080;">day</span><span style=" color: #000;">){</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if</span>(<span style=" color: #808080;">day </span>&gt; 0 &amp;&amp; <span style=" color: #808080;">day </span>&lt;= 31) <span style=" color: #00F;">this</span>-&gt;day = <span style=" color: #808080;">day</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetDay()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">day;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">SetMonth(</span>unsigned <span style=" color: #808080;">month</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">if</span>(<span style=" color: #808080;">month </span>&gt; 0 &amp;&amp; <span style=" color: #808080;">month </span>&lt;= 12) <span style=" color: #00F;">this</span>-&gt;month = <span style=" color: #808080;">month</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">GetMonth()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">month;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">SetYear(</span>unsigned <span style=" color: #808080;">year</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">if</span>(<span style=" color: #808080;">year </span>&lt;= 9999) <span style=" color: #00F;">this</span>-&gt;year = <span style=" color: #808080;">year</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetYear()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">return <span style=" color: #000;">year;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">Print()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%02u.%02u.%u&quot;</span>, day, month, year);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// конструктор по умолчанию</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">DateClass()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Init();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// конструктор с параметрами</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">DateClass(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">day</span>, <span style=" color: #00F;">unsigned </span><span style=" color: #808080;">month</span>, <span style=" color: #00F;">unsigned </span><span style=" color: #808080;">year</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Init(); SetDay(<span style=" color: #808080;">day</span>); SetMonth(<span style=" color: #808080;">month</span>); SetYear(<span style=" color: #808080;">year</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">DateClass <span style=" color: #000;">dc1; </span><span style=" color: #008000;">// вызов конструктора по умолчанию</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">dc1.Print(); <span style=" color: #008000;">// 01.01.1900 </span>printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">DateClass <span style=" color: #000;">dc2(3, 11, 1995); </span><span style=" color: #008000;">// вызов конструктора с параметрами</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">dc2.Print(); <span style=" color: #008000;">// 03.11.1995</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Обратите внимание, что в данной реализации был добавлен закрытый метод Init(), который устанавливает закрытым полям day, month и year значения по умолчанию. Этот метод пришлось добавить, чтобы избежать дублирования кода, поскольку и в конструкторе по умолчанию, и в конструкторе с параметрами необходимо первоначально</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">инициализировать поля данных</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">значениями по умолчанию (<i><b>подумайте для чего это нужно в конструкторе с параметрами</b></i>). Это достаточно распространенная практика, т.к. в случае, когда у класса есть несколько конструкторов, очень часто бывает, что им</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">необходимо выполнять некоторый общий фрагмент кода, а <b>вызвать один конструктор из тела другого невозможно</b>.</p><p class="s12" style="padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Уменьшение количества конструкторов</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В примере с классом DateClass и двумя конструкторами (по умолчанию и с параметрами), конструктор по умолчанию на самом деле лишний. Можно упростить класс, реализовав один универсальный конструктор:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">DateClass</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">day; </span>unsigned <span style=" color: #000;">month; </span>unsigned <span style=" color: #000;">year; </span>public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">SetDay(</span>unsigned <span style=" color: #808080;">day</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if</span>(<span style=" color: #808080;">day </span>&gt; 0 &amp;&amp; <span style=" color: #808080;">day </span>&lt;= 31) <span style=" color: #00F;">this</span>-&gt;day = <span style=" color: #808080;">day</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetDay()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">return <span style=" color: #000;">day;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">SetMonth(</span>unsigned <span style=" color: #808080;">month</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">if</span>(<span style=" color: #808080;">month </span>&gt; 0 &amp;&amp; <span style=" color: #808080;">month </span>&lt;= 12) <span style=" color: #00F;">this</span>-&gt;month = <span style=" color: #808080;">month</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">GetMonth()</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">month;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">SetYear(</span>unsigned <span style=" color: #808080;">year</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if</span>(<span style=" color: #808080;">year </span>&lt;= 9999) <span style=" color: #00F;">this</span>-&gt;year = <span style=" color: #808080;">year</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetYear()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">return <span style=" color: #000;">year;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">Print()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%02u.%02u.%u&quot;</span>, day, month, year);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// универсальный конструктор</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">DateClass(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">day </span>= 1, <span style=" color: #00F;">unsigned </span><span style=" color: #808080;">month </span>= 1, <span style=" color: #00F;">unsigned </span><span style=" color: #808080;">year </span>= 1900)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">SetDay(1); SetDay(<span style=" color: #808080;">day</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">SetMonth(1);SetMonth(<span style=" color: #808080;">month</span>); SetYear(1990); SetYear(<span style=" color: #808080;">year</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">DateClass </span>dc1; dc1.Print(); <span style=" color: #008000;">// 01.01.1900 </span>printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">DateClass <span style=" color: #000;">dc2(3, 11, 1995);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">dc2.Print(); <span style=" color: #008000;">// 03.11.1995</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Здесь у конструктора с параметрами для каждого параметра определено значение по умолчанию, следовательно, он может работать и как конструктор по умолчанию (вызывается со значениями по умолчанию для всех параметров) и как конструктор с параметрами (вызывается со значениями параметров, указанными пользователем).</p><p class="s12" style="padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Неявно генерируемый конструктор по умолчанию</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Если класс не имеет явно определенных конструкторов, то компилятор автоматически сгенерирует для него</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">конструктор по умолчанию. Такой конструктор называют <b>неявным конструктором </b>или <b>неявно сгенерированным конструктором</b>. Рассмотрим следующий класс:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">DateClass</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">day; </span>unsigned <span style=" color: #000;">month; </span>unsigned <span style=" color: #000;">year;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">У этого класса конструктор не определен, поэтому компилятор сгенерирует следующий конструктор по умолчанию:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">DateClass</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">day; </span>unsigned <span style=" color: #000;">month; </span>unsigned <span style=" color: #000;">year; </span>public<span style=" color: #000;">:</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// неявно генерируемый конструктор</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">DateClass()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Такой конструктор позволяет создавать экземпляры класса, но не выполняет их инициализацию и каких-либо дополнительных действий. При использовании неявного конструктора следует быть готовым к тому, что члены-данные класса будут содержать неинициализированные (мусорные) значения.</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">Если в классе определен хотя бы один конструктор, то неявно генерируемый конструктор создаваться не будет. Рекомендуется всегда создавать по крайней мере один конструктор в классе, это позволит контролировать процесс создания объектов класса, и предотвратит возникновение потенциальных проблем после добавления других</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">конструкторов.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 10pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s14" style=" background-color: #0F0;">Лекция 4 Список инициализации. Деструкторы. Конструктор</span><span class="s16"> копирования.</span></p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Список инициализации членов класса</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В примерах ранее мы инициализировали члены класса в конструкторе, используя оператор присваивания. При таком подходе сначала создаются члены-данные, а затем выполняется тело конструктора, где этим переменным</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">присваиваются значения. Однако некоторые типы данных (например, константы и ссылки) должны быть инициализированы сразу. Так, например, такой код не будет скомпилирован:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Value</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">const int <span style=" color: #000;">value; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Value() <span style=" color: #008000;">// Value::value: требуется инициализация в списке инициализации базовых классов и членов</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">value = 3; <span style=" color: #008000;">// левостороннее значение указывает на объект-константу (const)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Ошибка компиляции происходит, поскольку приведенный код аналогичен следующему коду (без привязки к ООП):</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">const int </span>value; <span style=" color: #008000;">// объект const необходимо инициализировать, если он не внешний </span>value = 3; <span style=" color: #008000;">// value: невозможно присваивать значения переменной, которая объявлена как константа</span></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Для решения этой проблемы в C++ добавили возможность инициализации членов-данных класса через список</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">инициализации после объявления конструктора, вместо присваивания им значений после объявления. Синтаксис списка инициализации следующий:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">&lt;имя конструктора&gt;(&lt;список параметров&gt;):&lt;список инициализации&gt;</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Сам список инициализации представляет собой конструкцию вида:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">&lt;имя поля&gt;(&lt;значение&gt;),...</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Таким образом поставленную выше проблему можно решить следующим образом:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Value</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">const int <span style=" color: #000;">value; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Value(): value(3)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Такая конструкция <span class="s9">переменная(значение) </span>называется <b>прямой инициализацией </b>и может использоваться для</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">переменных любых типов, для переменных-объектов, такая инициализация подразумевает вызов конструктора, для переменных базовых типов – присваивание значения. Использование прямой инициализации возможно наряду с уже известной вам <b>копирующей</b></p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">инициализацией<span class="p">, причем не только в списке инициализации.</span></h3><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{<span style=" color: #00F;">int </span>a = 3; <span style=" color: #008000;">// копирующая инициализация </span><span style=" color: #00F;">int </span>b(5); <span style=" color: #008000;">// прямая инициализация </span>printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, a); <span style=" color: #008000;">// 3</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, b); <span style=" color: #008000;">// 5 </span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Список инициализации, можно использовать и для выполнения инициализации и обычных членов-данных (не только констант и ссылок), при этом если в конструкторе подразумевается только инициализация полей, то тело</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">конструктора может быть пустым, а код инициализации заменен списком. В качестве значений в списке</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">инициализации можно использовать имена параметров конструктора. Рассмотрим классический вариант, где значения полей присваиваются в конструкторе:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">m_x, m_y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x </span>= 0.0, <span style=" color: #00F;">double </span><span style=" color: #808080;">y </span>= 0.0)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">m_x = <span style=" color: #808080;">x</span>; m_y = <span style=" color: #808080;">y</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">print()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;(%lf, %lf)&quot;</span>, m_x, m_y);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Такой вариант можно переписать, используя список инициализации:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">m_x, m_y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x </span>= 0.0, <span style=" color: #00F;">double </span><span style=" color: #808080;">y </span>= 0.0): m_x(<span style=" color: #808080;">x</span>), m_y(<span style=" color: #808080;">y</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">print()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;(%lf, %lf)&quot;</span>, m_x, m_y);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-bottom: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point <span style=" color: #000;">a;</span></p><table style="border-collapse:collapse;margin-left:5.3pt" cellspacing="0"><tr style="height:11pt"><td style="width:76pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">a.Print(); <span style=" color: #008000;">//</span></p></td><td style="width:54pt"><p class="s8" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: center;">(0.000000,</p></td><td style="width:53pt"><p class="s8" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">0.000000)</p></td></tr><tr style="height:12pt"><td style="width:76pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p></td><td style="width:54pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:53pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:12pt"><td style="width:76pt"><p class="s19" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Point <span style=" color: #000;">b(5);</span></p></td><td style="width:54pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:53pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:12pt"><td style="width:76pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">b.Print(); <span style=" color: #008000;">//</span></p></td><td style="width:54pt"><p class="s8" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: center;">(5.000000,</p></td><td style="width:53pt"><p class="s8" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: right;">0.000000)</p></td></tr><tr style="height:12pt"><td style="width:76pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p></td><td style="width:54pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:53pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:12pt"><td style="width:76pt"><p class="s19" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Point <span style=" color: #000;">c(1, 4);</span></p></td><td style="width:54pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:53pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:12pt"><td style="width:76pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">c.Print(); <span style=" color: #008000;">//</span></p></td><td style="width:54pt"><p class="s8" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: center;">(1.000000,</p></td><td style="width:53pt"><p class="s8" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: right;">4.000000)</p></td></tr><tr style="height:11pt"><td style="width:76pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">getchar();}</p></td><td style="width:54pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:53pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В данном примере мы использовали традиционное именование членов-данных в виде m_имя, такая традиция</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">именования исходит из предпосылок, что все члены-данные закрыты и преследует цель избежать конфликта имён. Сам по себе префикс m обязан английскому слову member – член (класса). При желании можете использовать такой олдскульный подход, но в настоящее время это не является обязательным. т.к. современные компиляторы и среды разработки достаточно сообразительны, что бы различить поля и параметры по их использованию в выражениях.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Ниже показан еще один вариант реализации этого класса, когда имена параметров конструктора и членов класса совпадают:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x </span>= 0.0, <span style=" color: #00F;">double </span><span style=" color: #808080;">y </span>= 0.0): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">...</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Деструкторы</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">Деструктор — это специальный тип метода класса, который выполняется при удалении объекта класса. В то время как конструкторы предназначены для инициализации класса, деструкторы предназначены для очистки памяти после</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">него.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Когда объект автоматически выходит из области видимости или динамически выделенный объект явно удаляется с помощью оператора delete, вызывается деструктор класса (если он существует) для выполнения необходимых</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">действий очистки (как правило, это действия по освобождению ресурсов) до того, как объект будет удален из памяти. Для простых классов (тех, которые только инициализируют значения обычных переменных-членов) явно определять деструктор нет необходимости, т.к. с задачей освобождения занятой объектами памяти справится и автоматически</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">сгенерированный деструктор. Однако, если объект класса содержит любые ресурсы (например, динамически</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">выделенную память, указатель на открытый файл, открытые присоединения к БД), или если необходимо выполнить какие-либо специфические действия до того, как объект будет уничтожен, деструктор является идеальным решением, поскольку он производит последние действия с объектом перед его окончательным уничтожением. Так же, как и</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">конструкторы, деструкторы имеют свои особенности именования:</p><ul id="l4"><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;line-height: 14pt;text-align: left;">деструктор должен иметь то же имя, что и класс, со знаком тильда (~) в самом начале;</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;text-align: left;">деструктор не может принимать аргументы;</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;text-align: left;">деструктор не имеет возвращаемого значения.</p></li></ul><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Из второго правила вытекает еще одно правило: для каждого класса может существовать только один деструктор, так как нет возможности <b>перегрузить </b>деструкторы, поскольку перегруженные функции должны отличаться набором</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">параметров. Синтаксис определения деструктора:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">~&lt;имя класса&gt;()</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Аналогично автоматически генерируемому конструктору по умолчанию, если для класса явно не определен</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">деструктор, то он будет сгенерирован автоматически. Однако он сделает возможным только удаление экземпляра класса, но если речь идет об освобождении ресурсов, либо выполнении еще каких-то специфических действий. то без явно определенного деструктора – не обойтись. Рассмотрим деструктор на примере класса массив.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Array</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double<span style=" color: #000;">* data; </span>unsigned <span style=" color: #000;">size; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Array(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">size </span>= 0)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Create\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">size</span>]; <span style=" color: #00F;">this</span>-&gt;size = <span style=" color: #808080;">size</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~Array()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Destroy\n&quot;</span>); <span style=" color: #00F;">delete </span>[]data;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double<span style=" color: #000;">&amp; Element(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">GetSize(){</span>return <span style=" color: #000;">size;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">ArrayWork()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Array <span style=" color: #000;">a(5);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt; a.GetSize(); i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">a.Element(i) = i*i;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt; a.GetSize(); i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%lf &quot;</span>, a.Element(i));</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">ArrayWork(); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">После запуска программы получим следующий вывод:</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Create</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">0.000000 1.000000 4.000000 9.000000 16.000000</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Destroy</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Конструктор копирования</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Сначала рассмотрим пример:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span><span style=" color: #000;">{ </span>private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x </span>= 0.0, <span style=" color: #00F;">double </span><span style=" color: #808080;">y </span>= 0.0): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;"><span style=" color: #00F;">void </span>MoveX(<span style=" color: #00F;">double </span><span style=" color: #808080;">dx</span>){<span style=" color: #00F;">this</span>-&gt;x += <span style=" color: #808080;">dx</span>;} <span style=" color: #00F;">void </span>MoveY(<span style=" color: #00F;">double </span><span style=" color: #808080;">dy</span>){<span style=" color: #00F;">this</span>-&gt;y += <span style=" color: #808080;">dy</span>;} <span style=" color: #00F;">void </span>Print()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;(%lf, %lf)&quot;</span>, x, y);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">Point </span>Move(<span style=" color: #2B91AE;">Point </span><span style=" color: #808080;">a</span>, <span style=" color: #00F;">double </span><span style=" color: #808080;">dx</span>, <span style=" color: #00F;">double </span><span style=" color: #808080;">dy</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Point </span>r = <span style=" color: #808080;">a</span>; r.MoveX(<span style=" color: #808080;">dx</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">r.MoveY(<span style=" color: #808080;">dy</span>); <span style=" color: #00F;">return </span>r;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point <span style=" color: #000;">p1(3, 7);</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point <span style=" color: #000;">p2 = Move(p1, -5, 2);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">p2.Print(); <span style=" color: #008000;">// (-2.000000, 9.000000)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">С первого взгляда может показаться, что конструктор здесь вызывается всего один раз, в строке Point a(3, 7), однако это совсем не так. В строке Point b = Move(a, -5, 2) происходит вызов конструктора 3 раза.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Первый раз – при копировании объекта p1 на стек, при вызове Move(p1, -5, 2). Второй раз – при выполнении</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">присваивания Point r = a. Третий – при выполнении return r, здесь создается временная копия объекта, для возврата значения.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Во всех этих случаях вызывается, так называемый <b>конструктор копирования</b>. Также, как и с конструктором по умолчанию, если он не был определен явно, то компилятор автоматически создаёт конструктор побитового копирования. Определяется конструктор копирования следующим образом:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">&lt;имя класса&gt;(const &lt;имя класса&gt; &amp;&lt;имя параметра&gt;)</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Фактически в конструктор копирования передаётся константная ссылка на объект, копию которого необходимо сконструировать. Можем расширить наш класс конструктором копирования:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x </span>= 0.0, <span style=" color: #00F;">double </span><span style=" color: #808080;">y </span>= 0.0): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Create(%lf, %lf)\n&quot;</span>, <span style=" color: #808080;">x</span>, <span style=" color: #808080;">y</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}Point(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Point </span>&amp; <span style=" color: #808080;">p</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">x = <span style=" color: #808080;">p</span>.x;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">y = <span style=" color: #808080;">p</span>.y;</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Copy(%lf, %lf)\n&quot;</span>, <span style=" color: #808080;">p</span>.x, <span style=" color: #808080;">p</span>.y);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;"><span style=" color: #00F;">void </span>MoveX(<span style=" color: #00F;">double </span><span style=" color: #808080;">dx</span>){<span style=" color: #00F;">this</span>-&gt;x += <span style=" color: #808080;">dx</span>;} <span style=" color: #00F;">void </span>MoveY(<span style=" color: #00F;">double </span><span style=" color: #808080;">dy</span>){<span style=" color: #00F;">this</span>-&gt;y += <span style=" color: #808080;">dy</span>;} <span style=" color: #00F;">void </span>Print()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;(%lf, %lf)&quot;</span>, x, y);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Point </span>Move(<span style=" color: #2B91AE;">Point </span><span style=" color: #808080;">a</span>, <span style=" color: #00F;">double </span><span style=" color: #808080;">dx</span>, <span style=" color: #00F;">double </span><span style=" color: #808080;">dy</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Point </span>r = <span style=" color: #808080;">a</span>; r.MoveX(<span style=" color: #808080;">dx</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">r.MoveY(<span style=" color: #808080;">dy</span>); <span style=" color: #00F;">return </span>r;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point <span style=" color: #000;">p1(3, 7);</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point <span style=" color: #000;">p2 = Move(p1, -5, 2); p2.Print();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">После запуска программы получим следующий вывод. который подтверждает, сказанное выше:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Create(3.000000, 7.000000)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Copy(3.000000, 7.000000)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Copy(3.000000, 7.000000)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Copy(-2.000000, 9.000000)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">(-2.000000, 9.000000)</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Стоит сказать, что фактически в данной реализации наш конструктор копирования выполняет теже функции, что и автоматический конструктор копирования, и весь приведенный код отработал бы и с ним. Зачем же тогда явно определять конструктор копирования? Дело в том, что автоматический конструктор копирования выполняет</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">побитовое копирование объекта, этого достаточно для простых классов, а вот, например, если в классе есть поля, указывающие на динамические объекты, то после такого копирования, будет два объекта, поля которых хранят адреса одной и той же области памяти. В таком случае, при удалении одного из них, второй останется</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">неработоспособным, т.к. его поле будет ссылаться на освобожденную область памяти. Рассмотрим на примере класса массив, сначала без конструктора копирования:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Array</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double<span style=" color: #000;">* data;</span>unsigned <span style=" color: #000;">size; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Array(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">size </span>= 0)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Create\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">size</span>]; <span style=" color: #00F;">this</span>-&gt;size = <span style=" color: #808080;">size</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">~Array()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Destroy\n&quot;</span>); <span style=" color: #00F;">delete </span>[]data;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double<span style=" color: #000;">&amp; Element(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">GetSize(){</span>return <span style=" color: #000;">size;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Array <span style=" color: #000;">*a = </span><span style=" color: #00F;">new </span>Array<span style=" color: #000;">(5);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt; a-&gt;GetSize(); i++) a-&gt;Element(i) = i*i;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; a-&gt;GetSize(); i++) printf(<span style=" color: #A21515;">&quot;%lf &quot;</span>, a-&gt;Element(i));</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Array <span style=" color: #000;">b = *a; </span><span style=" color: #008000;">// вызов автоматически сгенерированного конструктора копирования</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">delete <span style=" color: #000;">a;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; b.GetSize(); i++) printf(<span style=" color: #A21515;">&quot;%lf &quot;</span>, b.Element(i)); printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">При выводе элементов массива b явно пошло что-то не так. А причина такого поведения программы кроется в том, что на момент печати массива. физическое хранилище (data) уже было освобождено, при вызове деструктора массива a.</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Теперь добавим в класс конструктор копирования и выполним тот-же код:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Array</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{<span style=" color: #00F;">private</span>:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double<span style=" color: #000;">* data; </span>unsigned <span style=" color: #000;">size; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Array(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">size </span>= 0)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Create\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">size</span>]; <span style=" color: #00F;">this</span>-&gt;size = <span style=" color: #808080;">size</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Array(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Array </span>&amp; <span style=" color: #808080;">a</span>) <span style=" color: #008000;">// конструктор копирования</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Copy\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">a</span>.size]; size = <span style=" color: #808080;">a</span>.size;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">a</span>.size; i++) data[i] = <span style=" color: #808080;">a</span>.data[i];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~Array()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Destroy\n&quot;</span>); <span style=" color: #00F;">delete </span>[]data;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double<span style=" color: #000;">&amp; Element(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">GetSize(){</span>return <span style=" color: #000;">size;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Array <span style=" color: #000;">*a = </span><span style=" color: #00F;">new </span>Array<span style=" color: #000;">(5);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt; a-&gt;GetSize(); i++) a-&gt;Element(i) = i*i;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; a-&gt;GetSize(); i++) printf(<span style=" color: #A21515;">&quot;%lf &quot;</span>, a-&gt;Element(i)); printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Array <span style=" color: #000;">b = *a; </span><span style=" color: #008000;">// вызов явно определенного конструктора копирования</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">delete <span style=" color: #000;">a;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; b.GetSize(); i++) printf(<span style=" color: #A21515;">&quot;%lf &quot;</span>, b.Element(i)); printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В этом случае мы видим ожидаемый вывод, т.к. в конструкторе копирования реализовали выделение памяти для хранилища данных массива b, и перенесли туда данные из массива a. При этом освобождение хранилища массива a никак не сказалось на поведении массива b.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 10pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s14" style=" background-color: #0F0;">Лекция 5 Классы и константы. Раздельное объявление и</span><span class="s16"> определение классов. Статические члены классов.</span></p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Классы и константы</p><p class="s12" style="padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Константные объекты классов</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">Объекты классов можно сделать константными (используя ключевое слово const). Инициализация таких объектов выполняется посредством конструкторов. После инициализации такого объекта любая попытка изменить члены-данные (поля) объекта запрещена, так как это нарушает принципы константности объекта. Запрещается как</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">изменение членов-данных напрямую, если они являются открытыми (public), так и вызов методов (сеттеров) с помощью которых можно</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">установить значения членам-данным. Определяются константные объекты с помощью следующего синтаксиса:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">const &lt;имя класса&gt;<b>[</b>(&lt;фактические параметры конструктора&gt;)<b>]</b></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Рассмотрим на примере:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">x, y;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x </span>= 0.0, <span style=" color: #00F;">double </span><span style=" color: #808080;">y </span>= 0.0): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;"><span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">void </span>SetY(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">double </span>GetX() {<span style=" color: #00F;">return </span>x;}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">double <span style=" color: #000;">GetY() {</span>return <span style=" color: #000;">y;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">const <span style=" color: #2B91AE;">Point </span><span style=" color: #000;">p1;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">p1.x = 5; <span style=" color: #008000;">// невозможно присваивать значения переменной, которая объявлена как константа</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">p1.SetX(5); <span style=" color: #008000;">// невозможно преобразовать указатель &quot;this&quot; из &quot;const Point&quot; в &quot;Point</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">&amp;&quot;</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">const <span style=" color: #2B91AE;">Point </span><span style=" color: #000;">p2(-5, 2);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">p2.x = 3; <span style=" color: #008000;">// невозможно присваивать значения переменной, которая объявлена как константа</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">p2.SetX(3); <span style=" color: #008000;">// невозможно преобразовать указатель &quot;this&quot; из &quot;const Point&quot; в &quot;Point</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">&amp;&quot; <span style=" color: #000;">getchar();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Строки кода, в которых мы пытаемся менять состояние объекта вызывают ошибки компиляции. т.к. они нарушают принципы константности объекта, пытаясь изменить переменную-член напрямую или посредством вызова сеттера. <span class="s12">Константные методы классов</span></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Если продолжить предыдущий пример и попытаться вызвать метод-геттер, то к удивлению также получим ошибку:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">p1x = p1.GetX(); </span><span style=" color: #008000;">// невозможно преобразовать указатель &quot;this&quot; из &quot;const Point&quot; в</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">&quot;Point &amp;&quot;</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Дело в том, что константные объекты могут явно вызывать только константные методы класса, а GetX() таковым не является. <b>Константный метод </b>— это метод, который гарантированно не изменяет объект и не вызывает</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">неконстантные методы класса (поскольку они могут изменить объект). Для объявления константных методов используют следующий синтаксис:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">&lt;тип возвращаемого значения&gt; &lt;имя метода&gt;(<b>[</b>&lt;список параметров&gt;<b>]</b>) const</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Модифицируем наш пример:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">x, y;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x </span>= 0.0, <span style=" color: #00F;">double </span><span style=" color: #808080;">y </span>= 0.0): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">void </span>SetY(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">double </span>GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;} <span style=" color: #00F;">double </span>GetY() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>y;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">const <span style=" color: #2B91AE;">Point </span><span style=" color: #000;">p1;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">p1x = p1.GetX(); </span><span style=" color: #008000;">// ок</span></p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">const <span style=" color: #2B91AE;">Point </span><span style=" color: #000;">p2(-5, 2);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">p2x = p1.GetX(); </span><span style=" color: #008000;">// ок</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Теперь методы GetX() и GetY()можно вызывать для константных объектов. Если в определении константного метода попытаться изменить значение поля данных или вызвать неконстантный метод. это также приведет к ошибке компиляции:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">x, y;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x </span>= 0.0, <span style=" color: #00F;">double </span><span style=" color: #808080;">y </span>= 0.0): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;"><span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">void </span>SetY(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">double </span>GetX() <span style=" color: #00F;">const</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">x = 0; <span style=" color: #008000;">// &quot;x&quot; не может быть изменен, поскольку доступ к нему осуществляется через константный объект</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">SetX(0); <span style=" color: #008000;">// невозможно преобразовать указатель &quot;this&quot; из &quot;const Point&quot; в</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">&quot;Point &amp;&quot; <span style=" color: #00F;">return </span><span style=" color: #000;">x;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">GetY() </span>const <span style=" color: #000;">{</span>return <span style=" color: #000;">y;}};</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Следует обратить внимание, что конструкторы не могут быть константными. Это связано с тем, что они должны иметь возможность инициализировать поля-данных класса, а константный метод по определению этого сделать не может. Следовательно, в языке С++ конструкторы всегда являются неконстантными. Стоит отметить, что константный объект класса может создаваться с помощью любого конструктора, в том числе и с помощью автоматически</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">сгенерированного конструктора по умолчанию, в этом случае члены-данные будут иметь неинициализированные значения, которые</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">впоследствии невозможно будет изменить.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">void </span>SetY(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">double </span>GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;} <span style=" color: #00F;">double </span>GetY() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>y;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">const <span style=" color: #2B91AE;">Point </span><span style=" color: #000;">p1;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Point(%.2lf, %.2lf)&quot;</span>, p1.GetX(), p1.GetY());</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// Point(-92559631349317831000000000000000000000000000000000000000000000.00, -92559631349317831000000000000000000000000000000000000000000000.00)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В приведенном выше примере поля x и y не инициализированы, поскольку конструктор явно не определен и для</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">создания объектов использован автоматически сгенерированный конструктор по умолчанию. И при этом, поскольку объект является константным, значения этих полей невозможно изменить.</p><p class="s12" style="padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">Константные ссылки на объекты</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Ранее мы рассмотрели преимущества передачи аргументов в функции ссылке, нежели по значению. Если вкратце, то передача аргументов по значению создает копию значения (что является медленным и затратным по памяти</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">процессом). В большинстве случаев копия данных в действительности не нужна, а ссылка уже указывает на исходный аргумент и является более эффективной, так как не приводит к необходимости создания копии данных. Если</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">требуется гарантировать, что функция не изменит значение аргумента, то используют константную ссылку. При работе с объектными параметрами функций придерживаются той же логики. Рассмотрим пример. Реализуем класс «точка» и функцию (не метод класса) вывода точки на печать, принимающую константную ссылку на экземпляр класса «точка»:</p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x </span>= 0.0, <span style=" color: #00F;">double </span><span style=" color: #808080;">y </span>= 0.0): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>) {</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;"><span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">void </span>SetY(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">double </span>GetX() {<span style=" color: #00F;">return </span>x;}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">double <span style=" color: #000;">GetY() {</span>return <span style=" color: #000;">y;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">};<span style=" color: #00F;">void </span>PrintPoint(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Point </span>&amp;<span style=" color: #808080;">p</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;(%.2lf, %.2lf)&quot;</span>, <span style=" color: #808080;">p</span>.GetX(), <span style=" color: #808080;">p</span>.GetY());</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point <span style=" color: #000;">p1(2.5, -3.1);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">PrintPoint(p1); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">На первый взгляд в приведенном коде все неплохо, но есть один момент: данную программу невозможно</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">скомпилировать, т.к. строка кода printf(&quot;(%.2lf, %.2lf)&quot;, p.GetX(), p.GetY()) в теле функции PrintPoint будет вызывать</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">ошибку «невозможно преобразовать указатель &quot;this&quot; из &quot;const Point&quot; в &quot;Point &amp;&quot;». Проблема заключается в том, что в теле функции PrintPoint объект p будет интерпретирован как константный (хотя p1 в функции main таковым не</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">является) и соответственно</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">мы пытаемся вызвать неконстантные методы GetX() и GetY для константного объекта. Решением в данной ситуации будет сделать эти методы константными, как в примере выше.</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Все методы класса, которые не изменяют состояние объекта следует делать константными. Это необходимо для возможности полноценной работы с экземплярами классов посредством константных объектов и константных ссылок.</h3><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Раздельное объявление и определение классов</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">До сих пор мы рассматривали совместное объявление и определение классов, однако в языке C++ можно разделять объявление и определение функций в том числе по отношению к методам класса. В этом случае в объявлении класса указываются только прототипы методов, а определение следует далее, вне тела класса с использованием</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">следующего синтаксиса:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">&lt;тип значения&gt; &lt;имя_класса&gt;::&lt;имя метода&gt;(<b>[</b>&lt;список параметров&gt;<b>]</b>)</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">{&lt;тело функции&gt;}</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Рассмотрим на примере класса точка:</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// объявление класса</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point(<span style=" color: #00F;">double </span>x = 0.0, <span style=" color: #00F;">double </span>y = 0.0); <span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">double </span>value);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">SetY(</span>double <span style=" color: #000;">value); </span>double <span style=" color: #000;">GetX() </span>const<span style=" color: #000;">; </span>double <span style=" color: #000;">GetY() </span>const<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// определение класса</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Point</span>::Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">double </span><span style=" color: #808080;">y</span>): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>) { } <span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetX(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetY(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">double </span><span style=" color: #2B91AE;">Point</span>::GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;} <span style=" color: #00F;">double </span><span style=" color: #2B91AE;">Point</span>::GetY() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>y;}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Следует помнить, что значение параметров по умолчанию допустимо указывать либо в объявлении метода, либо в его определении, указывать их и в объявлении метода и в определении – не допускается. Спецификатор const,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">определяющий константные методы наоборот указывается и в объявлении, и в определении метода. Более того</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">реализацию класса можно разнести на два файла. В этом случае определение класса помещается в заголовочный (.h)</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">файл с тем же именем, что и имя класса, а определение в файл реализации (.cpp) с тем же именем, что и имя класса.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Модифицируем наш пример и разобьем ш проект на 3 файла - объявление класса, определение класса и код основной программы: Текст заголовочного файла <b>Point.h </b>(объявление класса Point):</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// объявление класса Point</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point(<span style=" color: #00F;">double </span>x = 0.0, <span style=" color: #00F;">double </span>y = 0.0); <span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">double </span>value);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">SetY(</span>double <span style=" color: #000;">value); </span>double <span style=" color: #000;">GetX() </span>const<span style=" color: #000;">; </span>double <span style=" color: #000;">GetY() </span>const<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Текст файла реализации <b>Point.cpp </b>(определение класса Point):</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">#include <span style=" color: #A21515;">&quot;Point.h&quot;</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// определение класса</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Point</span>::Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">double </span><span style=" color: #808080;">y</span>): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>) { } <span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetX(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetY(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">double </span><span style=" color: #2B91AE;">Point</span>::GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;} <span style=" color: #00F;">double </span><span style=" color: #2B91AE;">Point</span>::GetY() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>y;}</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Текст файла реализации <b>source.cpp </b>(основная программа):</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">#include<span style=" color: #A21515;">&lt;stdio.h&gt; </span>#include<span style=" color: #A21515;">&quot;Point.h&quot;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>PrintPoint(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Point </span>&amp;<span style=" color: #808080;">p</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;(%.2lf, %.2lf)&quot;</span>, <span style=" color: #808080;">p</span>.GetX(), <span style=" color: #808080;">p</span>.GetY());</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;input first point coordinates:&quot;</span>); scanf(<span style=" color: #A21515;">&quot;%lf %lf&quot;</span>, &amp;x, &amp;y);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point <span style=" color: #000;">p1(x, y);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;input second point coordinates:&quot;</span>); scanf(<span style=" color: #A21515;">&quot;%lf %lf&quot;</span>, &amp;x, &amp;y);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Point </span>p2(x, y); printf(<span style=" color: #A21515;">&quot;your points:\n&quot;</span>); PrintPoint(p1); printf(<span style=" color: #A21515;">&quot;\n&quot;</span>); PrintPoint(p2); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}<span class="p">Разделение объявления класса и его реализации является хорошим тоном и значительно упрощает повторное использование классов. Для использования ранее написанного класса в своей программе необходимо добавить заголовочный файл (.h) и файл-реализации (.cpp) в ваш проект и подключить в файле-реализации программы</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">заголовочный файл с объявлением класса используя директиву препроцессора #include. Наличие собственных файлов, разделенных на объявление (.h) и реализацию (.cpp), является не только хорошей формой содержания кода, но и упрощает создание собственных пользовательских библиотек.</p><p class="s20" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Статические члены класса</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Кроме полей-данных и методов, которые относятся непосредственно к объекту, C++ позволяет определять поля и методы, которые относятся к классу в целом, или иначе говоря статические члены класса. Для их определения</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">используется ключевое слово static.</p><p class="s12" style="padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Статические поля-данных</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Начнем с рассмотрения примера простейшего класса:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Test</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">: </span>int <span style=" color: #000;">value; Test()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><table style="border-collapse:collapse;margin-left:5.3pt" cellspacing="0"><tr style="height:22pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">value = 0;</p><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p></td><td style="width:78pt" colspan="2" rowspan="6"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">};</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s21" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int <span style=" color: #000;">main()</span></p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">{</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s19" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Test <span style=" color: #000;">t1;</span></p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s19" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Test <span style=" color: #000;">t2;</span></p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>,</p></td><td style="width:58pt"><p class="s17" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: right;">t1.value);</p></td><td style="width:20pt"><p class="s8" style="padding-left: 1pt;padding-right: 1pt;text-indent: 0pt;line-height: 10pt;text-align: center;">//0</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>,</p></td><td style="width:58pt"><p class="s17" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: right;">t2.value);</p></td><td style="width:20pt"><p class="s8" style="padding-left: 1pt;padding-right: 1pt;text-indent: 0pt;line-height: 10pt;text-align: center;">//0</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">t1.value = 5;</p></td><td style="width:58pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:20pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>,</p></td><td style="width:58pt"><p class="s17" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: right;">t1.value);</p></td><td style="width:20pt"><p class="s8" style="padding-left: 1pt;padding-right: 1pt;text-indent: 0pt;line-height: 10pt;text-align: center;">//5</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>,</p></td><td style="width:58pt"><p class="s17" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: right;">t2.value);</p></td><td style="width:20pt"><p class="s8" style="padding-left: 1pt;padding-right: 1pt;text-indent: 0pt;line-height: 10pt;text-align: center;">//0</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">getchar();</p></td><td style="width:58pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:20pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:11pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">}</p></td><td style="width:58pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:20pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Вывод программы вполне ожидаем. Теперь немного изменим объявление класса и сделаем поле value статическим, при этом определение класса также несколько изменится, об этом несколько позже:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Test</span><span style=" color: #000;">{ </span>public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">static int <span style=" color: #000;">value; Test() {}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #2B91AE;">Test</span><span style=" color: #000;">::value = 0; </span>int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-bottom: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">Test <span style=" color: #000;">t1; </span>Test <span style=" color: #000;">t2;</span></p><table style="border-collapse:collapse;margin-left:5.3pt" cellspacing="0"><tr style="height:11pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>,</p></td><td style="width:58pt"><p class="s17" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">t1.value);</p></td><td style="width:20pt"><p class="s8" style="padding-left: 1pt;padding-right: 1pt;text-indent: 0pt;line-height: 9pt;text-align: center;">//0</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>,</p></td><td style="width:58pt"><p class="s17" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: right;">t2.value);</p></td><td style="width:20pt"><p class="s8" style="padding-left: 1pt;padding-right: 1pt;text-indent: 0pt;line-height: 10pt;text-align: center;">//0</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">t1.value = 5;</p></td><td style="width:58pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:20pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>,</p></td><td style="width:58pt"><p class="s17" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: right;">t1.value);</p></td><td style="width:20pt"><p class="s8" style="padding-left: 1pt;padding-right: 1pt;text-indent: 0pt;line-height: 10pt;text-align: center;">//5</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>,</p></td><td style="width:58pt"><p class="s17" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: right;">t2.value);</p></td><td style="width:20pt"><p class="s8" style="padding-left: 1pt;padding-right: 1pt;text-indent: 0pt;line-height: 10pt;text-align: center;">//5</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">getchar();</p></td><td style="width:58pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:20pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:11pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">}</p></td><td style="width:58pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:20pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В данном случае, вывод той-же программы будет иным, изменение значение value через объект t1 повлияло на это же значение для объекта t2. Дело в том, что статические поля данных «принадлежат» конкретным экземплярам</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">объектов, а классу в целом. Они используются для работы с некоторой «глобальной» информацией класса, для хранения совместно используемых всеми экземплярами классов ресурсов и т.д. При объявлении статического поля-</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">данных в классе, мы сообщаем компилятору о существовании такой переменной, но не о её определении. Поскольку статические члены-данных не являются частью конкретных экземпляров класса, а обрабатываются аналогично</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">глобальным переменным и инициализируются при запуске программы, то необходимо явно определить статический член вне тела класса — в глобальной области видимости. именно это мы и сделали в строке кода int Test::value = 0.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Как любые статические переменные, статические поля класса создаются в начале работы программы и существуют до её закрытия. их время жизни никак не связано с временем жизни отдельных экземпляров класса. Стоит обратить</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">внимание, что определение</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">статических полей-данных не попадает под действие спецификаторов доступа: вы можете определить и</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">инициализировать такой член-класса только вне тела класса, даже если он будет закрытым (private или protected).</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Если объявление и определение класса разнесено на два файла, то определение статических полей обычно помещают в файл-реализации класса (.cpp). Не рекомендуется выносить определение статических полей в</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">заголовочный файл (подобно глобальным переменным), т.к. при подключении этого файла более одного раза, происходит многократное определение одного</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">члена-класса, что приводит к ошибке компиляции. Если класс определен в одном файле, то определение статических полей обычно пишется непосредственно под классом. Рассмотрим пример использования статического поля данных для генерации уникальных идентификаторов объектов класса точка:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">static int <span style=" color: #000;">last_id; </span><span style=" color: #008000;">// статический член данных</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">id;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:Point(</span>double <span style=" color: #000;">x = 0.0, </span>double <span style=" color: #000;">y = 0.0);</span></p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">SetX(</span>double <span style=" color: #000;">value); </span>void <span style=" color: #000;">SetY(</span>double <span style=" color: #000;">value); </span>double <span style=" color: #000;">GetX() </span>const<span style=" color: #000;">; </span>double <span style=" color: #000;">GetY() </span>const<span style=" color: #000;">; </span>int <span style=" color: #000;">GetId() </span>const<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">int </span><span style=" color: #2B91AE;">Point</span>::last_id; <span style=" color: #008000;">// определение статического члена данных </span><span style=" color: #2B91AE;">Point</span>::Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">double </span><span style=" color: #808080;">y</span>): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>) {id = last_id++;} <span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetX(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetY(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">double </span><span style=" color: #2B91AE;">Point</span>::GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;} <span style=" color: #00F;">double </span><span style=" color: #2B91AE;">Point</span>::GetY() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>y;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">int </span><span style=" color: #2B91AE;">Point</span>::GetId() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>id;} <span style=" color: #00F;">void </span>PrintPoint(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Point </span>&amp;<span style=" color: #808080;">p</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Point(%.2lf, %.2lf); id:%d;&quot;</span>, <span style=" color: #808080;">p</span>.GetX(), <span style=" color: #808080;">p</span>.GetY(), <span style=" color: #808080;">p</span>.GetId());</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point <span style=" color: #000;">p1(3.5, 0.5);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">PrintPoint(p1); printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point <span style=" color: #000;">p2(-0.5, 0.0);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">PrintPoint(p2); printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point <span style=" color: #000;">p3(5.0, -1.5);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">PrintPoint(p3); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Как видим, поставленная задача решена без использования каких-либо сложных алгоритмов. Фактически у нас есть одна статическая переменная хранящая следующий идентификатор и один метод (конструктор) в котором это</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">значение меняется.</p><p class="s12" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Статические методы</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Начнем с продумывания реализации класса (пусть это будет класс точка, на самом деле совершенно не важно) в котором есть функционал подсчета количества созданных объектов. Очевидно, что это будет что-то похожее на</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">предыдущий класс с генерацией идентификаторов. У нас будет закрытое статическое поле данных, допустим count, значение которого будет</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">инкрементироваться каждый раз при вызове конструктора. Остаётся вопрос, как нам вернуть пользователю это значение? Можно написать открытый метод GetCount(), который будет вызываться для конкретного экземпляра класса и возвращать значение поля count:<span class="s3">class </span><span class="s10">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y; </span>static int <span style=" color: #000;">count; </span>int <span style=" color: #000;">id;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point(<span style=" color: #00F;">double </span>x = 0.0, <span style=" color: #00F;">double </span>y = 0.0); <span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">double </span>value);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">SetY(</span>double <span style=" color: #000;">value); </span>double <span style=" color: #000;">GetX() </span>const<span style=" color: #000;">; </span>double <span style=" color: #000;">GetY() </span>const<span style=" color: #000;">; </span>int <span style=" color: #000;">GetCount() </span>const<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #2B91AE;">Point</span><span style=" color: #000;">::count;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Point</span>::Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">double </span><span style=" color: #808080;">y</span>): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>) {count++;} <span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetX(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetY(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">double </span><span style=" color: #2B91AE;">Point</span>::GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;} <span style=" color: #00F;">double </span><span style=" color: #2B91AE;">Point</span>::GetY() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>y;}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #2B91AE;">Point</span><span style=" color: #000;">::GetCount() </span>const <span style=" color: #000;">{</span>return <span style=" color: #000;">count;} </span>int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point <span style=" color: #000;">p1(3.5, 0.5);</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, p1.GetCount()); <span style=" color: #008000;">//1 </span><span style=" color: #2B91AE;">Point </span>p2(-0.5, 0.0);</p><p class="s4" style="padding-bottom: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, p2.GetCount()); <span style=" color: #008000;">//2 </span><span style=" color: #2B91AE;">Point </span>p3(5.0, -1.5);</p><table style="border-collapse:collapse;margin-left:5.3pt" cellspacing="0"><tr style="height:11pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>,</p></td><td style="width:84pt"><p class="s17" style="padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: center;">p3.GetCount());</p></td><td style="width:21pt"><p class="s8" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">//3</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>,</p></td><td style="width:84pt"><p class="s17" style="padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: center;">p1.GetCount());</p></td><td style="width:21pt"><p class="s8" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: right;">//3</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>,</p></td><td style="width:84pt"><p class="s17" style="padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: center;">p2.GetCount());</p></td><td style="width:21pt"><p class="s8" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: right;">//3</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>,</p></td><td style="width:84pt"><p class="s17" style="padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: center;">p3.GetCount());</p></td><td style="width:21pt"><p class="s8" style="padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: right;">//3</p></td></tr><tr style="height:12pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">getchar();</p></td><td style="width:84pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:21pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:11pt"><td style="width:78pt"><p class="s17" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">}</p></td><td style="width:84pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:21pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Такое решение на первый взгляд является рабочим, но содержит ряд проблем. Предложенный подход</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">методологически некорректен, т.к. число объектов является свойством класса, а не объекта, как в нашей реализации. Как следствие, для того что бы узнать число созданных объектов нам нужен как минимум один объект класса, а также для разных экземпляров класса метод возвращает одинаковое значение. Для корректного решения поставленной</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">задачи необходимо использовать <b>статические методы</b>. Равно как и статические поля-данных статические методы привязаны не к конкретному экземпляру класса, а ко всему классу в целом. Рассмотрим реализацию этой задачи с использованием статического метода:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y; </span>static int <span style=" color: #000;">count; </span>int <span style=" color: #000;">id;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point(<span style=" color: #00F;">double </span>x = 0.0, <span style=" color: #00F;">double </span>y = 0.0); <span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">double </span>value);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">SetY(</span>double <span style=" color: #000;">value);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">GetX() </span>const<span style=" color: #000;">;</span>double <span style=" color: #000;">GetY() </span>const<span style=" color: #000;">;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">static int <span style=" color: #000;">GetCount(); </span><span style=" color: #008000;">// объявление статического метода</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #2B91AE;">Point</span><span style=" color: #000;">::count;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Point</span>::Point(<span style=" color: #00F;">double </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">double </span><span style=" color: #808080;">y</span>): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>) {count++;} <span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetX(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetY(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">double </span><span style=" color: #2B91AE;">Point</span>::GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;} <span style=" color: #00F;">double </span><span style=" color: #2B91AE;">Point</span>::GetY() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>y;}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #2B91AE;">Point</span><span style=" color: #000;">::GetCount() {</span>return <span style=" color: #000;">count;} </span><span style=" color: #008000;">// определение статического метода</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #008000;">// вызов статического метода по имени класса </span>printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, <span style=" color: #2B91AE;">Point</span>::GetCount()); <span style=" color: #008000;">//0 </span><span style=" color: #2B91AE;">Point </span>p1(3.5, 0.5);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, <span style=" color: #2B91AE;">Point</span>::GetCount()); <span style=" color: #008000;">//1 </span><span style=" color: #2B91AE;">Point </span>p2(-0.5, 0.0);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, <span style=" color: #2B91AE;">Point</span>::GetCount()); <span style=" color: #008000;">//2 </span><span style=" color: #2B91AE;">Point </span>p3(5.0, -1.5);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, <span style=" color: #2B91AE;">Point</span>::GetCount()); <span style=" color: #008000;">//3</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #008000;">// вызов статического метода по имени объекта </span>printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, p1.GetCount()); <span style=" color: #008000;">//3 </span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В данной реализации мы можем вызвать метод по имени класса, т.е. можем вызвать метод возвращающий число созданных экземпляров класса точка, не имея ни одного объекта, что само по себе более корректно. Однако,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">поскольку такие методы определены на уровне класса они могут вызываться и для конкретных объектов – результат будет тем-же. Статические методы могут обращаться только к другим статическим членам класса, поэтому при</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">использовании статических методов запрещён модификатор const, так как такие методы по определению не могут изменять нестатические поля. Также в статических методах недоступен указатель this, т.к. они вызываются</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">независимо от экземпляра, поэтому при необходимости</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">работы с нестатическими членами класса объект должен передаваться в статический метод явным образом. В качестве примера рассмотрим класс вектор со статическим методом нахождения суммы двух векторов</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">(справедливости ради замечу, что подобный функционал можно реализовать и нестатическим методом, а еще лучше через перегрузку операции «+»),</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">данный пример дан исключительно для демонстрации работы с нестатическими данными в статическом методе:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Vector</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector(<span style=" color: #00F;">double </span><span style=" color: #808080;">x </span>= 0, <span style=" color: #00F;">double </span><span style=" color: #808080;">y </span>= 0): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>){} <span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>SetY(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">double </span>GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;} <span style=" color: #00F;">double </span>GetY() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>y;}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//статический метод вычисления суммы</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">static </span><span style=" color: #2B91AE;">Vector </span>sum(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp;<span style=" color: #808080;">a</span>, <span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp;<span style=" color: #808080;">b</span>){<span style=" color: #00F;">return </span><span style=" color: #2B91AE;">Vector</span>(<span style=" color: #808080;">a</span>.x+<span style=" color: #808080;">b</span>.x, <span style=" color: #808080;">a</span>.y+<span style=" color: #808080;">b</span>.y);}};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector <span style=" color: #000;">a(1, 1);</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector <span style=" color: #000;">b(3, -3);</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector <span style=" color: #000;">c = </span>Vector<span style=" color: #000;">::sum(a, b);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;(%lf, %lf)&quot;</span>, c.GetX(), c.GetY()); <span style=" color: #008000;">//(4.000000, -2.000000) </span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Иногда статические методы используют для реализации специфических «конструкторов». Конечно формально такие методы не являются конструкторами, но реализуют функционал создания объектов и иногда использовать такие методы удобнее, чем конструкторы. Дополним класс вектор статическими методами, возвращающий орты i и j: <span class="s3">class </span><span class="s10">Vector</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector(<span style=" color: #00F;">double </span><span style=" color: #808080;">x </span>= 0, <span style=" color: #00F;">double </span><span style=" color: #808080;">y </span>= 0): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>){} <span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>SetY(<span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">double </span>GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;} <span style=" color: #00F;">double </span>GetY() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>y;}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #008000;">//статические методы создания ортов </span>static <span style=" color: #2B91AE;">Vector </span><span style=" color: #000;">i(){</span>return <span style=" color: #2B91AE;">Vector</span><span style=" color: #000;">(1, 0);} </span>static <span style=" color: #2B91AE;">Vector </span><span style=" color: #000;">j(){</span>return <span style=" color: #2B91AE;">Vector</span><span style=" color: #000;">(0, 1);}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector <span style=" color: #000;">i = </span>Vector<span style=" color: #000;">::i();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;(%lf, %lf)\n&quot;</span>, i.GetX(), i.GetY()); <span style=" color: #008000;">//(1.000000, 0.000000) </span><span style=" color: #2B91AE;">Vector </span>j = <span style=" color: #2B91AE;">Vector</span>::j();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;(%lf, %lf)\n&quot;</span>, j.GetX(), j.GetY()); <span style=" color: #008000;">//(0.000000, 1.000000) </span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Если все члены класса являются статическими такие классы называют «чисто статическими». Работа с такими классами не требует создания экземпляра класса (да и нет смысла, т.к. класс не содержит данных специфических для конкретного экземпляра), как правило в таком виде реализуются какие-то вспомогательные классы, выполняющие</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">некоторые рутинные операции, и в некотором смысле такие классы эквивалентны объявлению функций и</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">переменных в глобальной области видимости. Рассмотрим «чисто статический» класс генератор идентификаторов:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">IDGenerator</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">static unsigned <span style=" color: #000;">nextID; </span><span style=" color: #008000;">// объявление статической переменной-члена</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">static unsigned <span style=" color: #000;">getID(); </span><span style=" color: #008000;">// объявление статического метода</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// Определение статического поля-данных. Начинаем генерировать ID с 1</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #2B91AE;">IDGenerator</span><span style=" color: #000;">::nextID = 1;</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// Определение статического метода</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #2B91AE;">IDGenerator</span><span style=" color: #000;">::getID() { </span>return <span style=" color: #000;">nextID++; } </span>int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">unsigned </span>id1 = <span style=" color: #2B91AE;">IDGenerator</span>::getID();</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//...</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">unsigned </span>id100 = <span style=" color: #2B91AE;">IDGenerator</span>::getID();</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//... <span style=" color: #000;">getchar();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Как видим для генерации идентификаторов не понадобилось создавать ни одного экземпляра класса IDGenerator.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 10pt;padding-left: 7pt;text-indent: 0pt;line-height: 20pt;text-align: left;"><span class="s14" style=" background-color: #0F0;">Лекция 6 Дружественные функции и классы</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">При реализации взаимодействия различных классов может возникать необходимость обращения к закрытым или защищенным членам класса из внешних функций или классов. для реализации такого поведения в языке C++</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">существует концепция <b>дружественных </b>функций. методов или классов. Однако надо понимать, что при использовании такого механизма фактически происходит <b>нарушение инкапсуляции </b>и использовать такой подход стоит только тогда, когда это действительно необходимо. В качестве примера можно привести случай, когда необходимо получать доступ к внутренним данным класса, но делать это через открытые методы не эффективно, например, из-за недостаточной</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">скорости обращения к данным, либо такие методы вовсе не предусмотрены интерфейсом класса.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: justify;">Дружественные функции</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">Для объявления дружественных функций используют следующий синтаксис в любом месте объявления класса:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">friend &lt;тип значения&gt; &lt;имя функции&gt;(<b>[</b>&lt;список параметров&gt;<b>]</b>);</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">На примере реализации двух классов «вектор» и «матрица» сравним эффективность реализации функции умножения матрицы на вектор посредством доступа к данным через интерфейс класса и посредством прямого доступа к данным (дружественная функция):</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">Текст файла “Vector.h”:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Matrix</span><span style=" color: #000;">; </span>class <span style=" color: #2B91AE;">Vector</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">*data; </span>unsigned <span style=" color: #000;">size; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector(<span style=" color: #00F;">unsigned </span>size = 0); Vector(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp;v);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~Vector();</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">Elements(</span>unsigned <span style=" color: #000;">i) </span>const<span style=" color: #000;">; </span>double<span style=" color: #000;">&amp; Elements(</span>unsigned <span style=" color: #000;">i); </span>unsigned <span style=" color: #000;">GetSize();</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">friend <span style=" color: #2B91AE;">Vector </span><span style=" color: #000;">mul_friend(</span>const <span style=" color: #2B91AE;">Matrix </span><span style=" color: #000;">&amp;m, </span>const <span style=" color: #2B91AE;">Vector </span><span style=" color: #000;">&amp;v);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Текст файла “Vector.cpp”:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">#include <span style=" color: #A21515;">&quot;Vector.h&quot; </span><span style=" color: #2B91AE;">Vector</span><span style=" color: #000;">::Vector(</span>const unsigned <span style=" color: #808080;">size</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;size = <span style=" color: #808080;">size</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">size</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>i = 0; i &lt; <span style=" color: #808080;">size</span>; i++) data[i] = 0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">Vector</span>::Vector(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp;<span style=" color: #808080;">v</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">size = <span style=" color: #808080;">v</span>.size;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[size];<span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>i = 0; i &lt; size; i++) data[i] = <span style=" color: #808080;">v</span>.data[i];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector<span style=" color: #000;">::~Vector()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">delete <span style=" color: #000;">[] data;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #2B91AE;">Vector</span><span style=" color: #000;">::Elements(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">) </span>const</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= size) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index i is out of bounds&quot;</span>); <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">double </span>&amp;<span style=" color: #2B91AE;">Vector</span>::Elements(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">i</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= size) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index i is out of bounds&quot;</span>); <span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&lt; size) <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #2B91AE;">Vector</span><span style=" color: #000;">::GetSize()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">size;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Текст файла “Matrix.h”:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Vector</span><span style=" color: #000;">; </span>class <span style=" color: #2B91AE;">Matrix</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">**data; </span>unsigned <span style=" color: #000;">rows, cols; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Matrix(<span style=" color: #00F;">unsigned </span>rows = 0, <span style=" color: #00F;">unsigned </span>cols = 0); Matrix(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Matrix </span>&amp;m);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~Matrix();</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">Elements(</span>unsigned <span style=" color: #000;">i, </span>unsigned <span style=" color: #000;">j) </span>const<span style=" color: #000;">; </span>double <span style=" color: #000;">&amp;Elements(</span>unsigned <span style=" color: #000;">i, </span>unsigned <span style=" color: #000;">j); </span>unsigned <span style=" color: #000;">GetRows() </span>const<span style=" color: #000;">;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetCols() </span>const<span style=" color: #000;">;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">friend <span style=" color: #2B91AE;">Vector </span><span style=" color: #000;">mul_friend(</span>const <span style=" color: #2B91AE;">Matrix </span><span style=" color: #000;">&amp;m, </span>const <span style=" color: #2B91AE;">Vector </span><span style=" color: #000;">&amp;v);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Текст файла “Matrix.cpp”:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">#include <span style=" color: #A21515;">&quot;Matrix.h&quot;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">Matrix</span>::Matrix(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">rows</span>, <span style=" color: #00F;">unsigned </span><span style=" color: #808080;">cols</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;rows = <span style=" color: #808080;">rows</span>; <span style=" color: #00F;">this</span>-&gt;cols = <span style=" color: #808080;">cols</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">data = <span style=" color: #00F;">new double</span>*[<span style=" color: #808080;">rows</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>i = 0; i &lt; <span style=" color: #808080;">rows</span>; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">data[i] = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">cols</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>j = 0; j &lt; <span style=" color: #808080;">cols</span>; j++) data[i][j] = 0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">Matrix</span>::Matrix(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Matrix </span>&amp;<span style=" color: #808080;">m</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">rows = <span style=" color: #808080;">m</span>.rows; cols = <span style=" color: #808080;">m</span>.cols;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">data = <span style=" color: #00F;">new double</span>*[rows];</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i &lt; rows; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data[i] = <span style=" color: #00F;">new double</span>[cols];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>j = 0; j &lt; cols; j++) data[i][j] = <span style=" color: #808080;">m</span>.data[i][j];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}}</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Matrix<span style=" color: #000;">::~Matrix()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i &lt; rows; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">delete <span style=" color: #000;">[] data[i];</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">delete <span style=" color: #000;">[] data;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #2B91AE;">Matrix</span><span style=" color: #000;">::Elements(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">, </span>unsigned <span style=" color: #808080;">j</span><span style=" color: #000;">) </span>const</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= rows) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index i is out of bounds&quot;</span>); <span style=" color: #00F;">if </span>(<span style=" color: #808080;">j </span>&gt;= cols) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index j is out of bounds&quot;</span>); <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>][<span style=" color: #808080;">j</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">double</span>&amp; <span style=" color: #2B91AE;">Matrix</span>::Elements(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">i</span>, <span style=" color: #00F;">unsigned </span><span style=" color: #808080;">j</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: justify;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= rows) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index i is out of bounds&quot;</span>); <span style=" color: #00F;">if </span>(<span style=" color: #808080;">j </span>&gt;= cols) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index j is out of bounds&quot;</span>); <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>][<span style=" color: #808080;">j</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #2B91AE;">Matrix</span><span style=" color: #000;">::GetRows() </span>const</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">return <span style=" color: #000;">rows;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #2B91AE;">Matrix</span><span style=" color: #000;">::GetCols() </span>const</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">cols;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Текст файла “Main.cpp”:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">#include <span style=" color: #A21515;">&lt;stdio.h&gt; </span>#include <span style=" color: #A21515;">&lt;time.h&gt; </span>#include <span style=" color: #A21515;">&quot;Vector.h&quot; </span>#include <span style=" color: #A21515;">&quot;Matrix.h&quot; </span>#define <span style=" color: #6E0089;">TESTS </span><span style=" color: #000;">50000</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">Vector </span>mul(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Matrix </span>&amp;<span style=" color: #808080;">m</span>, <span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp;<span style=" color: #808080;">v</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Vector </span>res(<span style=" color: #808080;">m</span>.GetRows());</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>i = 0; i &lt; <span style=" color: #808080;">m</span>.GetRows(); i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">res.Elements(i) = 0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>j = 0; j &lt; <span style=" color: #808080;">m</span>.GetCols(); j++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">res.Elements(i) += <span style=" color: #808080;">m</span>.Elements(i, j) * <span style=" color: #808080;">v</span>.Elements(j);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">return <span style=" color: #000;">res;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">Vector </span>mul_friend(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Matrix </span>&amp;<span style=" color: #808080;">m</span>, <span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp;<span style=" color: #808080;">v</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Vector </span>res(<span style=" color: #808080;">m</span>.rows);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>i = 0; i &lt; <span style=" color: #808080;">m</span>.rows; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">res.data[i] = 0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>j = 0; j &lt; <span style=" color: #808080;">m</span>.cols; j++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">res.data[i] += <span style=" color: #808080;">m</span>.data[i][j] * <span style=" color: #808080;">v</span>.data[j];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">return <span style=" color: #000;">res;} </span>int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector <span style=" color: #000;">v(5);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i &lt; v.GetSize(); i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">v.Elements(i) = (<span style=" color: #00F;">double</span>)i/(i+1);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i &lt; v.GetSize(); i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%.2lf &quot;</span>, v.Elements(i));</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n\n&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Matrix <span style=" color: #000;">m(3, 5);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i &lt; m.GetRows(); i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">j = 0; j &lt; m.GetCols(); j++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">m.Elements(i, j) = (<span style=" color: #00F;">double</span>)(i+j)/(i+j+1);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i &lt; m.GetRows(); i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">j = 0; j &lt; m.GetCols(); j++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%.2lf &quot;</span>, m.Elements(i, j));</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n\n&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">clock_t <span style=" color: #000;">start, end, diff;</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// доступ к data через функции</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">start = clock();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>t = 0; t &lt; <span style=" color: #6E0089;">TESTS</span>; t++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector <span style=" color: #000;">r = mul(m, v);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">end = clock();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">diff = end - start;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;finished in %d msec\n&quot;</span>, diff * 1000 / <span style=" color: #6E0089;">CLOCKS_PER_SEC</span>);</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// доступ к data напрямую</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">start = clock();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>t = 0; t &lt; <span style=" color: #6E0089;">TESTS</span>; t++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector <span style=" color: #000;">r = mul_friend(m, v);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">end = clock();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">diff = end - start;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;finished in %d msec\n&quot;</span>, diff * 1000 / <span style=" color: #6E0089;">CLOCKS_PER_SEC</span>); getchar();</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">0;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}<span class="p">Как видим дружественная реализация функции умножения примерно в 2 раза эффективнее по времени, чем</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">обычная. Такой прирост в эффективности можно объяснить тем, что что в реализации дружественной функции мы работаем с массивами данных в динамической памяти напрямую, минуя вызов функций доступа к элементам данных через стек, а также, не выполняя проверок корректности индекса, которые реализованы в этих методах.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Дружественные методы</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Аналогично рассмотренным выше дружественным функциям «подружить» с классом можно не только глобальные функции, но и методы другого класса. В этом случае уже говорят о дружественных методах. Объявление</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">дружественных методов аналогично объявлению дружественных функций, за исключением необходимости указания префикса с именем класса:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">friend &lt;тип значения&gt; &lt;имя класса&gt;::&lt;имя метода&gt;(<b>[</b>&lt;список параметров&gt;<b>]</b>);</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Дружественные классы</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Если дружественных методов предполагается много, то вместо перечисления их по отдельности можно объявить один класс дружественным другому целиком. В этом случае будет открыт доступ всем членам первого класса к</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">членам второго класса. Для объявления дружественных классов используют следующий синтаксис в любом месте объявления класса:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">friend &lt;имя класса&gt;;</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">На примере двух классов «вектор» и «матрица» рассмотрим реализацию методов класса «матрица» возвращающих указанную строку или столбец, как объект класса вектор. Для обеспечения прямого доступа к массиву данных объекта класса «вектор» необходимо сделать класс «матрица» дружественными классу «вектор»:</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Текст файла “Vector.h”:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Matrix</span><span style=" color: #000;">; </span>class <span style=" color: #2B91AE;">Vector</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">*data; </span>unsigned <span style=" color: #000;">size; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector(<span style=" color: #00F;">unsigned </span>size = 0); Vector(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp;v);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~Vector();</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">Elements(</span>unsigned <span style=" color: #000;">i) </span>const<span style=" color: #000;">; </span>double<span style=" color: #000;">&amp; Elements(</span>unsigned <span style=" color: #000;">i); </span>unsigned <span style=" color: #000;">GetSize();</span></p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">friend class <span style=" color: #2B91AE;">Matrix</span><span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Текст файла “Vector.cpp”:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">#include <span style=" color: #A21515;">&quot;Vector.h&quot;</span><span style=" color: #2B91AE;">Vector</span><span style=" color: #000;">::Vector(</span>const unsigned <span style=" color: #808080;">size</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;size = <span style=" color: #808080;">size</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">size</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>i = 0; i &lt; <span style=" color: #808080;">size</span>; i++) data[i] = 0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Vector</span>::Vector(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp;<span style=" color: #808080;">v</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">size = <span style=" color: #808080;">v</span>.size;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[size];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>i = 0; i &lt; size; i++) data[i] = <span style=" color: #808080;">v</span>.data[i];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector<span style=" color: #000;">::~Vector()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">delete <span style=" color: #000;">[] data;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #2B91AE;">Vector</span><span style=" color: #000;">::Elements(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">) </span>const</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= size) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index i is out of bounds&quot;</span>); <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">double </span>&amp;<span style=" color: #2B91AE;">Vector</span>::Elements(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">i</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= size) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index i is out of bounds&quot;</span>); <span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&lt; size) <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #2B91AE;">Vector</span><span style=" color: #000;">::GetSize()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">size;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Текст файла “Matrix.h”:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Vector</span><span style=" color: #000;">; </span>class <span style=" color: #2B91AE;">Matrix</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">**data; </span>unsigned <span style=" color: #000;">rows, cols; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Matrix(<span style=" color: #00F;">unsigned </span>rows = 0, <span style=" color: #00F;">unsigned </span>cols = 0); Matrix(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Matrix </span>&amp;m);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~Matrix();</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">Elements(</span>unsigned <span style=" color: #000;">i, </span>unsigned <span style=" color: #000;">j) </span>const<span style=" color: #000;">; </span>double <span style=" color: #000;">&amp;Elements(</span>unsigned <span style=" color: #000;">i, </span>unsigned <span style=" color: #000;">j); </span>unsigned <span style=" color: #000;">GetRows() </span>const<span style=" color: #000;">;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetCols() </span>const<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Vector </span>GetRow(<span style=" color: #00F;">unsigned </span>i) <span style=" color: #00F;">const</span>; <span style=" color: #2B91AE;">Vector </span>GetCol(<span style=" color: #00F;">unsigned </span>i) <span style=" color: #00F;">const</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Текст файла “Matrix.cpp”:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">#include <span style=" color: #A21515;">&quot;Matrix.h&quot; </span>#include <span style=" color: #A21515;">&quot;Vector.h&quot;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">Matrix</span>::Matrix(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">rows</span>, <span style=" color: #00F;">unsigned </span><span style=" color: #808080;">cols</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;rows = <span style=" color: #808080;">rows</span>; <span style=" color: #00F;">this</span>-&gt;cols = <span style=" color: #808080;">cols</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">data = <span style=" color: #00F;">new double</span>*[<span style=" color: #808080;">rows</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>i = 0; i &lt; <span style=" color: #808080;">rows</span>; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">data[i] = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">cols</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>j = 0; j &lt; <span style=" color: #808080;">cols</span>; j++) data[i][j] = 0;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Matrix</span>::Matrix(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Matrix </span>&amp;<span style=" color: #808080;">m</span>)</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">rows = <span style=" color: #808080;">m</span>.rows; cols = <span style=" color: #808080;">m</span>.cols;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">data = <span style=" color: #00F;">new double</span>*[rows];</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i &lt; rows; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data[i] = <span style=" color: #00F;">new double</span>[cols];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>j = 0; j &lt; cols; j++) data[i][j] = <span style=" color: #808080;">m</span>.data[i][j];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Matrix<span style=" color: #000;">::~Matrix()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i &lt; rows; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">delete <span style=" color: #000;">[] data[i];</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">delete <span style=" color: #000;">[] data;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #2B91AE;">Matrix</span><span style=" color: #000;">::Elements(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">, </span>unsigned <span style=" color: #808080;">j</span><span style=" color: #000;">) </span>const</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= rows) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index i is out of bounds&quot;</span>); <span style=" color: #00F;">if </span>(<span style=" color: #808080;">j </span>&gt;= cols) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index j is out of bounds&quot;</span>); <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>][<span style=" color: #808080;">j</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">double</span>&amp; <span style=" color: #2B91AE;">Matrix</span>::Elements(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">i</span>, <span style=" color: #00F;">unsigned </span><span style=" color: #808080;">j</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= rows) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index i is out of bounds&quot;</span>); <span style=" color: #00F;">if </span>(<span style=" color: #808080;">j </span>&gt;= cols) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index j is out of bounds&quot;</span>); <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>][<span style=" color: #808080;">j</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #2B91AE;">Matrix</span><span style=" color: #000;">::GetRows() </span>const</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">return <span style=" color: #000;">rows;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #2B91AE;">Matrix</span><span style=" color: #000;">::GetCols() </span>const</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">cols;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Vector Matrix</span>::GetRow(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">i</span>) <span style=" color: #00F;">const</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= rows) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index i is out of bounds&quot;</span>); <span style=" color: #2B91AE;">Vector </span>res(cols);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">j = 0; j &lt; cols; j++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">res.data[j] = data[<span style=" color: #808080;">i</span>][j];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">res;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Vector Matrix</span>::GetCol(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">i</span>) <span style=" color: #00F;">const</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= cols) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;index i is out of bounds&quot;</span>); <span style=" color: #2B91AE;">Vector </span>res(rows);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">j = 0; j &lt; rows; j++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">res.data[j] = data[j][<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">res;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Текст файла “Main.cpp”:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">#include <span style=" color: #A21515;">&lt;stdio.h&gt;</span>#include <span style=" color: #A21515;">&quot;Vector.h&quot; </span>#include <span style=" color: #A21515;">&quot;Matrix.h&quot;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Matrix <span style=" color: #000;">m(3, 5);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i &lt; m.GetRows(); i++)</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">j = 0; j &lt; m.GetCols(); j++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">m.Elements(i, j) = (<span style=" color: #00F;">double</span>)(i+j)/(i+j+1);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i &lt; m.GetRows(); i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">j = 0; j &lt; m.GetCols(); j++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%.2lf &quot;</span>, m.Elements(i, j));</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n\n&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector <span style=" color: #000;">row = m.GetRow(1);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i &lt; row.GetSize(); i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%.2lf &quot;</span>, row.Elements(i));</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n\n&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector <span style=" color: #000;">col = m.GetCol(3);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i &lt; col.GetSize(); i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%.2lf &quot;</span>, col.Elements(i));</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n\n&quot;</span>); getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">За счет того, что мы сделали класс «матрица» дружественным классу «вектор», в реализации методов GetRow и</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">GetCol есть возможность прямого доступа к данным объектов класса «вектор» и нет необходимости явно перечислять дружественные методы в объявлении класса вектор. Более того, мы можем расширить класс «матрица» еще рядом методов, работающих с закрытыми данными класса «вектор» без необходимости какой-либо его модификации. Стоит отметить, что дружба классов не является взаимной, в приведенном выше примере класс «матрица» является другом класса «вектор», но не наоборот. Если мы хотим добиться взаимности, то стоит явным образом указать <b>friend class Vector </b>в объявлении класса «матрица».</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 10pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s14" style=" background-color: #0F0;">Лекция 7 Наследование</span></p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Наследование</p><h3 style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Наследование <span class="p">– концепция ООП, позволяющая одним объектам приобретать атрибуты и поведение других объектов.</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Наследование помогает сделать разработку более экономной и обозримой, так как объекты пользуются одними и теми же атрибутами, а также формами поведения без дублирования реализующих их программных кодов. При</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">наследовании класс-</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">наследник может как расширять функциональность класса-предка, так и неким образом модифицировать или</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">уточнять её. Например, класс «Цветная точка» будет расширять функциональность класса «Точка», а класс «Квадрат» будет уточнять функциональность класса «Прямоугольник»: расширение уточнение В языке C++ поддерживается</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">концепция множественного наследования, это значит, что в общем случае у одного класса может быть несколько классов предков. Однако само по себе множественное наследование сопряжено с множеством проблем, и как</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">правило применяется для</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">определения шаблона поведения класса наследника, т.е. в том случае, когда предки являются абстрактными классами (об этом мы будем разговаривать несколько позже), т.е. для замены, отсутствующей в C++ концепции</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">интерфейсов. В литературе можно встретить различные определения для <b>базового </b>класса: <b>предок</b>, <b>родительский класс </b>или <b>суперкласс</b>. <b>Производный</b></p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">класс <span class="p">называют </span>потомком<span class="p">, </span>дочерним классом <span class="p">или </span>подклассом<span class="p">. При наследовании родительские и дочерние классы образуют так называемую </span>иерархию наследования<span class="p">, при этом количество уровней в этой иерархии в общем случае не ограничено.</span></h3><p style="padding-left: 81pt;text-indent: 0pt;text-align: left;">При наследовании выполняются следующие правила:</p><ol id="l5"><li data-list-text="1."><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">Информационные поля и методы класса-предка наследуются всеми его классами- наследниками независимо от числа промежуточных уровней иерархии.</p></li><li data-list-text="2."><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Доступ к полям и методам классов-предков для любого класса-наследника выполняется так, как будто бы они описаны в самом дочернем типе, если доступ к этим членам класса не ограничен спецификаторами доступа.</p></li><li data-list-text="3."><p style="padding-left: 18pt;text-indent: -10pt;line-height: 13pt;text-align: left;">Класс-наследник может доопределить произвольное число собственных методов и полей.</p></li><li data-list-text="4."><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Если идентификаторы полей или методов в классах-наследниках совпадают с таковыми в классах-предках, то в этом случае говорят, что дочерний член класса перекрывает одноименный родительский член класса. При обращении к такому члену через объект класса-наследника будет происходить обращение именно к дочернему члену класса, а не к родительскому.</p></li></ol><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Одиночное наследование</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Синтаксис определения нового класса на основе уже существующего следующий:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">class &lt;имя класса&gt;:<b>[</b>&lt;атрибут наследования&gt;<b>]</b>&lt;имя базового класса&gt; {...}</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Указание атрибута наследования позволяет ограничить область видимости членов базового класса в классе</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">наследнике. Хотя атрибут наследования и является опциональным, в большинстве случаев его следует указывать. т.к. по умолчанию наследование производится с атрибутом private, что фактически приводит к невозможности</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">обращения ко всем полям и методам, определенным в базовом классе из внешнего кода.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Атрибут наследования</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private protected public private</h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">недоступен недоступен недоступен <b>protected </b>private protected protected <b>public </b>private protected public</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Видимость в производном классе Наиболее распространённым вариантом является указания атрибута public, при котором</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">модификаторы доступа базового класса остаются без изменений. Члены базового класса, объявленные как private недоступны для производных классов, поэтому если предполагается, что доступ к таким членам базового класса</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">будет необходим при реализации методов класса-потомка их следует объявлять сак protected. Как видно из</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">приведенной таблицы используя атрибут наследования нельзя расширить доступ к членам базового класса, но можно сузить, т.е. при</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">наследовании производный класс имеет возможность сделать все открытые члены базового класса защищенными (используя атрибут наследования protected) или скрыть все защищенные и открытые члены базового класса</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">(используя атрибут наследования public). Видимость в базовом классеРассмотрим пример реализации класса-наследника «Цветная точка» на основе базового класса «Точка»:</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//базовый класс точка</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point(<span style=" color: #00F;">int </span>x = 0, <span style=" color: #00F;">int </span>y = 0); <span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">int </span>value);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">SetY(</span>int <span style=" color: #000;">value); </span>int <span style=" color: #000;">GetX() </span>const<span style=" color: #000;">; </span>int <span style=" color: #000;">GetY() </span>const<span style=" color: #000;">; </span>void <span style=" color: #000;">Print() </span>const<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">Point</span>::Point(<span style=" color: #00F;">int </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">y</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Point constructor (%d, %d)\n&quot;</span>, <span style=" color: #808080;">x</span>, <span style=" color: #808080;">y</span>); <span style=" color: #00F;">this</span>-&gt;x = <span style=" color: #808080;">x</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;y = <span style=" color: #808080;">y</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetX(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetY(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">int </span><span style=" color: #2B91AE;">Point</span>::GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">int <span style=" color: #2B91AE;">Point</span><span style=" color: #000;">::GetY() </span>const <span style=" color: #000;">{</span>return <span style=" color: #000;">y;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::Print() <span style=" color: #00F;">const</span>{printf(<span style=" color: #A21515;">&quot;(%d, %d)\n&quot;</span>, x, y);} <span style=" color: #00F;">enum </span><span style=" color: #2B91AE;">Color</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s22" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Black <span style=" color: #000;">= 0x000000, </span>Blue <span style=" color: #000;">= 0x000080,</span></p><p class="s22" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Green <span style=" color: #000;">= 0x008000, </span>Cyan <span style=" color: #000;">= 0x008080, </span>Red <span style=" color: #000;">= 0x800000,</span></p><p class="s22" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Magenta <span style=" color: #000;">= 0x800080, </span>Brown <span style=" color: #000;">= 0x808000, </span>LightGray <span style=" color: #000;">= 0xC0C0C0, </span>DarkGray <span style=" color: #000;">= 0x808080, </span>LightBlue <span style=" color: #000;">= 0x0000FF, </span>LightGreen <span style=" color: #000;">= 0x00FF00, </span>LightCyan <span style=" color: #000;">= 0x00FFFF, </span>LightRed <span style=" color: #000;">= 0xFF0000, </span>LightMagenta <span style=" color: #000;">= 0xFF00FF, </span>Yellow <span style=" color: #000;">= 0xFFFF00,</span></p><p class="s22" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">White <span style=" color: #000;">= 0xFFFFFF</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//класс-наследник цветная точка</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">class </span>CPoint <span style=" color: #000;">: </span>Point</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Color </span>color; <span style=" color: #00F;">public</span>:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">CPoint(<span style=" color: #00F;">int </span>x = 0, <span style=" color: #00F;">int </span>y = 0, <span style=" color: #2B91AE;">Color </span>color = <span style=" color: #2E4F4F;">Black</span>); <span style=" color: #00F;">void </span>SetColor(<span style=" color: #2B91AE;">Color </span>value);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Color </span>GetColor() <span style=" color: #00F;">const</span>; <span style=" color: #00F;">void </span>Print() <span style=" color: #00F;">const</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">CPoint</span>::CPoint(<span style=" color: #00F;">int </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">y</span>, <span style=" color: #2B91AE;">Color </span><span style=" color: #808080;">color</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;CPoint constructor (%d, %d, %X)\n&quot;</span>, <span style=" color: #808080;">x</span>, <span style=" color: #808080;">y</span>, <span style=" color: #808080;">color</span>);</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//this-&gt;x = x; //невозможно обратиться к private член, объявленному в классе &quot;Point&quot;//this-&gt;y = y; //невозможно обратиться к private член, объявленному в классе &quot;Point&quot;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">SetX(<span style=" color: #808080;">x</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">SetX(<span style=" color: #808080;">y</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;color = <span style=" color: #808080;">color</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">CPoint</span>::SetColor(<span style=" color: #2B91AE;">Color </span><span style=" color: #808080;">value</span>) {color = <span style=" color: #808080;">value</span>;} <span style=" color: #2B91AE;">Color CPoint</span>::GetColor() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>color;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">CPoint</span>::Print() <span style=" color: #00F;">const</span>{printf(<span style=" color: #A21515;">&quot;(%d, %d) #%X\n&quot;</span>, GetX(), GetY(), color);} <span style=" color: #00F;">int </span>main()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point <span style=" color: #000;">p1(3, -5);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">p1.SetX(5);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">p1.SetY(-3);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">p1.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">CPoint </span>cp1(-5, 4, <span style=" color: #2E4F4F;">LightMagenta</span>);</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//cp1.SetX(-4); //нет доступа к &quot;Point::SetX&quot;, поскольку &quot;CPoint&quot; использует &quot;private&quot; для наследования из &quot;Point&quot;</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//cp1.SetY(-4); //нет доступа к &quot;Point::SetY&quot;, поскольку &quot;CPoint&quot; использует &quot;private&quot; для наследования из &quot;Point&quot;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">cp1.SetColor(<span style=" color: #2E4F4F;">LightGray</span>);</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">cp1.Print(); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Рассмотрим проблемы представленной реализации:</p><ol id="l6"><li data-list-text="1."><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">У нас нет доступа к полям данных x и y базового класса, хотя он нужен, т.к. в методе Print, например, мы вынуждены обращаться к этим полям через геттеры, следовательно, в базовом классе для этих полей стоит использовать спецификатор доступа protected вместо private.</p></li><li data-list-text="2."><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Как видно по выводу программы, при прежде чем сработает конструктор для класса «Цветная точка» вызывается конструктор для класса «Точка». В нашем случае он отработал вхолостую. т.к. в конструкторе класса-наследника фактически продублирована инициализация полей x и y.</p></li><li data-list-text="3."><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Во внешнем коде нет возможности обратиться к, казалось бы, открытым методам SetX и SetY класса предка. Очевидно нужно указать атрибут наследования public. С первым и третьим пунктом все более-менее понятно, а насчет вызова конструкторов стоит разобраться более подробно. Дело в том, что при создании объекта класса-наследника всегда</p></li></ol><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">вызывается конструктор по умолчанию класса предка, только если нет явного вызова конструктора класса предка в списке инициализации конструктора класса наследника (в теле конструктора нельзя вызвать конструктор базового класса). При этом, если базовый класс не имеет конструктора по умолчанию, то конструктор по умолчанию для</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">производного класса не может быть сгенерирован автоматически! В этом случае конструктор производного класса должен быть реализован явно, а вызов конструктора класса предка выполняется в списке инициализации его</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">конструктора. Для вызова конструктора базового класса в списке инициализации используют следующий синтаксис:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">&lt;имя конструктора&gt;([&lt;список параметров &gt;]) [,...]</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">Таким образом, в списке инициализации можно обратиться не только к конструктору по умолчанию, но и к</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">конструктору с параметрами. Рассмотрим пример, когда отсутствует конструктор по умолчанию для базового класса:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">x; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A(<span style=" color: #00F;">int </span><span style=" color: #808080;">x</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;A(%d)\n&quot;</span>, <span style=" color: #808080;">x</span>); <span style=" color: #00F;">this</span>-&gt;x = <span style=" color: #808080;">x</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {printf(<span style=" color: #A21515;">&quot;A.SetX\n&quot;</span>); x = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">int </span>GetX() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;A.GetX\n&quot;</span>); <span style=" color: #00F;">return </span>x;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Print(){printf(<span style=" color: #A21515;">&quot;A: x = %d&quot;</span>, x);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">B</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">B(<span style=" color: #00F;">int </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">y</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;B(%d)\n&quot;</span>, <span style=" color: #808080;">y</span>); <span style=" color: #00F;">this</span>-&gt;x = <span style=" color: #808080;">x</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;y = <span style=" color: #808080;">y</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>SetY(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {printf(<span style=" color: #A21515;">&quot;B.SetY\n&quot;</span>); y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">int </span>GetY() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;B.GetY\n&quot;</span>); <span style=" color: #00F;">return </span>y;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Print(){printf(<span style=" color: #A21515;">&quot;B: x = %d; y = %d;&quot;</span>, x, y);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В рассмотренном примере мы получим ошибку компиляции «A: нет подходящего конструктора по умолчанию» в объявлении конструктора класса B. И это справедливо, поскольку конструктор по умолчанию для класса А не</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">определен, а явного вызова конструктора с параметром в списке инициализации конструктора класса B нет.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Исправить положение может добавление вызова конструктора класса A в список инициализации конструктора класса</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">B:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">B(<span style=" color: #00F;">int </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">y</span>) : <span style=" color: #2B91AE;">A</span>(<span style=" color: #808080;">x</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;B(%d)\n&quot;</span>, <span style=" color: #808080;">y</span>);</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;y = <span style=" color: #808080;">y</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">При создании объекта сначала вызывается конструктор базового класса, а затем – конструктор производного. Деструкторы вызываются в обратном порядке. Продемонстрируем на простом примере:<span class="s3">class </span><span class="s10">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">x; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A(<span style=" color: #00F;">int </span><span style=" color: #808080;">x </span>= 0) :x(<span style=" color: #808080;">x</span>) {printf(<span style=" color: #A21515;">&quot;A(%d)\n&quot;</span>, <span style=" color: #808080;">x</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~A(){printf(<span style=" color: #A21515;">&quot;~A\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {printf(<span style=" color: #A21515;">&quot;A.SetX\n&quot;</span>); x = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">int </span>GetX() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;A.GetX\n&quot;</span>); <span style=" color: #00F;">return </span>x;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Print(){printf(<span style=" color: #A21515;">&quot;A: x = %d\n&quot;</span>, x);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">B</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">B(<span style=" color: #00F;">int </span><span style=" color: #808080;">x </span>= 0, <span style=" color: #00F;">int </span><span style=" color: #808080;">y </span>= 0) : <span style=" color: #2B91AE;">A</span>(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>) {printf(<span style=" color: #A21515;">&quot;B(%d, %d)\n&quot;</span>, <span style=" color: #808080;">x</span>, <span style=" color: #808080;">y</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">~B(){printf(<span style=" color: #A21515;">&quot;~B\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>SetY(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {printf(<span style=" color: #A21515;">&quot;B.SetY\n&quot;</span>); y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">int </span>GetY() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;B.GetY\n&quot;</span>); <span style=" color: #00F;">return </span>y;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Print(){printf(<span style=" color: #A21515;">&quot;B: x = %d; y = %d;\n&quot;</span>, x, y);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">C</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">B</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">z; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">C(<span style=" color: #00F;">int </span><span style=" color: #808080;">x </span>= 0, <span style=" color: #00F;">int </span><span style=" color: #808080;">y </span>= 0, <span style=" color: #00F;">int </span><span style=" color: #808080;">z </span>= 0) : <span style=" color: #2B91AE;">B</span>(<span style=" color: #808080;">x</span>, <span style=" color: #808080;">y</span>), z(<span style=" color: #808080;">z</span>) {printf(<span style=" color: #A21515;">&quot;C(%d, %d, %d)\n&quot;</span>, <span style=" color: #808080;">x</span>, <span style=" color: #808080;">y</span>, <span style=" color: #808080;">z</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~C(){printf(<span style=" color: #A21515;">&quot;~C\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>SetZ(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {printf(<span style=" color: #A21515;">&quot;C.SetY\n&quot;</span>); y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">int </span>GetZ() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;C.GetY\n&quot;</span>); <span style=" color: #00F;">return </span>y;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Print(){printf(<span style=" color: #A21515;">&quot;C: x = %d; y = %d; z = %d;\n&quot;</span>, x, y, z);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">test()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">C <span style=" color: #000;">c(1, 2, 3);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">c.SetX(5);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">c.SetY(6);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">c.SetZ(7);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">c.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">test(); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">}<span class="p">В нашем случае (вернемся к иерархии «Точка» -&gt; «Цветная точка») разумно будет вызвать конструктор класса</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">«Точка» с параметрами в списке инициализации конструктора класса «Цветная точка» и соответственно убрать дублирующий код инициализации полей x и y. Рассмотрим реализацию с учетом указанных проблем:</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//базовый класс точка</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point(<span style=" color: #00F;">int </span>x = 0, <span style=" color: #00F;">int </span>y = 0); <span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">int </span>value);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">SetY(</span>int <span style=" color: #000;">value); </span>int <span style=" color: #000;">GetX() </span>const<span style=" color: #000;">; </span>int <span style=" color: #000;">GetY() </span>const<span style=" color: #000;">; </span>void <span style=" color: #000;">Print() </span>const<span style=" color: #000;">;</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">Point</span>::Point(<span style=" color: #00F;">int </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">y</span>): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Point constructor (%d, %d)\n&quot;</span>, <span style=" color: #808080;">x</span>, <span style=" color: #808080;">y</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetX(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetY(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">int </span><span style=" color: #2B91AE;">Point</span>::GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">int <span style=" color: #2B91AE;">Point</span><span style=" color: #000;">::GetY() </span>const <span style=" color: #000;">{</span>return <span style=" color: #000;">y;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::Print() <span style=" color: #00F;">const</span>{printf(<span style=" color: #A21515;">&quot;(%d, %d)\n&quot;</span>, x, y);} <span style=" color: #00F;">enum </span><span style=" color: #2B91AE;">Color</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s22" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Black <span style=" color: #000;">= 0x000000,</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">...</p><p class="s22" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">White <span style=" color: #000;">= 0xFFFFFF</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//класс-наследник цветная точка</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">CPoint </span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Color </span>color; <span style=" color: #00F;">public</span>:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">CPoint(<span style=" color: #00F;">int </span>x = 0, <span style=" color: #00F;">int </span>y = 0, <span style=" color: #2B91AE;">Color </span>color = <span style=" color: #2E4F4F;">Black</span>); <span style=" color: #00F;">void </span>SetColor(<span style=" color: #2B91AE;">Color </span>value);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Color </span>GetColor() <span style=" color: #00F;">const</span>; <span style=" color: #00F;">void </span>Print() <span style=" color: #00F;">const</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">CPoint</span>::CPoint(<span style=" color: #00F;">int </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">y</span>, <span style=" color: #2B91AE;">Color </span><span style=" color: #808080;">color</span>) : <span style=" color: #2B91AE;">Point</span>(<span style=" color: #808080;">x</span>, <span style=" color: #808080;">y</span>), color(<span style=" color: #808080;">color</span>){ printf(<span style=" color: #A21515;">&quot;CPoint constructor (%d, %d, %X)\n&quot;</span>, <span style=" color: #808080;">x</span>, <span style=" color: #808080;">y</span>, <span style=" color: #808080;">color</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">CPoint</span>::SetColor(<span style=" color: #2B91AE;">Color </span><span style=" color: #808080;">value</span>) {color = <span style=" color: #808080;">value</span>;} <span style=" color: #2B91AE;">Color CPoint</span>::GetColor() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>color;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">CPoint</span>::Print() <span style=" color: #00F;">const</span>{printf(<span style=" color: #A21515;">&quot;(%d, %d) #%X\n&quot;</span>, x, y, color);} <span style=" color: #00F;">int </span>main()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point <span style=" color: #000;">p1(3, -5);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">p1.SetX(5);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">p1.SetY(-3);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">p1.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">CPoint </span>cp1(-5, 4, <span style=" color: #2E4F4F;">LightMagenta</span>); cp1.SetX(-4);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">cp1.SetY(5); cp1.SetColor(<span style=" color: #2E4F4F;">LightGray</span>); cp1.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В данной реализации у нас решены озвученные выше проблемы, поля x и y теперь защищенные, а не закрытые следовательно к ним есть доступ в реализации класса наследника, использовали атрибут наследования public,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">следовательно не изменили область видимости членов базового класса и явным образом вызвали конструктор класса предка, чем исключили дублирование кода инициализации его полей. А что, если мы захотим в методе Print класса</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">«Цветная точка» вызвать метод Print класса точка? ведь там тоже в некотором смысле дублирование функционала. Можно это сделать следующим образом:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #2B91AE;">CPoint</span><span style=" color: #000;">::Print() </span>const</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Point</span>::Print(); printf(<span style=" color: #A21515;">&quot;#%X\n&quot;</span>, color);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}<span class="p">Как видно, для конкретизации того какого именно класса метода print мы хотим вызвать применили синтаксис вида:</span></p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">&lt;имя класса&gt;::&lt;имя члена класса&gt; <span class="p">Такой синтаксис применим как для обращения к полям данных, так и для обращения к методам. Правда вывод информации об объекте класса «Цветная точка» в этом случае будет в две</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">строки,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">но здесь нас важна сама принципиальная возможность такого обращения к одноименным членам класса:</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Теперь подробнее рассмотрим особенности работы с одноименными членами классов на примере двух тестовых классов A и B:</p><p class="s7" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//базовый класс A</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">x; </span>public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">y;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A(): x(0), y(0) {printf(<span style=" color: #A21515;">&quot;A.Create\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {printf(<span style=" color: #A21515;">&quot;A.SetX\n&quot;</span>); x = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">int </span>GetX() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;A.GetX\n&quot;</span>); <span style=" color: #00F;">return </span>x;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Print(){printf(<span style=" color: #A21515;">&quot;A.Print: x = %d; y = %d;\n&quot;</span>, x, y);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//класс-наследник B</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">B</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">x; </span>public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">y;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">B(): x(0), y(0) {printf(<span style=" color: #A21515;">&quot;B.Create\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {printf(<span style=" color: #A21515;">&quot;B.SetX\n&quot;</span>); x = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">int </span>GetX() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;B.GetX\n&quot;</span>); <span style=" color: #00F;">return </span>x;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>Print(){printf(<span style=" color: #A21515;">&quot;B.Print: A.x = %d; A.y = %d; B.x =%d; B.y = %d\n&quot;</span>, <span style=" color: #2B91AE;">A</span>::x, <span style=" color: #2B91AE;">A</span>::y, x, y);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">B <span style=" color: #000;">b; b.Print();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">b.SetX(1);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">b.y = 2; b.Print(); b.<span style=" color: #2B91AE;">A</span>::SetX(3); b.<span style=" color: #2B91AE;">A</span>::y = 4;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">b.Print(); b.<span style=" color: #2B91AE;">A</span>::Print(); getchar();</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s4">}</span>В приведенном примере, при обращении к полю y или методу SetX, как мы видим происходило обращение к членам класса-потомка, т.к. члены класса-потомка <b>перекрывают </b>одноименные члены класса-предка. Для обращения к</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">членам класса-предка через объект класса-потомка требуется явно указывать имя класса, как например в строке</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">b.A::SetX(3).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 10pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s14" style=" background-color: #0F0;">Лекция 8 Виртуальные методы и абстрактные классы</span></p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Совместимость типов при наследовании</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Наследование предъявляет свои требования к правилам совместимости типов - производный тип наследует совместимость со всеми базовыми типами. Эта расширенная совместимость применима:</p><ul id="l7"><li data-list-text=""><p style="padding-left: 14pt;text-indent: -7pt;line-height: 13pt;text-align: left;">между объектами,</p></li><li data-list-text=""><p style="padding-left: 14pt;text-indent: -7pt;text-align: left;">между указателями на объекты,</p></li><li data-list-text=""><p style="padding-left: 14pt;text-indent: -7pt;text-align: left;">между формальными и фактическими параметрами функций.</p></li></ul><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Во всех случаях необходимо запомнить, что совместимость типов распространяется <b>от потомка к предку</b>. Другими словами, производные классы можно свободно использовать вместо базовых, но не наоборот. За этим правилом стоит весьма простая логика: Производный класс в обязательном порядке содержит все члены базового класса,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">поэтому размер объекта производного класса равен или (в большинстве случаев) больше, чем размер объекта базового класса. Соответственно при</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">интерпретации объекта класса-потомка, как объекта класса-предка все члены базового класса точно будут</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">определены. И наоборот, при интерпретации объекта класса-предка как объекта класса-потомка возможна ситуация, когда некоторые поля производного класса (которых нет в базовом) останутся неопределенными. При присваивании объекта производного класса объекту базового класса будут копироваться только те поля, которые являются общими</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">для обоих типов, то есть только поля базового класса - происходит «срезка» объекта. Рассмотрим на примере иерархии классов «Двумерная точка» → Трехмерная точка»:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">#include <span style=" color: #A21515;">&lt;stdio.h&gt; </span>#include <span style=" color: #A21515;">&lt;string.h&gt; </span>class <span style=" color: #2B91AE;">Point2D</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point2D(<span style=" color: #00F;">int </span><span style=" color: #808080;">x </span>= 0, <span style=" color: #00F;">int </span><span style=" color: #808080;">y </span>= 0): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>) {} <span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>SetY(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">int </span>GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">GetY() </span>const const <span style=" color: #000;">{</span>return <span style=" color: #000;">y;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>Print() <span style=" color: #00F;">const const</span>{printf(<span style=" color: #A21515;">&quot;(%d, %d)\n&quot;</span>, x, y);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Point3D </span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Point2D</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">z; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point3D(<span style=" color: #00F;">int </span><span style=" color: #808080;">x </span>= 0, <span style=" color: #00F;">int </span><span style=" color: #808080;">y </span>= 0, <span style=" color: #00F;">int </span><span style=" color: #808080;">z </span>= 0): <span style=" color: #2B91AE;">Point2D</span>(<span style=" color: #808080;">x</span>, <span style=" color: #808080;">y</span>), z(<span style=" color: #808080;">z</span>) {} <span style=" color: #00F;">void </span>SetZ(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {z = <span style=" color: #808080;">value</span>;}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">GetZ() </span>const <span style=" color: #000;">{</span>return <span style=" color: #000;">z;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>Print() <span style=" color: #00F;">const const</span>{printf(<span style=" color: #A21515;">&quot;(%d, %d, %d)\n&quot;</span>, x, y, z);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Print2D(<span style=" color: #2B91AE;">Point2D </span><span style=" color: #808080;">p</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s6" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">p<span style=" color: #000;">.Print();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}<span style=" color: #00F;">void </span>Print3D(<span style=" color: #2B91AE;">Point3D </span><span style=" color: #808080;">p</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s6" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">p<span style=" color: #000;">.Print();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point2D <span style=" color: #000;">p2 = </span>Point2D<span style=" color: #000;">(-1, 3); </span>Point3D <span style=" color: #000;">p3 = </span>Point3D<span style=" color: #000;">(4, -2, 5); </span>Point2D <span style=" color: #000;">_p2;</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point3D <span style=" color: #000;">_p3;</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// для объектов:</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//объекту-предку можно присвоить объект-потомок</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">_p2 = p3;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">_p2.SetX(1);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">_p2.SetY(-1);</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//_p2.SetZ(6); //SetZ: не является членом &quot;Point2D&quot;</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//объекту-потомку нельзя присвоить объект-предок</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//_p3 = p2; //не найден оператор, принимающий правый операнд типа &quot;Point2D&quot; (или приемлемое преобразование отсутствует)</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point2D <span style=" color: #000;">*pp2; </span>Point3D <span style=" color: #000;">*pp3;</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//для указателей:</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//указателю на объект-предок можно присвоить указатель на объект-потомок</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">pp2 = &amp;p3; pp2-&gt;SetX(1);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">pp2-&gt;SetY(-1);</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//pp2-&gt;SetZ(6); //SetZ: не является членом &quot;Point2D&quot;</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//указателю на объект-потомок нельзя присвоить указатель на объект-предок</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//pp3 = &amp;p2_1; //невозможно преобразовать &quot;Point2D *&quot; в &quot;Point3D *&quot;</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//для параметров функций:</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//вместо формального параметра объект-предок можно использовать объект-потомок</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Print2D(p3);</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//вместо формального параметра объект-потомок нельзя использовать объект-предок</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//Print3D(p2); //невозможно преобразовать параметр 1 из &quot;Point2D&quot; в &quot;Point3D&quot;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s2" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Виртуальные методы</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Начнем с рассмотрения несложного примера:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>f(){printf(<span style=" color: #A21515;">&quot;A::f()\n&quot;</span>);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">B</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>f(){printf(<span style=" color: #A21515;">&quot;B::f()\n&quot;</span>);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">A <span style=" color: #000;">a;</span>B <span style=" color: #000;">b;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">a.f(); <span style=" color: #008000;">//A::f()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">b.f(); <span style=" color: #008000;">//B::f()</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A <span style=" color: #000;">*pa = &amp;a;</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">B <span style=" color: #000;">*pb = &amp;b;</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A <span style=" color: #000;">*pbase = pb;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">pa-&gt;f(); <span style=" color: #008000;">//A::f()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">pb-&gt;f(); <span style=" color: #008000;">//B::f()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">pbase-&gt;f(); <span style=" color: #008000;">//A::f() </span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Давайте проанализируем вывод нашей программы. Так объекты a и b объявлены как экземпляры классов A и B соответственно, то ожидаемо, что при обращениях a.f() и b.f() будут вызваны методы f соответствующих классов.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Далее указатели pa и pb объявлены как указатели на экземпляры классов A и B соответственно, и опять таки</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">ожидаемо, что при обращениях pa-&gt;f() и pb-&gt;f() будут вызваны методы f соответствующих классов. С последним случаем все не так просто, указатель pbase объявлен как указатель на объект базового класса A но</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">проинициализирован указателем на экземпляр производного класса B. Какой же метод должен сработать при вызове</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">pbase-&gt;f()? Правильным ответом будет A::f(). таким образом можно заключить, что при вызове обычного метода выбор вызываемого метода зависит не от <b>фактического </b>типа объекта, на который установлен указатель, а от <b>формального</b>, т.е. от типа самого указателя. Именно поэтому независимо от того, что указатель указывает на объект класса-потомка была вызвана функция класса предка. Такое поведение не всегда удобно. Рассмотрим пример.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Допустим есть иерархия классов, представляющих геометрические фигуры на плоскости. В базовом классе «Фигура» мы могли бы определить такие методы управления фигурами как сдвиг, поворот или, например, отображение. В классах наследниках («Линия», «Прямоугольник», «Окружность») мы могли бы переопределить эти функции, так,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">чтобы они изменяли состояние соответствующих объектов корректным образом или отображали их на экране. Тогда имея группу объектов различных типов в виде массива указателей на базовый класс «Фигура», мы можем за один</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">проход по массиву выполнить сдвиг, перенос или отображение всей группы объектов. Однако, чтобы такой подход</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">сработал с учетом ранее рассмотренного поведения нам пришлось бы приводить каждый указатель на базовый класс</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">«Фигура» к указателю</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">на объект производного типа, чтобы вызвать методы соответствующего класса. А для этого нам придется еще и каким-то образом хранить фактический тип объекта, в общем хорошее, на первый взгляд решение, оказывается не таким уж и красивым. Однако существует элегантное решение этой проблемы, основанное на использовании виртуальных методов.</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Виртуальные методы <span class="p">объявляются с использованием спецификатора virtual, при этом если в базовом классе метод объявлен как виртуальный, то в производном классе функция автоматически становится виртуальной.</span></h3><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">virtual &lt;тип возвращаемого значения&gt; &lt;имя метода&gt;(<b>[</b>&lt;список параметров&gt;<b>]</b>)</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">{...};</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Виртуальные методы объявляются в базовых классах и, как правило переопределяются в классах- потомках.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Механизм виртуальных функций является средством реализации концепции полиморфизма и позволяет однообразно работать с объектами различных типов. Для иллюстрации разницы между виртуальными и невиртуальными методами расширим</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">предыдущий пример виртуальной функцией vf:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>f(){printf(<span style=" color: #A21515;">&quot;A::f()\n&quot;</span>);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">virtual void </span>vf(){printf(<span style=" color: #A21515;">&quot;A::vf()\n&quot;</span>);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">B</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>f(){printf(<span style=" color: #A21515;">&quot;B::f()\n&quot;</span>);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>vf(){printf(<span style=" color: #A21515;">&quot;B::vf()\n&quot;</span>);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A <span style=" color: #000;">a;</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">B <span style=" color: #000;">b;</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A <span style=" color: #000;">*pa = &amp;a;</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">B <span style=" color: #000;">*pb = &amp;b;</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">A <span style=" color: #000;">*pbase = pb;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">pa-&gt;f(); <span style=" color: #008000;">//A::f()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">pb-&gt;f(); <span style=" color: #008000;">//B::f()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">pbase-&gt;f(); <span style=" color: #008000;">//A::f()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">pa-&gt;vf(); <span style=" color: #008000;">//A::vf()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">pb-&gt;vf(); <span style=" color: #008000;">//B::vf()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">pbase-&gt;vf(); <span style=" color: #008000;">//B::vf() </span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Такое поведение обусловлено тем, что при обращении к виртуальному методу выбор вызываемого метода зависит не от типа указателя, а от фактического типа объекта, на который этот указатель установлен. Поэтому в последнем случае вызывается метод класса-потомка, несмотря на то, что указатель имеет формальный тип указателя на объект класса</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">предка. Такая разница в поведении обусловлена <b>типом связывания</b>. при обращении к статическим или</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">невиртуальным методам используется <b>раннее (статическое) связывание </b>– адрес вызываемой функции определяется на этапе компиляции программы. Для виртуальных функций используется <b>позднее (динамическое) связывание </b>–адрес вызываемой функции определяется</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">непосредственно при обращении к такой функции во время выполнения программы. В этом случае при определении адреса учитывается фактический тип объекта, для которого вызывается виртуальная функция. При необходимости</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">обратиться к реализации виртуальной функции в каком-то конкретном классе, можно указать этот класс явно:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">B <span style=" color: #000;">b;</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">B <span style=" color: #000;">*pb = &amp;b;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">pb-&gt;vf(); <span style=" color: #008000;">//B::vf()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">pb-&gt;<span style=" color: #2B91AE;">B</span>::vf(); <span style=" color: #008000;">//B::vf()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">pb-&gt;<span style=" color: #2B91AE;">A</span>::vf(); <span style=" color: #008000;">//A::vf() </span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">}<span class="p">Рассмотрим применение виртуальных функций на примере базового класса «Фигура» и классов- наследников</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">«Точка», «Линия», «Окружность». Функции печати данных о фигуре и сдвига реализуем как виртуальные:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Shape</span><span style=" color: #000;">{ </span>public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">virtual void <span style=" color: #000;">Shift(</span>int <span style=" color: #808080;">dx</span><span style=" color: #000;">, </span>int <span style=" color: #808080;">dy</span><span style=" color: #000;">) {} </span>virtual void <span style=" color: #000;">Print() {}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Shape</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">x, y;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point(<span style=" color: #00F;">int </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">y</span>): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>) {} <span style=" color: #00F;">virtual void </span>Shift(<span style=" color: #00F;">int </span><span style=" color: #808080;">dx</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">dy</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">x += <span style=" color: #808080;">dx</span>; y += <span style=" color: #808080;">dy</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">virtual void </span>Print() {printf(<span style=" color: #A21515;">&quot;Point: (%d, %d);\n&quot;</span>, x, y);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Line</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Shape</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Point <span style=" color: #000;">p1, p2;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Line(<span style=" color: #00F;">int </span><span style=" color: #808080;">x1</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">y1</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">x2</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">y2</span>): p1(<span style=" color: #808080;">x1</span>, <span style=" color: #808080;">y1</span>), p2(<span style=" color: #808080;">x2</span>, <span style=" color: #808080;">y2</span>) {} <span style=" color: #00F;">virtual void </span>Shift(<span style=" color: #00F;">int </span><span style=" color: #808080;">dx</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">dy</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">p1.Shift(<span style=" color: #808080;">dx</span>, <span style=" color: #808080;">dy</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">p2.Shift(<span style=" color: #808080;">dx</span>, <span style=" color: #808080;">dy</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">virtual void </span>Print() {printf(<span style=" color: #A21515;">&quot;Line: p1 (%d, %d), p2 (%d, %d);\n&quot;</span>, p1.x, p1.y, p2.x, p2.y);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Circle</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Shape</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Point </span>c; <span style=" color: #00F;">int </span>r;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Circle(<span style=" color: #00F;">int </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">y</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">r</span>): c(<span style=" color: #808080;">x</span>, <span style=" color: #808080;">y</span>), r(<span style=" color: #808080;">r</span>) {} <span style=" color: #00F;">virtual void </span>Shift(<span style=" color: #00F;">int </span><span style=" color: #808080;">dx</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">dy</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">c.Shift(<span style=" color: #808080;">dx</span>, <span style=" color: #808080;">dy</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">virtual void </span>Print() {printf(<span style=" color: #A21515;">&quot;Circle: center (%d, %d), radius %d;\n&quot;</span>, c.x, c.y, r);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Shift (<span style=" color: #2B91AE;">Shape </span>**<span style=" color: #808080;">shapes</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">count</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">dx</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">dy</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">count</span>; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s6" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">shapes<span style=" color: #000;">[i]-&gt;Shift(</span>dx<span style=" color: #000;">, </span>dy<span style=" color: #000;">);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Print (<span style=" color: #2B91AE;">Shape </span>**<span style=" color: #808080;">shapes</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">count</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">count</span>; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s6" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">shapes<span style=" color: #000;">[i]-&gt;Print();}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Shape <span style=" color: #000;">**shapes = </span><span style=" color: #00F;">new </span>Shape<span style=" color: #000;">*[5]; shapes[0] = </span><span style=" color: #00F;">new </span>Point<span style=" color: #000;">(3, 3); shapes[1] = </span><span style=" color: #00F;">new </span>Point<span style=" color: #000;">(1, 1); shapes[2] = </span><span style=" color: #00F;">new </span>Line<span style=" color: #000;">(0, 0, 5, 2);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">shapes[3] = <span style=" color: #00F;">new </span><span style=" color: #2B91AE;">Circle</span>(5, 2, 7);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">shapes[4] = <span style=" color: #00F;">new </span><span style=" color: #2B91AE;">Circle</span>(3, 1, 5); printf(<span style=" color: #A21515;">&quot;before:\n&quot;</span>); Print(shapes, 5);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Shift(shapes, 5, -3, 4);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;after:\n&quot;</span>); Print(shapes, 5);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt; 5; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">delete <span style=" color: #000;">shapes[i];</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">delete <span style=" color: #000;">[] shapes; getchar();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">В реализации функций Print и Shift продемонстрирована возможность однотипной работы с экземплярами различных родственных классов, через указатель на экземпляр базового класса. В этом случае на уровне базового класса</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">декларировано определенное поведение объектов, а за счет использования виртуальных методов мы можем быть уверенны, что для каждого конкретного объекта в массиве будет вызван метод соответствующий его фактическому типу (классу).</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Виртуальные деструкторы</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">Еще один важный аспект при работе с виртуальными функциями проявляется при работе с деструкторами, рассмотрим вариацию нашего примера, добавим деструкторы:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{<span style=" color: #00F;">public</span>:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>f(){printf(<span style=" color: #A21515;">&quot;A::f()\n&quot;</span>);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">virtual void </span>vf(){printf(<span style=" color: #A21515;">&quot;A::vf()\n&quot;</span>);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~A(){printf(<span style=" color: #A21515;">&quot;A::~A()\n&quot;</span>);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">B</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>f(){printf(<span style=" color: #A21515;">&quot;B::f()\n&quot;</span>);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>vf(){printf(<span style=" color: #A21515;">&quot;B::vf()\n&quot;</span>);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">~B(){printf(<span style=" color: #A21515;">&quot;B::~B()\n&quot;</span>);};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">B <span style=" color: #000;">*pb = </span><span style=" color: #00F;">new </span>B<span style=" color: #000;">();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">A </span>*pbase = <span style=" color: #00F;">new </span><span style=" color: #2B91AE;">B</span>(); printf(<span style=" color: #A21515;">&quot;delete pb:\n&quot;</span>); <span style=" color: #00F;">delete </span>pb;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;delete pbase:\n&quot;</span>); <span style=" color: #00F;">delete </span>pbase;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">По выводу можно понять следующее: при удалении объекта через указатель на объект класса- наследника корректно отработали оба деструктора, сначала деструктор производного класса, а затем уже базового. При удалении же</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">объекта через указатель на объект базового класса отработал только деструктор базового класса. другими словами деструкторы ведут себя как обычные невиртуальные методы классов. При этом, если в деструкторе производного класса выполняются какие-то значимые действия, то использование невиртуальных деструкторов может привести к определенным проблемам, например, к утечке памяти. Рассмотрим эту проблему на примере класса «Именованная точка», который реализован на основе класса «Фигура»:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Shape</span><span style=" color: #000;">{ </span>public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">virtual void <span style=" color: #000;">Shift(</span>int <span style=" color: #808080;">dx</span><span style=" color: #000;">, </span>int <span style=" color: #808080;">dy</span><span style=" color: #000;">) {} </span>virtual void <span style=" color: #000;">Print() {}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">NamedPoint</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Shape</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">x, y; </span>char <span style=" color: #000;">*name; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">NamedPoint(<span style=" color: #00F;">int </span><span style=" color: #808080;">x </span>= 0, <span style=" color: #00F;">int </span><span style=" color: #808080;">y </span>= 0, <span style=" color: #00F;">const char</span>* <span style=" color: #808080;">name </span>= <span style=" color: #A21515;">&quot;&quot;</span>): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;name = <span style=" color: #00F;">new char</span>[strlen(<span style=" color: #808080;">name</span>)+1]; strcpy(<span style=" color: #00F;">this</span>-&gt;name, <span style=" color: #808080;">name</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}~NamedPoint()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;free mem %s;\n&quot;</span>, name); <span style=" color: #00F;">delete </span>[] name;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">virtual void <span style=" color: #000;">Shift(</span>int <span style=" color: #808080;">dx</span><span style=" color: #000;">, </span>int <span style=" color: #808080;">dy</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">x += <span style=" color: #808080;">dx</span>; y += <span style=" color: #808080;">dy</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">virtual void </span>Print() {printf(<span style=" color: #A21515;">&quot;coordinates: (%d, %d), name: %s;\n&quot;</span>, x, y, name);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">NamedPoint </span>*pp1 = <span style=" color: #00F;">new </span><span style=" color: #2B91AE;">NamedPoint </span>(0, 4, <span style=" color: #A21515;">&quot;first&quot;</span>); <span style=" color: #2B91AE;">NamedPoint </span>*pp2 = <span style=" color: #00F;">new </span><span style=" color: #2B91AE;">NamedPoint </span>(3, -2, <span style=" color: #A21515;">&quot;second&quot;</span>); <span style=" color: #2B91AE;">Shape </span>*pp3 = <span style=" color: #00F;">new </span><span style=" color: #2B91AE;">NamedPoint </span>(-1, 2, <span style=" color: #A21515;">&quot;third&quot;</span>);</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">pp1-&gt;Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">pp2-&gt;Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">pp3-&gt;Print(); <span style=" color: #00F;">delete </span>pp1; <span style=" color: #00F;">delete </span>pp2; <span style=" color: #00F;">delete </span>pp3; getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Как видим, при работе через указатель на базовый класс деструктор производного класса «Именованная точка» не вызывается, и память, выделенная под хранение строк освобождена не будет. Соответственно приведенная ниже функция удаления группы объектов должным образом работать не будет, и приведет к утечке памяти:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>DeleteObjects (<span style=" color: #2B91AE;">Shape </span>**<span style=" color: #808080;">shapes</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">count</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">count</span>; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">delete </span><span style=" color: #808080;">shapes</span>[i]; <span style=" color: #808080;">shapes</span>[i] = <span style=" color: #6E0089;">NULL</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Что бы избежать подобных проблем нужно лишь объявить деструктор в базовом классе виртуальным:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Shape</span><span style=" color: #000;">{</span>public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">virtual <span style=" color: #000;">~Shape() {}</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">virtual void <span style=" color: #000;">Shift(</span>int <span style=" color: #808080;">dx</span><span style=" color: #000;">, </span>int <span style=" color: #808080;">dy</span><span style=" color: #000;">) {} </span>virtual void <span style=" color: #000;">Print() {}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Shape <span style=" color: #000;">**shapes = </span><span style=" color: #00F;">new </span>Shape<span style=" color: #000;">*[3];</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">shapes[0] = <span style=" color: #00F;">new </span><span style=" color: #2B91AE;">NamedPoint </span>(0, 4, <span style=" color: #A21515;">&quot;first&quot;</span>); shapes[1] = <span style=" color: #00F;">new </span><span style=" color: #2B91AE;">NamedPoint </span>(3, -2, <span style=" color: #A21515;">&quot;second&quot;</span>); shapes[2] = <span style=" color: #00F;">new </span><span style=" color: #2B91AE;">NamedPoint </span>(-1, 2, <span style=" color: #A21515;">&quot;third&quot;</span>); Print(shapes, 3);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">DeleteObjects(shapes, 3); <span style=" color: #00F;">delete </span>[] shapes; getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В этом случае указанная выше функция удаления группы объектов отработает корректно:</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Чисто виртуальные функции и абстрактные классы</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Часто в базовом классе определяют лишь интерфейс объекта, но не подразумевают его реализацию. При этом</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">предполагается, что такие методы будут переопределены в классах потомках. В C++ в таком случае используют <b>чисто виртуальные методы</b>. Синтаксически они определяются указанием «=0» после списка параметров:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">virtual &lt;тип возвращаемого значения&gt; &lt;имя метода&gt;(<b>[</b>&lt;список параметров&gt;<b>]</b>) = 0;</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Например базовый класс геометрических фигур можно было описать как:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Shape</span><span style=" color: #000;">{ </span>public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">virtual <span style=" color: #000;">~Shape() {};</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">virtual void <span style=" color: #000;">Shift(</span>int <span style=" color: #000;">dx, </span>int <span style=" color: #000;">dy) = 0; </span>virtual void <span style=" color: #000;">Rotate(</span>double <span style=" color: #000;">angle) = 0; </span>virtual void <span style=" color: #000;">Print() = 0;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Чисто виртуальные функции обязательно должны быть переопределены в производных классах и зачастую вообще не имеют реализации. Однако при необходимости чисто виртуальный метод может иметь реализацию. Если класс</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">содержит хотя бы одну чисто виртуальную функцию такой класс называют <b>абстрактным. </b>Экземпляр такого класса не может быть создан, независимо от того выполнена ли реализация чисто виртуальной функции или нет. Это означает, что объекты абстрактных классов не могут передаваться в функции и возвращаться из функций по значению. В</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">иерархии наследования производные классы будут являться абстрактными до тех пор, пока все чисто виртуальные функции не будут переопределены.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Рассмотрим пример иерархии классов А, В, С:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">virtual void </span>vf1() = 0 {printf(<span style=" color: #A21515;">&quot;A::vf1()\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">virtual void </span>vf2() = 0 {printf(<span style=" color: #A21515;">&quot;A::vf2()\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">B</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">vf1()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;B::&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">A<span style=" color: #000;">::vf1();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">C</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">B</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">vf2()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;C::&quot;</span>);</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A<span style=" color: #000;">::vf2();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Класс A является абстрактным, т.к. в нем определены два чисто виртуальных метода. при этом в классе A оба этих метода имеют реализацию. такой подход имеет смысл, когда базовый класс предоставляет частичную реализацию некоторого функционала, которая впоследствии будет уточнена в производных классах (в крайнем случае в виде</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">перевызова метода абстрактного класса предка). Другие причины для реализации чисто виртуальных методов в абстрактном классе</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">придумать сложно, т.к. экземпляр такого класса создать нельзя и соответственно методы напрямую вызвать не</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">получится. Класс B также является абстрактным, поскольку он переопределяет только чисто виртуальный метод vf1, но не vf2. Класс C уже не является абстратным, т.к. в нем переопределены все чисто виртуальные методы класса A.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Метод vf2</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">переопределен непосредственно в классе C, а переопределенный метод vf2 он унаследовал от класса B (хотя</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">переопределение метода vf1 также могло иметь место и в классе C непосредственно). Теперь рассмотрим основную программу:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//A *pbase1 = new A(); // A: невозможно создать экземпляр абстрактного класса</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//A *pbase2 = new B(); // B: невозможно создать экземпляр абстрактного класса</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">A <span style=" color: #000;">*pbase3 = </span><span style=" color: #00F;">new </span>C<span style=" color: #000;">();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">pbase3-&gt;vf1(); <span style=" color: #008000;">//B::A::vf1()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">pbase3-&gt;vf2(); <span style=" color: #008000;">//C::A::vf2()</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//delete pbase1;</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//delete pbase2; <span style=" color: #00F;">delete </span><span style=" color: #000;">pbase3; getchar();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}<span class="p">Поскольку классы A и B абстрактные, то попытка создать экземпляры этих классов приводят к ошибке, поэтому две первые строчки закомментированы. Создать экземпляр класса C возможно, т.к. он не является абстрактным. Работа с экземпляром класса C через указатель на базовый класс даёт ожидаемый результат: вызываемый метод vf1</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">соответствует переопределенному методу из класса B, а метод vf2 соответствует переопределенному методу из класса C. При разработке программ часто применяют классы, содержащие только чисто виртуальные функции, такие классы называют <b>интерфейсными</b>. Эти классы используют для определения протокола взаимодействия между</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">объектами, что позволяет устранить зависимости от конкретных реализаций тех или иных классов и упрощает как разработку, так и последующее</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">сопровождение программы.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s14" style=" background-color: #0F0;">Лекция 9 Множественное и виртуальное наследование.</span></p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Множественное наследование</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В языке C++ возможно наследование более чем от одного класса предка - <b>множественное наследование</b>. Такой тип наследования применяется чтобы наделить производный класс свойствами и поведением нескольких базовых</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">классов. В ряде задач множественное наследование является более естественным, чем одиночное. Однако стоит помнить, что</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">проектирование классов при множественном наследовании, обладает значительно большей сложностью. Синтаксис определения нового класса на основе нескольких базовых классов следующий:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">class &lt;имя класса&gt;:<b>[</b>&lt;атрибут наследования&gt;<b>]</b>&lt;имя базового класса&gt;</p><p class="s13" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">[<span class="s9">,</span>[<span class="s9">&lt;атрибут наследования&gt;</span>]<span class="s9">&lt;имя базового класса&gt; ...</span>] <span class="s9">{...}</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">При множественном наследовании атрибуты наследования указываются отдельно для каждого базового класса и имеют тот же смысл, что и при одиночном наследовании. В случае необходимости вызова конструкторов базовых классов, такие вызовы следует производить в списке инициализации конструктора производного класса. При этом порядок вызова</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">конструкторов базовых классов определяется порядком следования базовых классов при наследовании, а не порядком указания их в списке инициализации. Рассмотрим на примере:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Person</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">char <span style=" color: #000;">name[50]; </span>unsigned <span style=" color: #000;">birth_year; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Person(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">name</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">birth_year</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">strncpy(<span style=" color: #00F;">this</span>-&gt;name, <span style=" color: #808080;">name</span>, 50); <span style=" color: #00F;">this</span>-&gt;birth_year = <span style=" color: #808080;">birth_year</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">const char<span style=" color: #000;">* GetName (){</span>return <span style=" color: #000;">name;}</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">const unsigned <span style=" color: #000;">GetBirthYear(){</span>return <span style=" color: #000;">birth_year;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Employee</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">salary; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Employee(<span style=" color: #00F;">double </span><span style=" color: #808080;">salary</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;salary = <span style=" color: #808080;">salary</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">const double <span style=" color: #000;">GetSalary(){</span>return <span style=" color: #000;">salary;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Worker</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Person</span><span style=" color: #000;">, </span>public <span style=" color: #2B91AE;">Employee</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">char <span style=" color: #000;">job[50];</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">char <span style=" color: #000;">department[50]; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Worker(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">name</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">birth_year</span>, <span style=" color: #00F;">double </span><span style=" color: #808080;">salary</span>, <span style=" color: #00F;">const char </span>*<span style=" color: #808080;">job</span>, <span style=" color: #00F;">const char </span>*<span style=" color: #808080;">department</span>): <span style=" color: #2B91AE;">Person</span>(<span style=" color: #808080;">name</span>, <span style=" color: #808080;">birth_year</span>), <span style=" color: #2B91AE;">Employee</span>(<span style=" color: #808080;">salary</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">strncpy(<span style=" color: #00F;">this</span>-&gt;job, <span style=" color: #808080;">job</span>, 50);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">strncpy(<span style=" color: #00F;">this</span>-&gt;department, <span style=" color: #808080;">department</span>, 50);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">const char<span style=" color: #000;">* GetJob (){</span>return <span style=" color: #000;">job;}</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">const char<span style=" color: #000;">* GetDepartment(){</span>return <span style=" color: #000;">department;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>PrintInfo(<span style=" color: #2B91AE;">Worker </span><span style=" color: #808080;">worker</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Worker information:\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Name: %s; Birth Year: %u;\n&quot;</span>, <span style=" color: #808080;">worker</span>.GetName(), <span style=" color: #808080;">worker</span>.GetBirthYear()); printf(<span style=" color: #A21515;">&quot;Department: %s; Job: %s;\n&quot;</span>, <span style=" color: #808080;">worker</span>.GetDepartment(), <span style=" color: #808080;">worker</span>.GetJob()); printf(<span style=" color: #A21515;">&quot;Salary: %.2lf;\n\n&quot;</span>, <span style=" color: #808080;">worker</span>.GetSalary());</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Worker </span>Ivanov(<span style=" color: #A21515;">&quot;Ivanov A. N.&quot;</span>, 1977, 67000, <span style=" color: #A21515;">&quot;accounting department&quot;</span>, <span style=" color: #A21515;">&quot;chief accountant&quot;</span>);</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Worker </span>Sidorov(<span style=" color: #A21515;">&quot;Sidorov I. A.&quot;</span>, 1989, 42000, <span style=" color: #A21515;">&quot;engineering office&quot;</span>, <span style=" color: #A21515;">&quot;engineer&quot;</span>); <span style=" color: #2B91AE;">Worker </span>Petrov(<span style=" color: #A21515;">&quot;Petrov N. K.&quot;</span>, 1995, 23000, <span style=" color: #A21515;">&quot;additional staff&quot;</span>, <span style=" color: #A21515;">&quot;driver&quot;</span>); PrintInfo(Ivanov);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">PrintInfo(Sidorov); PrintInfo(Petrov); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Проблемы множественного наследования</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Множественное наследование требует тщательного проектирования, так как может привести к непредвиденным последствиям. Большинство таких последствий вызваны неоднозначностью в наследовании. Рассмотрим пример: <span class="s3">class </span><span class="s10">Printer</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>DoPrint(<span style=" color: #00F;">char </span>*<span style=" color: #808080;">filename</span>) <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;printing %s\n&quot;</span>, <span style=" color: #808080;">filename</span>);} <span style=" color: #00F;">void </span>Check() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;checking printing system\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Scanner</span><span style=" color: #000;">{ </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>DoScan(<span style=" color: #00F;">char </span>*<span style=" color: #808080;">filename</span>) <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;scanning into %s\n&quot;</span>, <span style=" color: #808080;">filename</span>);} <span style=" color: #00F;">void </span>Check() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;checking scanning system\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Copier</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Printer</span><span style=" color: #000;">, </span>public <span style=" color: #2B91AE;">Scanner</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Copier </span>HP_LaserJet_Pro_M428fdw; HP_LaserJet_Pro_M428fdw.DoPrint(<span style=" color: #A21515;">&quot;d:\\text.txt&quot;</span>); HP_LaserJet_Pro_M428fdw.DoScan(<span style=" color: #A21515;">&quot;d:\\scan.jpg&quot;</span>);</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//HP_LaserJet_Pro_M428fdw.Check(); //неоднозначный уровень доступа &quot;Check&quot;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">При компиляции выражения HP_LaserJet_Pro_M428fdw.Check() выполняется поиск метода Check() у класса Copier. Такой метод в этом классе отсутствует, поэтому компилятор двигается по цепочке наследования вверх и смотрит, есть ли этот метод в каком-либо из родительских классов. И здесь возникает проблема — Check() есть как у Printer, так и у Scanner. Следовательно, вызов этого метода приводит к неоднозначности и мы получим ошибку, так как компилятор не будет знать</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">какую версию Check() ему вызывать. Конечно можно явно указать, какую версию Check() следует вызывать:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Copier </span>HP_LaserJet_Pro_M428fdw; HP_LaserJet_Pro_M428fdw.DoPrint(<span style=" color: #A21515;">&quot;d:\\text.txt&quot;</span>); HP_LaserJet_Pro_M428fdw.DoScan(<span style=" color: #A21515;">&quot;d:\\scan.jpg&quot;</span>); HP_LaserJet_Pro_M428fdw.<span style=" color: #2B91AE;">Printer</span>::Check(); HP_LaserJet_Pro_M428fdw.<span style=" color: #2B91AE;">Scanner</span>::Check(); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Хотя это решение довольно простое, но всё может стать намного сложнее, если наш класс будет иметь, например, 4 родительских класса, которые, в свою очередь, будут иметь свои родительские классы. Возможность возникновения <b>конфликтов имен </b>будет увеличиваться экспоненциально с каждым добавленным родительским классом, и в каждом из таких случаев нужно будет явно указывать версии методов, которые следует вызывать, дабы избежать</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">неоднозначности.Проблема ромба (Diamond problem) - классическая проблема в языках, программирования, которые поддерживают возможность множественного наследования. Эта проблема возникает, когда классы B и C наследуют</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">A, а класс D наследует B и C. При такой иерархии наследования возникает как неоднозначность при вызове методов, так и</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">копирование данных класса A в класс D дважды: первый раз в составе данных класса B и второй раз в составе данных класса C. Модифицируем рассмотренный выше пример, определим класса Printer и Scanner как наследников класса OfficeDevice:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">OfficeDevice</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">char <span style=" color: #000;">ipAddress[15]; </span>unsigned <span style=" color: #000;">port; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">OfficeDevice(<span style=" color: #00F;">const char</span>* <span style=" color: #808080;">ipAddress </span>= <span style=" color: #A21515;">&quot;192.168.1.1&quot;</span>, <span style=" color: #00F;">const unsigned </span><span style=" color: #808080;">port </span>= 2000)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Create OfficeDevice: %s:%u\n&quot;</span>, <span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>); strncpy(<span style=" color: #00F;">this</span>-&gt;ipAddress, <span style=" color: #808080;">ipAddress</span>, 15);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;port = <span style=" color: #808080;">port</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">const char<span style=" color: #000;">* GetIpAddress (){</span>return <span style=" color: #000;">ipAddress;} </span>const unsigned <span style=" color: #000;">GetPort(){</span>return <span style=" color: #000;">port;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Printer</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">OfficeDevice</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Printer(<span style=" color: #00F;">const char</span>* <span style=" color: #808080;">ipAddress </span>= <span style=" color: #A21515;">&quot;192.168.1.1&quot;</span>, <span style=" color: #00F;">const unsigned </span><span style=" color: #808080;">port </span>= 2000): <span style=" color: #2B91AE;">OfficeDevice</span>(<span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Create Printer: %s:%u\n&quot;</span>, <span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>DoPrint(<span style=" color: #00F;">char </span>*<span style=" color: #808080;">filename</span>) <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;printing %s\n&quot;</span>, <span style=" color: #808080;">filename</span>);} <span style=" color: #00F;">void </span>Check() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;checking printing system\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Scanner</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">OfficeDevice</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Scanner(<span style=" color: #00F;">const char</span>* <span style=" color: #808080;">ipAddress </span>= <span style=" color: #A21515;">&quot;192.168.1.1&quot;</span>, <span style=" color: #00F;">const unsigned </span><span style=" color: #808080;">port </span>= 2000): <span style=" color: #2B91AE;">OfficeDevice</span>(<span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Create Scanner: %s:%u\n&quot;</span>, <span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>DoScan(<span style=" color: #00F;">char </span>*<span style=" color: #808080;">filename</span>) <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;scanning into %s\n&quot;</span>, <span style=" color: #808080;">filename</span>);} <span style=" color: #00F;">void </span>Check() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;checking scanning system\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Copier</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Printer</span><span style=" color: #000;">, </span>public <span style=" color: #2B91AE;">Scanner</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Copier(<span style=" color: #00F;">const char</span>* <span style=" color: #808080;">ipAddress </span>= <span style=" color: #A21515;">&quot;192.168.1.1&quot;</span>, <span style=" color: #00F;">const unsigned </span><span style=" color: #808080;">port </span>= 2000): <span style=" color: #2B91AE;">Printer</span>(<span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>), <span style=" color: #2B91AE;">Scanner</span>(<span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Create Copier: %s:%u\n&quot;</span>, <span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">PrintNetworkSettings() </span>const</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Network settings:\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\tPrinter: %s:%u\n&quot;</span>, <span style=" color: #2B91AE;">Printer</span>::ipAddress, <span style=" color: #2B91AE;">Printer</span>::port); printf(<span style=" color: #A21515;">&quot;\tScanner: %s:%u\n&quot;</span>, <span style=" color: #2B91AE;">Scanner</span>::ipAddress, <span style=" color: #2B91AE;">Scanner</span>::port);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">//printf(&quot;\tOfficeDevice: %s:%u\n&quot;, OfficeDevice::ipAddress,</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">OfficeDevice::port); // неоднозначность</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//printf(&quot;\t%s:%u\n&quot;, ipAddress, port); // неоднозначность</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Copier </span>HP_LaserJet_Pro_M428fdw(<span style=" color: #A21515;">&quot;192.168.57.13&quot;</span>, 1586); HP_LaserJet_Pro_M428fdw.DoPrint(<span style=" color: #A21515;">&quot;d:\\text.txt&quot;</span>); HP_LaserJet_Pro_M428fdw.DoScan(<span style=" color: #A21515;">&quot;d:\\scan.jpg&quot;</span>); HP_LaserJet_Pro_M428fdw.PrintNetworkSettings(); <span style=" color: #00F;">unsigned </span>port;</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//port = HP_LaserJet_Pro_M428fdw.GetPort();// неоднозначность</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">port = HP_LaserJet_Pro_M428fdw.<span style=" color: #2B91AE;">Printer</span>::GetPort(); port = HP_LaserJet_Pro_M428fdw.<span style=" color: #2B91AE;">Scanner</span>::GetPort();</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В данном примере мало того что также имеет место неоднозначность, например для функции GetPort(), так еще и</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">произошло дублирование членов базового класса OfficeDevice, как видно из кода функции PrintNetworkSettings(), где мы обращаемся к полям ipAddress и port унаследованным как от класса Printer, так и от класса Scanner. И при этом</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">при попытке обращения</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">к этим полям через базовый класс получаем ошибку: «базовый класс &quot;OfficeDevice&quot; не является однозначным». При такой иерархии классов мы получили в классе Copier <b>две копии класса OfficeDevice</b>: одну от Printer и одну от Scanner. Вызов конструктора базового класса также производился дважды, как видно из вывода.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Виртуальное наследование</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В некоторых случаях желательно, что бы базовый класс был общим для всех дочерних классов. этого можно достичь с помощью виртуального базового класса. <b>Виртуальный базовый класс </b>— это класс, объект которого является общим для использования всеми дочерними классами. Синтаксически указание того, что класс наследуется как виртуальный обозначается ключевым словом virtual в списке базовых классов:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">class &lt;имя класса&gt;:<b>[</b>virtual<b>] [</b>&lt;атрибут наследования&gt;<b>]</b>&lt;имя базового класса&gt;</p><p class="s13" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">[<span class="s9">,</span>[<span class="s9">virtual</span>] [<span class="s9">&lt;атрибут наследования&gt;</span>]<span class="s9">&lt;имя базового класса&gt; ...</span>] <span class="s9">{...}</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Модифицируем рассмотренный выше пример, сделав базовый класс OfficeDevice виртуальным:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">OfficeDevice</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">char <span style=" color: #000;">ipAddress[15];</span>unsigned <span style=" color: #000;">port; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">OfficeDevice(<span style=" color: #00F;">const char</span>* <span style=" color: #808080;">ipAddress </span>= <span style=" color: #A21515;">&quot;192.168.1.1&quot;</span>, <span style=" color: #00F;">const unsigned </span><span style=" color: #808080;">port </span>= 2000)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Create OfficeDevice: %s:%u\n&quot;</span>, <span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>); strncpy(<span style=" color: #00F;">this</span>-&gt;ipAddress, <span style=" color: #808080;">ipAddress</span>, 15);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;port = <span style=" color: #808080;">port</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">const char<span style=" color: #000;">* GetIpAddress (){</span>return <span style=" color: #000;">ipAddress;} </span>const unsigned <span style=" color: #000;">GetPort(){</span>return <span style=" color: #000;">port;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Printer</span><span style=" color: #000;">: </span>virtual public <span style=" color: #2B91AE;">OfficeDevice</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Printer(<span style=" color: #00F;">const char</span>* <span style=" color: #808080;">ipAddress </span>= <span style=" color: #A21515;">&quot;192.168.1.1&quot;</span>, <span style=" color: #00F;">const unsigned </span><span style=" color: #808080;">port </span>= 2000): <span style=" color: #2B91AE;">OfficeDevice</span>(<span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Create Printer: %s:%u\n&quot;</span>, <span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>DoPrint(<span style=" color: #00F;">char </span>*<span style=" color: #808080;">filename</span>) <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;printing %s\n&quot;</span>, <span style=" color: #808080;">filename</span>);} <span style=" color: #00F;">void </span>Check() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;checking printing system\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Scanner</span><span style=" color: #000;">: </span>virtual public <span style=" color: #2B91AE;">OfficeDevice</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Scanner(<span style=" color: #00F;">const char</span>* <span style=" color: #808080;">ipAddress </span>= <span style=" color: #A21515;">&quot;192.168.1.1&quot;</span>, <span style=" color: #00F;">const unsigned </span><span style=" color: #808080;">port </span>= 2000): <span style=" color: #2B91AE;">OfficeDevice</span>(<span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Create Scanner: %s:%u\n&quot;</span>, <span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>DoScan(<span style=" color: #00F;">char </span>*<span style=" color: #808080;">filename</span>) <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;scanning into %s\n&quot;</span>, <span style=" color: #808080;">filename</span>);} <span style=" color: #00F;">void </span>Check() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;checking scanning system\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Copier</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Printer</span><span style=" color: #000;">, </span>public <span style=" color: #2B91AE;">Scanner</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Copier(<span style=" color: #00F;">const char</span>* <span style=" color: #808080;">ipAddress </span>= <span style=" color: #A21515;">&quot;192.168.1.1&quot;</span>, <span style=" color: #00F;">const unsigned </span><span style=" color: #808080;">port </span>= 2000): <span style=" color: #2B91AE;">Printer</span>(), <span style=" color: #2B91AE;">Scanner</span>(), <span style=" color: #2B91AE;">OfficeDevice</span>(<span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Create Copier: %s:%u\n&quot;</span>, <span style=" color: #808080;">ipAddress</span>, <span style=" color: #808080;">port</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">PrintNetworkSettings() </span>const</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Network settings:\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\tPrinter: %s:%u\n&quot;</span>, <span style=" color: #2B91AE;">Printer</span>::ipAddress, <span style=" color: #2B91AE;">Printer</span>::port); printf(<span style=" color: #A21515;">&quot;\tScanner: %s:%u\n&quot;</span>, <span style=" color: #2B91AE;">Scanner</span>::ipAddress, <span style=" color: #2B91AE;">Scanner</span>::port); printf(<span style=" color: #A21515;">&quot;\tOfficeDevice: %s:%u\n&quot;</span>, <span style=" color: #2B91AE;">OfficeDevice</span>::ipAddress, <span style=" color: #2B91AE;">Printer</span>::port);</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// неоднозначность устранена</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\t%s:%u\n&quot;</span>, ipAddress, port);<span style=" color: #008000;">// неоднозначность устранена</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Copier </span>HP_LaserJet_Pro_M428fdw(<span style=" color: #A21515;">&quot;192.168.57.13&quot;</span>, 1586); HP_LaserJet_Pro_M428fdw.DoPrint(<span style=" color: #A21515;">&quot;d:\\text.txt&quot;</span>); HP_LaserJet_Pro_M428fdw.DoScan(<span style=" color: #A21515;">&quot;d:\\scan.jpg&quot;</span>); HP_LaserJet_Pro_M428fdw.PrintNetworkSettings();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">unsigned </span>port = HP_LaserJet_Pro_M428fdw.GetPort();<span style=" color: #008000;">// неоднозначность устранена</span>getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Теперь, при создании класса Copier, мы получим только одну копию OfficeDevice, которая будет общей как для Scanner, так и для Printer. При таком определении классов каждый экземпляр класса Copier будет содержать лишь по одному экземпляру полей и методов класса OfficeDevice, что избавляет от неоднозначности. Возникает вопрос: «Если Scanner и Printer совместно</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">используют родительский класс OfficeDevice, то кто ответственный за его создание?». Оказывается, Copier.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Конструктор Copier отвечает за создание объекта OfficeDevice, что отражается в его списке инициализации. Это один из тех случаев, когда дочернему классу разрешено вызывать конструктор родительского класса, который не является его непосредственным</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">родителем. Фактически вызов конструктора класса OfficeDevice в списке инициализации классов Scanner и Printer необходим только для создания объектов непосредственно этих классов, а в данной программе эти вызовы</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">игнорируются, что видно по выводу функции PrintNetworkSettings(). Есть несколько особенностей виртуального наследования:</p><ol id="l8"><li data-list-text="1."><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Виртуальные базовые классы всегда создаются перед невиртуальными базовыми классами, что обеспечивает построение всех базовых классов до построения их производных классов.</p></li><li data-list-text="2."><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Конструкторы промежуточных классов вызывают конструкторы базового виртуального класса, но это имеет смысл только при создании непосредственно объектов этих классов. При создании объектов производного от</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">промежуточных классов класса эти вызовы конструктора игнорируются.</p></li><li data-list-text="3."><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Если класс, становясь дочерним, наследует один или несколько классов, которые, в свою очередь, имеют виртуальные базовые классы, то наиболее дочерний класс отвечает за создание виртуального базового класса. <span class="s2">Интерфейсы</span></p></li></ol><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Во многих языках программирования есть такое понятие как интерфейс. Интерфейс — это абстракция определяющая поведение класса объектов и существующая отдельно от класса. В свою очередь классы могут реализовывать</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">различные интерфейсы. Фактически интерфейс можно рассматривать как именованный набор сигнатур функций, и тот факт, что некоторый класс C реализует интерфейс I фактически означает, что класс C, некоторым специфичным для него образом реализует <b>все </b>функции, объявленные в интерфейсе I. При этом другой класс также может реализовать</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">этот интерфейс, но уже специфичным для него образом. В тоже время класс C кроме интерфейса I может</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">реализовывать еще ряд других нтерфейсов.В языке C++ понятие интерфейса отсутствует, но этот пробел можно</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">восполнить, используя множественное наследование от интерфейсных классов. В терминологии C++ интерфейсным классом называют класс, который <b>не имеет полей-данных и все методы которого являются чистыми виртуальными функциями</b>. Интерфейсные классы традиционно именуют с префиксом «I», например, IComparable, IPersistent и т.д.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Использования множественного наследования для</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">реализации интерфейсов, пожалуй, является наиболее обоснованным применением этой возможности языка, в</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">большинстве остальных задач, решаемых с помощью множественного наследования, можно обойтись и одиночным наследованием, избавив себя от необходимости решения вышеозначенных проблем. Рассмотрим описание и</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">реализацию интерфейсного класса на примере интерфейса класса ведения журнала событий, который будет иметь два метода: запись в журнал сообщения и запись в журнал ошибки:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">#include <span style=" color: #A21515;">&lt;stdio.h&gt; </span>#include<span style=" color: #A21515;">&lt;stdlib.h&gt; </span>#include<span style=" color: #A21515;">&lt;time.h&gt;</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">// интерфейсный класс</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">class <span style=" color: #2B91AE;">ILogger</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">virtual void <span style=" color: #000;">Message(</span>const char <span style=" color: #000;">*text) </span>const <span style=" color: #000;">= 0; </span>virtual void <span style=" color: #000;">Error(</span>const char <span style=" color: #000;">*text) </span>const <span style=" color: #000;">= 0; </span>virtual <span style=" color: #000;">~ILogger() {};</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// реализация логгирования на экран</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">ScreenLogger</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">ILogger</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Message(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">text</span>) <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;&gt;&gt; %s\n&quot;</span>, <span style=" color: #808080;">text</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Error(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">text</span>) <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;&gt;&gt; error: %s\n&quot;</span>, <span style=" color: #808080;">text</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// реализация логгирования в файл</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">FileLogger</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">ILogger</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">FILE </span>*logfile; <span style=" color: #00F;">public</span>:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">FileLogger(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">filename</span>) : logfile(<span style=" color: #6E0089;">NULL</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">logfile = fopen(<span style=" color: #808080;">filename</span>, <span style=" color: #A21515;">&quot;w&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Message(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">text</span>) <span style=" color: #00F;">const</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if</span>(logfile) fprintf(logfile, <span style=" color: #A21515;">&quot;%s\n&quot;</span>, <span style=" color: #808080;">text</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Error(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">text</span>) <span style=" color: #00F;">const</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if</span>(logfile) fprintf(logfile, <span style=" color: #A21515;">&quot;error: %s\n&quot;</span>, <span style=" color: #808080;">text</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~FileLogger()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">if<span style=" color: #000;">(logfile) fclose(logfile);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>processing(<span style=" color: #00F;">const unsigned </span><span style=" color: #808080;">size</span>, <span style=" color: #00F;">const </span><span style=" color: #2B91AE;">ILogger </span>&amp;<span style=" color: #808080;">logger</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">a, b;</span>char <span style=" color: #000;">text[80];</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">size</span>; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">a = rand() % 10;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">b = rand() % 10; <span style=" color: #00F;">if </span>(b == 0)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">sprintf(text, <span style=" color: #A21515;">&quot;%d/%d: division by zero&quot;</span>, a, b); <span style=" color: #808080;">logger</span>.Error(text);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">continue<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">sprintf(text, <span style=" color: #A21515;">&quot;%d/%d=%.2lf&quot;</span>, a, b, (<span style=" color: #00F;">double</span>)a/b); <span style=" color: #808080;">logger</span>.Message(text);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">srand((<span style=" color: #00F;">unsigned</span>)time(<span style=" color: #6E0089;">NULL</span>)); <span style=" color: #2B91AE;">ScreenLogger </span>s_logger; processing(20, s_logger); <span style=" color: #2B91AE;">FileLogger </span>f_logger(<span style=" color: #A21515;">&quot;d:\\log.txt&quot;</span>); processing(20, f_logger); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В этом примере мы абстрагировали функционал ведения журнала событий посредством интерфейсного класса ILogger и имеем возможность реализовать одну функцию обработки данных, принимающую ссылку на объект интерфейсного класса. А при вызове этой функции мы можем указать объект <b>любого класса-наследника </b>этого</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">интерфейсного класса (т.е. любого класса, который реализует интерфейс ILogger). В теле функции нам не важен фактический тип параметра logger, достаточно знать, что он реализует функционал интерфейса ILogger, который мы и используем. В свою очередь каждый из классов ScreenLogger и FileLogger реализует своим специфичным образом</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">декларированное в интерфейсном классе поведение: первый выводит события на экран, второй записывает в указанный при создании объекта файл. Работа класса ScreenLogger:Работа класса FileLogger:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 10pt;padding-left: 7pt;text-indent: 0pt;line-height: 20pt;text-align: left;"><span class="s14" style=" background-color: #0F0;">Лекция 10 Обработка исключений</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В данной лекции мы изучим обработку ошибок в программе с использованием исключений. прежде чем рассматривать непосредственно механизм исключений, рассмотрим альтернативные решения и их недостатки. <span class="s2">Альтернативные решения</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Допустим есть класс вектор и в этом классе определен методы доступа к элементу вектора на чтение и на запись по индексу:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Vector</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double<span style=" color: #000;">* data; </span>unsigned <span style=" color: #000;">size; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">size </span>= 0)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">size</span>]; <span style=" color: #00F;">this</span>-&gt;size = <span style=" color: #808080;">size</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp; <span style=" color: #808080;">v</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">v</span>.size]; size = <span style=" color: #808080;">v</span>.size;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">v</span>.size; i++) data[i] = <span style=" color: #808080;">v</span>.data[i];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">~Vector()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">delete <span style=" color: #000;">[]data;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">SetElement(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">, </span>double <span style=" color: #808080;">value</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">data[<span style=" color: #808080;">i</span>] = <span style=" color: #808080;">value</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">GetElement(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetSize(){</span>return <span style=" color: #000;">size;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В указанной выше реализации метода GetElement не производится никакой проверки на корректность индекса,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">поэтому если пользователь класса передаст значение индекса превышающее индекс последнего элемента, то метод вернет случайное значение из памяти. Аналогичным образом, при некорректном индексе метод SetElement, будет</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">писать значение за пределами блока памяти, выделенного в конструкторе. Понятное дело, что замалчивание этих проблем чревато дальнейшими ошибками. Можно поступить радикально:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">GetElement(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= size) abort(); <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}<span class="p">однако такое решение вряд ли можно назвать хорошим. т.к. при каждой попытке обращения к элементу вектора с некорректным индексом программа будет аварийно завершаться. Можно вставить дополнительную проверку и возвращать значение только при корректном значении индекса:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">GetElement(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&lt; size) <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="p">Однако в таком случае при некорректном индексе возвращаемое значение функции не задаётся, что также не хорошо, поскольку функция должна что-то вернуть. Таким образом, нам необходимо что-то вернуть и сообщить вызываемой функции об ошибке. Можно попытаться вернуть недопустимое значение, как признак ошибки: </span>double <span style=" color: #000;">GetElement(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&lt; size) <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>]; <span style=" color: #00F;">else return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В таком случае функция будет корректно отрабатывать при любом индексе и в целом такой подход является</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">неплохим, при условии, что действительно есть некоторое особое значение, которым можно сигнализировать об ошибочной ситуации. Для указателей таким значением является NULL, для индексов может быть значение -1, а вот для нашего случая вектора с</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">вещественными координатами такое значение выбрать не получится. поэтому данное решение в этом случае также не подходит. Еще одним вариантом является возврат флага успешности некоторого действия:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">double </span>GetElement(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">i</span>, <span style=" color: #00F;">bool </span>&amp;<span style=" color: #808080;">success</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s6" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">success <span style=" color: #000;">= (</span>i <span style=" color: #000;">&lt; size);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&lt; size) <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>]; <span style=" color: #00F;">else return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">или</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">bool </span>GetElement(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">i</span>, <span style=" color: #00F;">double </span>&amp;<span style=" color: #808080;">value</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&lt; size) <span style=" color: #808080;">value </span>= data[<span style=" color: #808080;">i</span>]; <span style=" color: #00F;">return </span>(<span style=" color: #808080;">i </span>&lt; size);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Это тоже довольно распространенный подход, но он требует изменения сигнатуры функции и дополнительной</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">проверки флага успешности в вызывающей функции, перед началом работы со значением координаты вектора. При этом никто не гарантирует, что автор вызывающей функции не забудет выполнить эту проверку. Еще одним</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">вариантом является использование специальной переменной, которая хранит код ошибки, либо признак успешности последней вызванной функции (метода). эта переменная может быть, как глобальной, так и членом класса:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Vector</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">...</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">bool <span style=" color: #000;">success; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">...<span style=" color: #00F;">double </span>GetElement(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">i</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">success = (<span style=" color: #808080;">i </span>&lt; size);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&lt; size) <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>]; <span style=" color: #00F;">else return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">bool <span style=" color: #000;">GetSuccess()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">return <span style=" color: #000;">success;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Подобный подход обладает теми же недостатками, что и предыдущий. Кроме указанных недостатков рассмотренные подходы еще не очень хорошо сочетаются с конструкторами: Что делать, если в конструктор объекта, например,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">переданы недопустимые значения? Конструкторы не могут использовать оператор return для возврата индикатора ошибки, а передача такого параметра по ссылке неудобна и кроме того требует явной проверки. Кроме того, даже</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">если проверка покажет, что с параметрами было что-то не то, то объект все равно уже будет создан, и в вызывающей функции потребуется уже устранять последствия. Обработка исключений как раз и обеспечивает механизм,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">позволяющий отделить обработку ошибок или других исключительных ситуаций от общего потока выполнения кода. Это предоставляет больше свободы в конкретных ситуациях, уменьшая при этом беспорядок, который вызывают коды возврата.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Генерация исключений</p><p class="s9" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="p">В языке C++ для извещения о возникновении исключительной ситуации используется оператор throw. Сам процесс этого извещения называется генерацией исключения. Синтаксис вызова оператора следующий: </span>throw <b>[</b>&lt;выражение&gt;<b>]</b></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В качестве выражения выступает объект-исключение желаемого типа. Как правило, этим значением является код ошибки, описание ошибки или некоторый класс-исключение. Как видно из синтаксиса выражение является</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">опциональным параметром для оператора throw – не указывать выражение допустимо только при регенерации</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">исключения, т.е. в блоке обработки исключений с целью отправки исключения на вышестоящий уровень обработки. Если throw без параметра используется вне блока обработки это приведет к завершению программы.</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">throw <span style=" color: #000;">-1; </span><span style=" color: #008000;">// генерация исключения типа int</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">throw <span style=" color: #000;">ENUM_INVALID_INDEX; </span><span style=" color: #008000;">// генерация исключения типа enum</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">throw <span style=" color: #A21515;">&quot;Can not take square root of negative number&quot;</span><span style=" color: #000;">; </span><span style=" color: #008000;">// генерация исключения типа const char* (строка C-style)</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">throw <span style=" color: #000;">dX; </span><span style=" color: #008000;">// генерация исключения типа double (переменная типа double, которая была определена ранее)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">throw </span>MyException(<span style=" color: #A21515;">&quot;Fatal Error&quot;</span>); <span style=" color: #008000;">// генерация исключения с использованием объекта класса</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">MyException</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Каждая из этих строк сигнализирует о том, что возникла какая-то ошибка, которую нужно обработать.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Обработка исключений</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Генерация исключений — это лишь одна часть процесса, эти исключения еще нужно найти и обработать. Поиск и обработку исключений в языке C++ выполняют с помощью блока try-catch. Блок try отвечает за обнаружение</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">исключений, а блок catch за их обработку. Эти блоки всегда используются совместно, т.е. синтаксисом языка не допускается использования блока try без блоков catch и наоборот. Синтаксис этого блока приведен ниже: <span class="s9">try{</span></p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">&lt;операторы&gt;</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">}</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">catch(&lt;описание исключения&gt;) {</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">&lt;операторы обработки исключения&gt;</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">}</p><p class="s13" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">[ <span class="s9">catch(&lt;описание исключения&gt;) {</span></p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">&lt;операторы обработки исключения&gt;</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">} ...<b>]</b></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">&lt;Операторы&gt; в блоке try представляют собой команды, во время выполнения которых может произойти</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">исключительная ситуация. При заключении некоторых операторов в блок try говорят, что эти операторы находятся в защищенном блоке.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">&lt;Описание исключения&gt; определяет тип исключения, которое будет обрабатываться в конкретном блоке catch. Здесь может быть представлен любой тип данных, как базовый, так и производный, кроме того здесь может быть</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">объявлена переменная указанного типа, которая в дальнейшем может быть использована в блоке обработки исключения. Кроме указания</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">конкретного типа здесь может указываться троеточие (...), что будет означать, что данный блок catch будет</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">обрабатывать исключения любого типа. &lt;Операторы обработки исключения&gt; в блоке catch представляют собой команды, которые</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">предназначены для разрешения исключительной ситуации в этом блоке. Однако, если при обработке исключения возникает ошибка или в рамках данного блока разрешить исключительную ситуацию полностью не представляется возможным, то в блоке catch допускается генерация нового или регенерация пойманного исключения, которое должно быть обнаружено и</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">обработано в каком-либо внешнем блоке try-catch. Если при выполнении программы достигнут блок try-catch, то</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">происходит выполнение операторов, находящихся в блоке try. Если при выполнении этих операторов не возникает</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">исключений, то выполнение продолжается с оператора, следующего за последним блоком catch, и ни один из блоков catch не выполняется. Если же при выполнении операторов в защищенном блоке генерируется исключение, то на</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">основе параметра оператора throw создаётся объект- исключение и производится поиск подходящего блока обработки catch. При поиске обработчики</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">просматриваются в порядке следования блоков catch в коде программы. При этом, если подходящий обработчик не найден, то выполняется поиск во внешнем блоке try-catch и так далее. Если обработчик найти не удаётся, то</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">производится аварийное завершение программы. Если соответствующий обработчик найден, то его формальный параметр инициализируется</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: justify;">копией объекта исключения, если он был указан как параметр по значению (catch (&lt;тип&gt; &lt;параметр&gt;)), либо адресом объекта-исключения, если он был указан как параметр по ссылке (catch (&lt;тип&gt; &amp;&lt;параметр&gt;)). После инициализации параметра начинается процесс <b>раскрутки стека</b>. В этом процессе выполняется вызов деструкторов всех объектов,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">созданных внутри блока try, при этом уничтожение объектов производится в порядке обратном их созданию. После раскрутки стека выполняются операторы обработки исключения соответствующего блока catch. В случае если при их выполнении никаких исключений не происходит, то выполнение продолжается с оператора, следующего за</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">последним из блоков catch.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Рассмотрим модификацию класса «вектор», в которой методы чтения и записи элементов по индексу будут генерировать исключения с описанием ошибок:<span class="s3">class </span><span class="s10">Vector</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double<span style=" color: #000;">* data; </span>unsigned <span style=" color: #000;">size; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">size </span>= 0)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">size</span>]; <span style=" color: #00F;">this</span>-&gt;size = <span style=" color: #808080;">size</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp; <span style=" color: #808080;">v</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">v</span>.size]; size = <span style=" color: #808080;">v</span>.size;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">v</span>.size; i++) data[i] = <span style=" color: #808080;">v</span>.data[i];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">~Vector()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">delete <span style=" color: #000;">[]data;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">SetElement(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">, </span>double <span style=" color: #808080;">value</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= size) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;SetElement - invalid index&quot;</span>); data[<span style=" color: #808080;">i</span>] = <span style=" color: #808080;">value</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">GetElement(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= size) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;GetElement - invalid index&quot;</span>); <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetSize(){</span>return <span style=" color: #000;">size;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">А теперь рассмотрим три варианта основной программы. Различия в коде будут только в диапазонах индексов при установке и чтении элементов вектора:</p><ol id="l9"><li data-list-text="1."><p style="padding-left: 18pt;text-indent: -10pt;text-align: left;">Ошибка при вызове метода SetElement.</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// error in SetElement <span style=" color: #00F;">int </span><span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Program started\n&quot;</span>); <span style=" color: #00F;">try</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\tWorking with vector\n&quot;</span>); <span style=" color: #2B91AE;">Vector </span>a(3);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\t\tSetting elements\n&quot;</span>); printf(<span style=" color: #A21515;">&quot;\t\t\t&quot;</span>);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt;= 3; i++) </span><span style=" color: #008000;">// invalid index</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><ol id="l10"><li data-list-text="a."><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">SetElement(i, i); printf(<span style=" color: #A21515;">&quot;%lf &quot;</span>, (<span style=" color: #00F;">double</span>)i);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">printf(<span style=" color: #A21515;">&quot;\t\tSetting finished\n&quot;</span>); printf(<span style=" color: #A21515;">&quot;\t\tGetting elements\n&quot;</span>); printf(<span style=" color: #A21515;">&quot;\t\t\t&quot;</span>);</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; 3; i++){ printf(<span style=" color: #A21515;">&quot;%lf &quot;</span>, a.GetElement(i));</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\t\tGetting finished\n&quot;</span>); printf(<span style=" color: #A21515;">&quot;\tWorking finished\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">catch<span style=" color: #000;">(</span>char<span style=" color: #000;">* err)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\nError: %s\n&quot;</span>, err);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Program finished\n&quot;</span>); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p></li></ol></li><li data-list-text="2."><p style="padding-left: 18pt;text-indent: -10pt;line-height: 13pt;text-align: left;">Ошибка при вызове метода GetElement:</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// error in GetElement <span style=" color: #00F;">int </span><span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Program started\n&quot;</span>); <span style=" color: #00F;">try</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\tWorking with vector\n&quot;</span>); <span style=" color: #2B91AE;">Vector </span>a(3);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\t\tSetting elements\n&quot;</span>); printf(<span style=" color: #A21515;">&quot;\t\t\t&quot;</span>);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt; 3; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><ol id="l11"><li data-list-text="a."><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">SetElement(i, i); printf(<span style=" color: #A21515;">&quot;%lf &quot;</span>, (<span style=" color: #00F;">double</span>)i);</p></li></ol></li></ol><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">printf(<span style=" color: #A21515;">&quot;\t\tSetting finished\n&quot;</span>); printf(<span style=" color: #A21515;">&quot;\t\tGetting elements\n&quot;</span>); printf(<span style=" color: #A21515;">&quot;\t\t\t&quot;</span>);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt;= 3; i++) </span><span style=" color: #008000;">// invalid index</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%lf &quot;</span>, a.GetElement(i));</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\t\tGetting finished\n&quot;</span>); printf(<span style=" color: #A21515;">&quot;\tWorking finished\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">catch<span style=" color: #000;">(</span>char<span style=" color: #000;">* err)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\nError: %s\n&quot;</span>, err);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Program finished\n&quot;</span>); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">}<span class="p">3. Вызов без ошибок:</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// no errors <span style=" color: #00F;">int </span><span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Program started\n&quot;</span>); <span style=" color: #00F;">try</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\tWorking with vector\n&quot;</span>); <span style=" color: #2B91AE;">Vector </span>a(3);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\t\tSetting elements\n&quot;</span>); printf(<span style=" color: #A21515;">&quot;\t\t\t&quot;</span>);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt; 3; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><ol id="l12"><li data-list-text="a."><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">SetElement(i, i); printf(<span style=" color: #A21515;">&quot;%lf &quot;</span>, (<span style=" color: #00F;">double</span>)i);</p></li></ol><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: justify;">printf(<span style=" color: #A21515;">&quot;\t\tSetting finished\n&quot;</span>); printf(<span style=" color: #A21515;">&quot;\t\tGetting elements\n&quot;</span>); printf(<span style=" color: #A21515;">&quot;\t\t\t&quot;</span>);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt; 3; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%lf &quot;</span>, a.GetElement(i));</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\t\tGetting finished\n&quot;</span>); printf(<span style=" color: #A21515;">&quot;\tWorking finished\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">catch<span style=" color: #000;">(</span>char<span style=" color: #000;">* err)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\nError: %s\n&quot;</span>, err);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Program finished\n&quot;</span>); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}<span class="p">Как можно понять из вывода, в первом варианте исполнение защищенного блока дошло только до строки a.SetElement(i, i) с параметром i равным 3. При вызове метода SetElement с параметром 3 было сгенерировано</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">исключение &quot;SetElement - invalid index&quot; и незамедлительно начал исполняться код в блоке catch. После обработки исключения (вывод текста ошибки) исполнение программы возобновилось с оператора printf(&quot;Program finished\n&quot;)</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">следующего сразу за блоком catch. Во втором варианте исполнение защищенного блока дошло до строки printf(&quot;%lf &quot;, a.GetElement(i)) с параметром i равным 3. Аналогично метод GetElement сгенерировал исключение &quot;GetElement -</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">invalid index&quot; и управление было передано в блок обработки исключений catch. В третьем же варианте работа с</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">экземпляром класса не вызвала никаких исключений, поэтому защищаемы блок отработал полностью и сразу после него управление было передано на оператор printf(&quot;Program finished\n&quot;), следующий сразу за блоком обработки</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">исключений catch - операторы блока обработки исключений не были вызваны. Теперь рассмотрим процесс раскрутки стека. Модифицируем класс – добавим печать информации в конструкторах и в деструкторе:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Vector</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double<span style=" color: #000;">* data; </span>unsigned <span style=" color: #000;">size; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">size </span>= 0)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;&gt;&gt; Vector::Consructor\n&quot;</span>); data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">size</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;size = <span style=" color: #808080;">size</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp; <span style=" color: #808080;">v</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;&gt;&gt; Vector::CopyConsructor\n&quot;</span>); data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">v</span>.size];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">size = <span style=" color: #808080;">v</span>.size;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">v</span>.size; i++) data[i] = <span style=" color: #808080;">v</span>.data[i];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~Vector()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;&gt;&gt; Vector::Destructor\n&quot;</span>); <span style=" color: #00F;">delete </span>[]data;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">SetElement(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">, </span>double <span style=" color: #808080;">value</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= size) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;SetElement - invalid index&quot;</span>); data[<span style=" color: #808080;">i</span>] = <span style=" color: #808080;">value</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">GetElement(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= size) <span style=" color: #00F;">throw</span>(<span style=" color: #A21515;">&quot;GetElement - invalid index&quot;</span>); <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">unsigned <span style=" color: #000;">GetSize(){</span>return <span style=" color: #000;">size;}</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Также реализуем две функции: Sum - вычисляет сумму элементов вектора и Processing - создает объект класса</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="p">«вектор» заданного размера, заполняет его значениями и вычисляет сумму. с помощью первой функции.</span><span style=" color: #00F;">double </span>Sum(<span style=" color: #2B91AE;">Vector </span><span style=" color: #808080;">v</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">double </span>sum = 0; printf(<span style=" color: #A21515;">&quot;Calculatng sum\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">v</span>.GetSize(); i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">sum += <span style=" color: #808080;">v</span>.GetElement(i);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Calculatng finished\n&quot;</span>); <span style=" color: #00F;">return </span>sum;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">Processing(</span>unsigned <span style=" color: #808080;">size</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Processing started\n&quot;</span>); <span style=" color: #2B91AE;">Vector </span>a(<span style=" color: #808080;">size</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">size</span>; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><ol id="l13"><li data-list-text="a."><p class="s4" style="padding-left: 18pt;text-indent: -10pt;text-align: left;">SetElement(i, i);</p></li></ol><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Call Sum()\n&quot;</span>); <span style=" color: #00F;">double </span>sum = Sum(a); printf(<span style=" color: #A21515;">&quot;Sum is: %lf\n&quot;</span>, sum);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Processing finished\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Рассмотрим основную программу:</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// no errors <span style=" color: #00F;">int </span><span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Program started\n&quot;</span>); <span style=" color: #00F;">try</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Call Processing()\n&quot;</span>); Processing(5);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">catch<span style=" color: #000;">(</span>char<span style=" color: #000;">* err)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\nError: %s\n&quot;</span>, err);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Program finished\n&quot;</span>); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В защищенном блоке вызывается функция Processing, если в ее работе или в работе функции Sum, которую вызывает эта функция будет сгенерировано исключение, то запустится процесс раскрутки стека. после чего исполнение кода</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">перейдет в блок обработки ошибок. В случае безошибочной работы вывод будет следующим:Здесь нас интересует создание и уничтожение объектов. Первый вызов конструктора (Vector::Consructor) соответствует определению вектора a в функции Processing, вызов конструктора копирования (Vector::CopyConsructor) обусловлен созданием локальной копии a при</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">вызове функции Sum. Далее следует первый вызов деструктора (Vector::Destructor) после завершения функции Sum –удаление локальной копии и затем вызов деструктора (Vector::Destructor) после завершения функции Processing –удаление вектора a. Теперь изменим код функции Sum, что бы при вычислении суммы возникал выход индекса за допустимый диапазон:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">double </span>Sum(<span style=" color: #2B91AE;">Vector </span><span style=" color: #808080;">v</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">double </span>sum = 0; printf(<span style=" color: #A21515;">&quot;Calculatng sum\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt;= <span style=" color: #808080;">v</span>.GetSize(); i++) <span style=" color: #008000;">// invalid index</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">sum += <span style=" color: #808080;">v</span>.GetElement(i);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Calculatng finished\n&quot;</span>);</p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">sum;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Выполним ту же программу и рассмотрим вывод:</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">С вызовами конструкторов здесь все также, как и в предыдущем случае, а вот деструкторы вызываются поочередно, непосредственно после вызова v.GetElement(i) породившего исключение. Дело в том, что поскольку в функции Sum нет обработчика исключений, то при его возникновении завершается выполнение этой функции, с соответствующим вызовом деструктора для локальной копии вектора а и происходит поиск подходящего обработчика в вызывающей функции Processing. В функции Processing также нет обработчика исключений, ее выполнение завершается с</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">сопутствующим уничтожением вектора a и происходит поиск подходящего обработчика в вызывающей функции main. Только в main находится подходящий обработчик, который и разрешает исключение сгенерированное функцией Sum.</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">А что будет, если и в функции main не будет обработчика исключений? В этом случае мы будем иметь дело с</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">необработанным исключением (unhandled exception), которое приводит к аварийному завершению программы. Рассмотрим на примере – уберем обработку исключений из функции main:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;Program started\n&quot;</span>); Processing(5); printf(<span style=" color: #A21515;">&quot;Program finished\n&quot;</span>); getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}<span class="p">Как видим, при возникновении необработанного исключения просто завершается программа.</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s14" style=" background-color: #0F0;">Лекция 11 Классы исключения</span></p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Классы исключения</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Одной из основных проблем использования базовых типов данных (например, типа int) в качестве типов исключений является то, что они, не позволяют отделить различные типы исключительных ситуаций друг от друга и несут мало</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">полезной информации. Что, например, означает исключение, когда в блоке try имеется несколько выражений или вызовов функций:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">*value = </span>new int<span style=" color: #000;">(vector.GetElement(index1) + vector.GetElement(index2));</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">catch <span style=" color: #000;">(</span>int <span style=" color: #000;">value)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// что именно произошло?</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В этом примере, если мы поймаем исключение типа int, что оно нам сообщит? Возможно некорректный индекс, возможно оператор «+» вызвал целочисленное переполнение, возможно оператор new не сработал из-за нехватки памяти... Конечно можно использовать исключения типа const char* которые будут давать описание ошибки, но это также не даст нам возможности обрабатывать исключения разных типов по-разному. А такая возможность</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">необходима, поскольку</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">на стороне вызывающей функции возможны различные действия при возникновении каждой определенной</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">нештатной ситуации. В некоторых ситуациях стоит завершить программу, в некоторых - повторно запросить данные у пользователя, в некоторых – повторить действие позже. Одним из способов решения этой проблемы является</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">использование классов-исключений. <b>Класс- Исключение </b>— это обычный класс, объект которого выбрасывается в качестве исключения. При</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">этом объекты разных классов соответствуют различным типам исключительных ситуаций, а переменные-члены класса хранят некую полезную информацию об исключительной ситуации. Создадим простой класс-исключение, который</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">будет использоваться с нашим классом вектор, для информирования вызывающей стороны об ошибке при указании недопустимого индекса:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">EInvalidIndex</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">ind, min, max; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">EInvalidIndex(<span style=" color: #00F;">int </span><span style=" color: #808080;">ind</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">min</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">max</span>): ind(<span style=" color: #808080;">ind</span>), min(<span style=" color: #808080;">min</span>), max(<span style=" color: #808080;">max</span>) {};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>Print(){ printf(<span style=" color: #A21515;">&quot;Index value %d is out of range [%d, %d]&quot;</span>, ind, min, max);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Vector</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double<span style=" color: #000;">* data; </span>unsigned <span style=" color: #000;">size; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">size </span>= 0)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">size</span>]; <span style=" color: #00F;">this</span>-&gt;size = <span style=" color: #808080;">size</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp; <span style=" color: #808080;">v</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[<span style=" color: #808080;">v</span>.size]; size = <span style=" color: #808080;">v</span>.size;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">v</span>.size; i++) data[i] = <span style=" color: #808080;">v</span>.data[i];}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~Vector()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">delete <span style=" color: #000;">[]data;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double<span style=" color: #000;">&amp; Element(</span>unsigned <span style=" color: #808080;">i</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">i </span>&gt;= size) <span style=" color: #00F;">throw </span><span style=" color: #2B91AE;">EInvalidIndex</span>(<span style=" color: #808080;">i</span>, 0, size-1); <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">i</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetSize(){</span>return <span style=" color: #000;">size;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector <span style=" color: #000;">a(3); a.Element(0) = 5;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">a.Element(1) = a.Element(0)*2;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">a.Element(2) = a.Element(3)/2; <span style=" color: #008000;">//некорректный индекс</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">catch</span>(<span style=" color: #2B91AE;">EInvalidIndex </span>&amp;err)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">err.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Модифицируем класс вектор, что бы при работе с ним могла возникать еще одна исключительная ситуация. Добавим метод Sum, который возвращает сумму объекта, для которого этот метод вызывается и другого экземпляра класса вектор. Естественно для выполнения операции размерности векторов должны совпадать:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">Vector </span>Sum(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp;<span style=" color: #808080;">v</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//проверка размерности v и генерация исключения</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector <span style=" color: #000;">res(size);</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt; size; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">res.data[i] = data[i] + <span style=" color: #808080;">v</span>.data[i];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">return <span style=" color: #000;">res;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Для данной ситуации исключение EInvalidIndex уже не подходит, т.к. это совершенно другая ошибочная ситуация, поэтому понадобится определять еще один класс исключение, например, такой:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">EInvalidArg</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">char <span style=" color: #000;">name[20]; </span>char <span style=" color: #000;">details[100]; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">EInvalidArg(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">name</span>, <span style=" color: #00F;">const char </span>*<span style=" color: #808080;">details</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">strncpy(<span style=" color: #00F;">this</span>-&gt;name, <span style=" color: #808080;">name</span>, 20);</p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">this<span style=" color: #000;">-&gt;name[19] = 0;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">strncpy(<span style=" color: #00F;">this</span>-&gt;details, <span style=" color: #808080;">details</span>, 100);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">this<span style=" color: #000;">-&gt;details[99] = 0;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Print(){ printf(<span style=" color: #A21515;">&quot;Invalid argument &lt;%s&gt; %s&quot;</span>, name, details);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В таком случае метод Sum может иметь следующую реализацию:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">Vector </span>Sum(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Vector </span>&amp;<span style=" color: #808080;">v</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">v</span>.size != size) <span style=" color: #00F;">throw </span><span style=" color: #2B91AE;">EInvalidArg</span>(<span style=" color: #A21515;">&quot;v&quot;</span>, <span style=" color: #A21515;">&quot;- inconsistent vector dimensions&quot;</span>); <span style=" color: #2B91AE;">Vector </span>res(size);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">for <span style=" color: #000;">(</span>int <span style=" color: #000;">i = 0; i &lt; size; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">res.data[i] = data[i] + <span style=" color: #808080;">v</span>.data[i];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">res;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Обработка такого исключения может выглядеть так:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector <span style=" color: #000;">a(3); a.Element(0) = 5;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">a.Element(1) = 5;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">a.Element(2) = 4; <span style=" color: #2B91AE;">Vector </span>b(2); b.Element(0) = 1;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">b.Element(1) = 7;</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector <span style=" color: #000;">c = a.Sum(b); </span><span style=" color: #008000;">//несоответствие размерностей</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">catch</span>(<span style=" color: #2B91AE;">EInvalidArg </span>&amp;err)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">err.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">В нашем примере оба класса исключений являются независимыми друг от друга, на практике такой подход не применяют, т.к. программисту, использующему такой код придется всюду отлавливать и обрабатывать по</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">отдельности все введенные типы исключений. Действительно если мы захотим обработать как случай некорректного индекса, так и случай несоответствия размерности, то в вызывающем коде придется указать два блока обработки:<span class="s3">int </span><span class="s4">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//работа с вектором<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">catch</span>(<span style=" color: #2B91AE;">EInvalidArg </span>&amp;err)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//случай несоответствия размерностей</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">err.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">catch</span>(<span style=" color: #2B91AE;">EInvalidIndex </span>&amp;err)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//случай ошибочного индекса</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">err.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Для упрощения работы с исключениями классы исключения должны образовывать иерархию наследования. Рассмотрим на примере:</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// базовый класс исключение</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">EVectorException</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">char <span style=" color: #000;">* message; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">EVectorException (<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">message</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;message = strdup(<span style=" color: #808080;">message</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">EVectorException (<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">EVectorException </span>&amp;<span style=" color: #808080;">e</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;message = strdup(<span style=" color: #808080;">e</span>.message);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">virtual <span style=" color: #000;">~EVectorException()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">free(message);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">const char<span style=" color: #000;">* Message() {</span>return <span style=" color: #000;">message;} </span>virtual void <span style=" color: #000;">Print() {puts(message);}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// класс-наследник некорректный аргумент</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">EInvalidArg</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">EVectorException</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">char <span style=" color: #000;">*name; </span>char <span style=" color: #000;">*details; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">EInvalidArg(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">name</span>, <span style=" color: #00F;">const char </span>*<span style=" color: #808080;">details</span>): <span style=" color: #2B91AE;">EVectorException</span>(<span style=" color: #A21515;">&quot;Invalid argument&quot;</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;name = strdup(<span style=" color: #808080;">name</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">this</span>-&gt;details = strdup(<span style=" color: #808080;">details</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~EInvalidArg()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">free(name); free(details);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Print(){ printf(<span style=" color: #A21515;">&quot;Invalid argument &lt;%s&gt; %s&quot;</span>, name, details);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};<span style=" color: #008000;">// класс-наследник некорректный индекс</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">EInvalidIndex</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">EVectorException</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">ind, min, max; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">EInvalidIndex(<span style=" color: #00F;">int </span><span style=" color: #808080;">ind</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">min</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">max</span>): <span style=" color: #2B91AE;">EVectorException</span>(<span style=" color: #A21515;">&quot;Invalid index&quot;</span>), ind(<span style=" color: #808080;">ind</span>), min(<span style=" color: #808080;">min</span>), max(<span style=" color: #808080;">max</span>) {};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Print(){ printf(<span style=" color: #A21515;">&quot;Index value %d is out of range [%d, %d]&quot;</span>, ind, min, max);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В этом случае в вызывающем коде мы можем ограничиться поимкой исключений только ожидаемого базового класса ошибок, ну и добавить обработку неожидаемых в данном контексте исключений, как того требуют правила хорошего тона:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector <span style=" color: #000;">a(3); a.Element(0) = 5;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">a.Element(1) = 5;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">a.Element(2) = 4;</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//a.Element(3) = 9; //некорректный индекс</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector <span style=" color: #000;">b(2); b.Element(0) = 1;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">b.Element(1) = 7;</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector <span style=" color: #000;">c = a.Sum(b); </span><span style=" color: #008000;">//несоответствие размерностей</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">catch</span>(<span style=" color: #2B91AE;">EVectorException </span>&amp;err)</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">err.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">catch<span style=" color: #000;">(...)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">puts(<span style=" color: #A21515;">&quot;Unknown exception&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector <span style=" color: #000;">a(3); a.Element(0) = 5;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">a.Element(1) = 5;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">a.Element(2) = 4;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">a.Element(3) = 9; <span style=" color: #008000;">//некорректный индекс</span><span style=" color: #2B91AE;">Vector </span>b(2); b.Element(0) = 1;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">b.Element(1) = 7;</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Vector <span style=" color: #000;">c = a.Sum(b); </span><span style=" color: #008000;">//несоответствие размерностей</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">catch</span>(<span style=" color: #2B91AE;">EVectorException </span>&amp;err)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">err.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">catch<span style=" color: #000;">(...)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">puts(<span style=" color: #A21515;">&quot;Unknown exception&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">При реализации иерархии объектов исключений также можно обеспечить и дифференцированную обработку исключений, если того требует логика работы программы:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// работа с вектором<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">catch</span>(<span style=" color: #2B91AE;">EInvalidArg </span>&amp;err)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// действия при несоответствии размерности</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">catch</span>(<span style=" color: #2B91AE;">EInvalidIndex </span>&amp;err)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// действия при некорректном индексе</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">catch<span style=" color: #000;">(...)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">puts(<span style=" color: #A21515;">&quot;Unknown exception&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">getchar();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">При этом стоит учитывать иерархию наследования, рассмотрим пример:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Parent</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Parent() {}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Child</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Parent</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">: Child() {}}; </span>int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">throw <span style=" color: #2B91AE;">Child</span><span style=" color: #000;">();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">catch </span>(<span style=" color: #2B91AE;">Parent </span>&amp;parent)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;caught Parent&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">catch </span>(<span style=" color: #2B91AE;">Child </span>&amp;child)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;caught Child&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Дочерние классы могут быть пойманы обработчиком родительского класса. Поскольку Child является дочерним классу Parent, то из этого следует, что Child «является» Parent. Во-вторых, когда C++ пытается найти обработчик для выброшенного исключения, он делает это последовательно. Первое, что он проверяет — подходит ли обработчик</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">исключений класса Parent для исключений класса Child. Поскольку Child «является» Parent, то блок catch для объектов класса Parent подходит и, соответственно, выполняется. В этом случае блок catch для объектов класса Child никогда не выполнится. Чтобы этот пример работал по-другому, нам нужно изменить порядок последовательности блоков catch: <span class="s3">int </span><span class="s4">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">throw <span style=" color: #2B91AE;">Child</span><span style=" color: #000;">();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">catch </span>(<span style=" color: #2B91AE;">Child </span>&amp;child)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;caught Child&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">catch </span>(<span style=" color: #2B91AE;">Parent </span>&amp;parent)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;caught Parent&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}<span class="p">Таким образом, обработчик Child будет ловить и обрабатывать исключения класса Child. Исключения класса Parent не соответствуют обработчику Child (Child «является» Parent, но Parent «не является» Child) и, соответственно, будут обрабатываться только обработчиком Parent. </span><span class="h3">Обработчики дочерних классов исключений должны находиться перед обработчиками родительских классов исключений. Обработчик catch(...), который ловит все исключения всегда</span></p><h3 style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">располагают последним.</h3><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: justify;">Базовый класс исключений std::exception</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Многие классы и операторы из Стандартной библиотеки С++ выбрасывают классы-исключения при сбое. Например, оператор new и std::string могут выбрасывать std::bad_alloc при нехватке памяти. Неудачное динамическое</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">приведение типов с помощью оператора dynamic_cast выбрасывает исключение std::bad_cast и т.д. Все эти классы-исключения являются дочерними классу std::exception. Это небольшой интерфейсный класс, который используется в качестве родительского класса для любого исключения в Стандартной библиотеке C++. В большинстве случаев, если исключение выбрасывается Стандартной библиотекой С++ не важно было ли это неудачное выделение памяти,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">преобразование типа или что-либо другое. Достаточно знать, что произошло некое событие, которое нарушило обычное течение программы. Благодаря</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">наличию базового класса std::exception можно использовать только обработчик исключений типа std::exception, который будет ловить и обрабатывать как std::exception, так и все дочерние классы- исключений.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Для унификации обработки исключений рекомендуется создавать свои классы исключения на основе базового класса</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">std::exception:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">ArrayException</span><span style=" color: #000;">: </span>public <span style=" color: #000;">std::exception</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">// реализация</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Повторная генерация исключений</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Иногда возникает ситуация, при которой исключение обнаружено, но обрабатывать его в данный момент времени не нужно или невозможно возможности. Например, можно записать описание ошибки в лог-файл, а затем передать</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">исключение вызывающей процедуре для дальнейшей обработки. Для повторной генерации исключения необходимо сгенерировать исключение в блоке обработки (catch), в этом случае оно не будет обработано на текущем уровне и</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">будет передано</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="p">вызывающей стороне, где и должно будет быть обработано. При генерации исключения допускается генерировать новое исключение либо регенерировать уже пойманное. Генерацию нового исключения рассмотрим на примере функцию VectorsProcessing которая принимает два вектора и выполняет некоторую их обработку:</span><span style=" color: #00F;">void </span>VectorsProcessing(<span style=" color: #2B91AE;">Vector </span><span style=" color: #808080;">a</span>, <span style=" color: #2B91AE;">Vector </span><span style=" color: #808080;">b</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">// работа с векторами</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">catch</span>(<span style=" color: #2B91AE;">EVectorException </span>&amp;err)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">char <span style=" color: #000;">message[256];</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">sprintf(message, <span style=" color: #A21515;">&quot;Vectors processing error: %s&quot;</span>, err.Message()); <span style=" color: #00F;">throw </span>message;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В этом случае, при возникновении какой-либо исключительной ситуации при работе с векторами по данным</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">пойманного объекта исключения класса EVectorException будет сформировано текстовое сообщение об ошибке и</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">сгенерировано исключение типа const char*. Т.е. в этой функции генерируется новое исключение и даже другого типа, чем пойманное в блоке catch. Соответственно обработано это исключение должно быть где-то на вызывающей</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">стороне, в нашем случае это может быть функция main:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Vector <span style=" color: #000;">a(5); </span>Vector <span style=" color: #000;">b(7);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #008000;">//... </span>VectorsProcessing(a, b); puts(<span style=" color: #A21515;">&quot;OK&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">catch<span style=" color: #000;">(</span>char <span style=" color: #000;">*err)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">puts(err);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">При такой реализации функция main выведет на экран «OK», если обработка векторов произошла без ошибок, либо текст исключений, сгенерированных в функции VectorsProcessing («Vectors processing error: Invalid argument» или</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">«Vectors processing error: Invalid index»), если в процессе работы с векторами произошла какая-то исключительная ситуация.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">При регенерации следует вызывать оператор trow без параметров, т.к. указание уже пойманного объекта исключения может привести к ошибкам в случае с иерархией классов исключений. Рассмотрим на примерах:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Parent</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Parent() {}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">virtual void </span>Print(){ printf(<span style=" color: #A21515;">&quot;Parent&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Child</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Parent</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Child() {}<span style=" color: #00F;">void </span>Print(){ printf(<span style=" color: #A21515;">&quot;Child&quot;</span>);}</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">throw <span style=" color: #2B91AE;">Child</span><span style=" color: #000;">();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">catch</span>(<span style=" color: #2B91AE;">Parent </span>&amp;exception)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;caught exception of type &quot;</span>); exception.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot; and rethrow incorrect\n&quot;</span>); <span style=" color: #00F;">throw </span>exception;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">catch </span>(<span style=" color: #2B91AE;">Parent </span>&amp;exception)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;caught exception of type &quot;</span>); exception.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">По выводу видно, что на следующий уровень обработки уже пришло исключение не того типа, что было изначально. Дело в том, что в этом случае в блоке catch генерируется не точно такое же исключение, которое было поймано, а копия переменной exception. Однако в таком случае копия exception будет являться объектом класса Parent, а не класса Child, другими словами, произойдет <b>обрезка </b>объекта класса Child до класса Parent. Рассмотрим правильный вариант регенерации</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">исключения:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">try</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">throw <span style=" color: #2B91AE;">Child</span><span style=" color: #000;">();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">catch</span>(<span style=" color: #2B91AE;">Parent </span>&amp;exception)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;caught exception of type &quot;</span>); exception.Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot; and rethrow correct\n&quot;</span>); <span style=" color: #00F;">throw</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">catch </span>(<span style=" color: #2B91AE;">Parent </span>&amp;exception)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;caught exception of type &quot;</span>);exception.Print(); printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Ключевое слово throw в блоке catch, которое, как кажется на первый взгляд, не генерирует что- либо конкретное, на самом деле генерирует точно такое же исключение, которое было только что обработано блоком catch. Копирования объекта-исключения и, следовательно, обрезки объекта не происходит.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Генерация исключений в конструкторах и деструкторах</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Конструкторы — это еще один класс методов, в которой исключения могут быть очень полезными. Если конструктор не сработал (не может быть выполнен полностью в данных условиях), то допускается сгенерировать исключение, которое сообщит, что объект не удалось создать. Создание объекта прерывается, а деструктор при этом вызван не</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">будет. Это означает, что <b>конструктор должен самостоятельно выполнять освобождение ресурсов, захваченных к моменту генерации исключения</b>. В отличие от конструкторов, где генерация исключений может быть полезным</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">способом указать, что создать объект не удалось, <b>исключения никогда не должны генерироваться в деструкторах</b>.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Это связано с тем, что в процессе раскручивания стека вызываются деструкторы для объектов в автоматической памяти, и при генерации исключения в деструкторе создаётся неопределенность: продолжать ли процесс</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">раскручивания стека или обработать новое исключение. Конечным результатом будет немедленное прекращение выполнения программы. Если при разработке деструктора возникает желание сгенерировать исключение, то</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">очевидно надо искать ошибку проектирования класса и устранять ее.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s14" style=" background-color: #0F0;">Лекция 12 Отношения между классами. Классы контейнеры.</span></p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Наследование</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Наследование является базовым принципом ООП и позволяет одному классу (наследнику) унаследовать функционал другого класса (родительского). Нередко отношения наследования еще называют генерализацией или обобщением. Наследование определяет отношение IS A, то есть &quot;является&quot;.</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//базовый класс точка</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">x, y; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Point(<span style=" color: #00F;">int </span>x = 0, <span style=" color: #00F;">int </span>y = 0); <span style=" color: #00F;">void </span>SetX(<span style=" color: #00F;">int </span>value);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">SetY(</span>int <span style=" color: #000;">value); </span>int <span style=" color: #000;">GetX() </span>const<span style=" color: #000;">; </span>int <span style=" color: #000;">GetY() </span>const<span style=" color: #000;">; </span>void <span style=" color: #000;">Print() </span>const<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Point</span>::Point(<span style=" color: #00F;">int </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">y</span>): x(<span style=" color: #808080;">x</span>), y(<span style=" color: #808080;">y</span>) {} <span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetX(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {x = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::SetY(<span style=" color: #00F;">int </span><span style=" color: #808080;">value</span>) {y = <span style=" color: #808080;">value</span>;} <span style=" color: #00F;">int </span><span style=" color: #2B91AE;">Point</span>::GetX() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>x;}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #2B91AE;">Point</span><span style=" color: #000;">::GetY() </span>const <span style=" color: #000;">{</span>return <span style=" color: #000;">y;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">Point</span>::Print() <span style=" color: #00F;">const</span>{printf(<span style=" color: #A21515;">&quot;(%d, %d)\n&quot;</span>, x, y);} <span style=" color: #00F;">enum </span><span style=" color: #2B91AE;">Color</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s22" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Black <span style=" color: #000;">= 0x000000,</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">...</p><p class="s22" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">White <span style=" color: #000;">= 0xFFFFFF</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//класс-наследник цветная точка</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">CPoint </span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">Point</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Color </span>color; <span style=" color: #00F;">public</span>:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">CPoint(<span style=" color: #00F;">int </span>x = 0, <span style=" color: #00F;">int </span>y = 0, <span style=" color: #2B91AE;">Color </span>color = <span style=" color: #2E4F4F;">Black</span>); <span style=" color: #00F;">void </span>SetColor(<span style=" color: #2B91AE;">Color </span>value);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">Color </span>GetColor() <span style=" color: #00F;">const</span>; <span style=" color: #00F;">void </span>Print() <span style=" color: #00F;">const</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">CPoint</span>::CPoint(<span style=" color: #00F;">int </span><span style=" color: #808080;">x</span>, <span style=" color: #00F;">int </span><span style=" color: #808080;">y</span>, <span style=" color: #2B91AE;">Color </span><span style=" color: #808080;">color</span>) : <span style=" color: #2B91AE;">Point</span>(<span style=" color: #808080;">x</span>, <span style=" color: #808080;">y</span>), color(<span style=" color: #808080;">color</span>) {} <span style=" color: #00F;">void </span><span style=" color: #2B91AE;">CPoint</span>::SetColor(<span style=" color: #2B91AE;">Color </span><span style=" color: #808080;">value</span>) {color = <span style=" color: #808080;">value</span>;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #2B91AE;">Color CPoint</span>::GetColor() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>color;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span><span style=" color: #2B91AE;">CPoint</span>::Print() <span style=" color: #00F;">const</span>{printf(<span style=" color: #A21515;">&quot;(%d, %d) #%X\n&quot;</span>, x, y, color);}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">В данном классе класс объект класса «CPoint» также <b>является </b>и объектом класса «Point». Наследование является</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">самым сильным типом связи между двумя классами, которую невозможно разорвать во время исполнения, т.к. она определяется на этапе компиляции.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Ассоциация</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Ассоциация - это отношение, при котором объекты одного типа неким образом связаны с объектами другого типа. Например, объект одного типа содержит или использует объект другого типа. Агрегация и композиция являются</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">частными случаями ассоциации, и реализуют отношение HAS A, то есть отношение &quot;является частью&quot; и обычно выражаются в том, что один класс содержит объекты других классов в виде полей данных.</p><p class="s12" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Композиция</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В случае композиции целое явно контролирует время жизни своей составной части - часть не существует без целого. Рассмотрим пример:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Logger</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">FILE </span>*logfile; <span style=" color: #00F;">public</span>:</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Logger(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">filename</span>) : logfile(<span style=" color: #6E0089;">NULL</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">logfile = fopen(<span style=" color: #808080;">filename</span>, <span style=" color: #A21515;">&quot;w&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Message(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">text</span>) <span style=" color: #00F;">const</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if</span>(logfile) fprintf(logfile, <span style=" color: #A21515;">&quot;%s\n&quot;</span>, <span style=" color: #808080;">text</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Error(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">text</span>) <span style=" color: #00F;">const</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">if</span>(logfile) fprintf(logfile, <span style=" color: #A21515;">&quot;error: %s\n&quot;</span>, <span style=" color: #808080;">text</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">~Logger()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">if<span style=" color: #000;">(logfile) fclose(logfile);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Calculator</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Logger <span style=" color: #000;">logger; </span><span style=" color: #008000;">//композиция</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Calculator(<span style=" color: #00F;">const char </span>*<span style=" color: #808080;">logfilename</span>): logger(<span style=" color: #808080;">logfilename</span>){} <span style=" color: #00F;">void </span>Calculate(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">count</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">a, b;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">char <span style=" color: #000;">text[80];</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">logger.Message(<span style=" color: #A21515;">&quot;start calculation&quot;</span>); <span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">count</span>; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">a = rand() % 10;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">b = rand() % 10; <span style=" color: #00F;">if </span>(b == 0)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">sprintf(text, <span style=" color: #A21515;">&quot;%d/%d: division by zero&quot;</span>, a, b); logger.Error(text);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">continue<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">sprintf(text, <span style=" color: #A21515;">&quot;%d/%d=%.2lf&quot;</span>, a, b, (<span style=" color: #00F;">double</span>)a/b); logger.Message(text);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">logger.Message(<span style=" color: #A21515;">&quot;end calculation&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">srand((<span style=" color: #00F;">unsigned</span>)time(<span style=" color: #6E0089;">NULL</span>)); <span style=" color: #2B91AE;">Calculator </span>c(<span style=" color: #A21515;">&quot;d:\\log.txt&quot;</span>); c.Calculate(10);getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">В данном примере объект logger <b>является </b>неотъемлемой <b>частью </b>объекта класса Calculator – он создаётся в</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">конструкторе и уничтожается вместе с объектом класса Calculator. <b>Вне экземпляра класса Calculator объект logger не существует</b>.</p><p class="s12" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Агрегация</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В случае агрегации целое хоть и содержит свою составную часть, время их жизни не связано (например, составная часть передается через параметры конструктора). Модифицируем пример:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">Calculator</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">const <span style=" color: #2B91AE;">Logger </span><span style=" color: #000;">&amp;logger; </span><span style=" color: #008000;">//агрегация</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Calculator(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Logger </span>&amp;<span style=" color: #808080;">logger</span>): logger(<span style=" color: #808080;">logger</span>){} <span style=" color: #00F;">void </span>Calculate(<span style=" color: #00F;">unsigned </span><span style=" color: #808080;">count</span>) <span style=" color: #00F;">const</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">a, b;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">char <span style=" color: #000;">text[80];</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">logger.Message(<span style=" color: #A21515;">&quot;start calculation&quot;</span>); <span style=" color: #00F;">for </span>(<span style=" color: #00F;">int </span>i = 0; i &lt; <span style=" color: #808080;">count</span>; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">a = rand() % 10;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">b = rand() % 10; <span style=" color: #00F;">if </span>(b == 0)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">sprintf(text, <span style=" color: #A21515;">&quot;%d/%d: division by zero&quot;</span>, a, b); logger.Error(text);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">continue<span style=" color: #000;">;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">sprintf(text, <span style=" color: #A21515;">&quot;%d/%d=%.2lf&quot;</span>, a, b, (<span style=" color: #00F;">double</span>)a/b); logger.Message(text);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">logger.Message(<span style=" color: #A21515;">&quot;end calculation&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">srand((<span style=" color: #00F;">unsigned</span>)time(<span style=" color: #6E0089;">NULL</span>)); <span style=" color: #2B91AE;">Logger </span>log(<span style=" color: #A21515;">&quot;d:\\log.txt&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Calculator <span style=" color: #000;">c(log); c.Calculate(5);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Calculator <span style=" color: #000;">c(log);c.Calculate(7);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">log.Message(<span style=" color: #A21515;">&quot;Viva la libertad!&quot;</span>); getchar();</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">0;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В данном примере объект logger также <b>является частью </b>объекта класса Calculator, но, в отличии от предыдущего примера объект класса Calculator принимает в конструкторе ссылку на <b>уже существующий объект </b>класса Logger и использует его. Время жизни объекта log не зависит от времени жизни объекта класса Calculator - уничтожение объекта класса Calculator не приводит к уничтожению объекта log, т.к. они существуют отдельно друг от друга.</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Агрегация является менее сильным и более гибким типом отношений между классами. При агрегации можно</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">определить ссылку не на конкретный класс, а на интерфейсный и тогда при работе с классом Calculator можно будет обеспечить вывод сообщений как в файл, так и на экран, в отличии от композиции, где используется конкретный тип.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Для каждого типа отношений есть свои области применимости, но в целом можно сформулировать следующий</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">принцип: если наследование можно заменить композицией, то лучше использовать композицию, если композицию можно заменить агрегацией, то лучше использовать агрегацию.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Классы-контейнеры</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Контейнерный класс <span class="p">(или </span>класс-контейнер<span class="p">) — это класс, предназначенный для хранения и организации набора объектов определенного типа данных (пользовательских или базовых). Существует много разных классов-контейнеров, каждый из которых имеет свои преимущества, недостатки или ограничения в использовании.</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Безусловно, наиболее часто используемым контейнером в программировании является массив. Хотя в языке C++ есть стандартные обычные массивы, большинство программистов используют контейнерные классы-массивы: <b>std::array</b></p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">или <b>std::vector </b>из-за преимуществ, которые они предоставляют. В отличие от стандартных массивов, контейнерные классы-массивы имеют возможность динамического изменения своего размера, когда элементы добавляются или удаляются, что делает работу с ними более удобной и безопасной. Если рассматривать контейнер-массив, то можно выделить следующий базовый функционал:</p><ul id="l14"><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;line-height: 14pt;text-align: left;">Создание пустого контейнера.<span class="s23"></span><span class="s24"> </span>Добавление нового элемента в контейнер.</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;text-align: left;">Удаление элемента из контейнера.</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;text-align: left;">Просмотр количества элементов в контейнере.</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;line-height: 14pt;text-align: left;">Очистка контейнера.</p></li><li data-list-text=""><p style="padding-left: 15pt;text-indent: -7pt;line-height: 14pt;text-align: left;">Доступ к элементам в контейнере.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Рассмотренный выше функционал предоставляет только базовые операции, естественно он может быть расширен,</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">например, функциями сортировки, поиска элемента, вставки элемента в указанную позицию, заполнения контейнера указанным значением и т.д., в зависимости от задач. Если речь идет о хранении объектов, то можно выделить два</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">типа контейнерных классов:</p></li><li data-list-text=""><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Контейнеры значений — это композиции, которые хранят копии объектов и, следовательно, <b>обеспечивают создание и уничтожение этих копий</b>.</p></li><li data-list-text=""><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Контейнеры ссылок — это агрегации, которые хранят указатели или ссылки на другие объекты и, следовательно, <b>не должны отвечать за создание и уничтожение хранимых объектов</b>. Рассмотрим пример реализации простейшего класса-контейнера на основе динамического массива вещественных чисел</p></li></ul><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">Array</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">private<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">*data; </span>unsigned <span style=" color: #000;">size; </span>public<span style=" color: #000;">:</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//конструктор</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Array(): size(0), data(<span style=" color: #6E0089;">NULL</span>) {}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//конструктор копирования</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Array(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Array </span>&amp;<span style=" color: #808080;">a</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">size = <span style=" color: #808080;">a</span>.size;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = <span style=" color: #00F;">new double</span>[size]; <span style=" color: #00F;">for</span>(<span style=" color: #00F;">unsigned </span>i = 0; i&lt; size; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">data[i] = <span style=" color: #808080;">a</span>.data[i];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//деструктор</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">~Array()</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">delete<span style=" color: #000;">[] data;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//очистка</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">Clear()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">delete</span>[] data; data = <span style=" color: #6E0089;">NULL</span>; size = 0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//доступ к элементу по индексу константный метод только чтение</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">Element(</span>unsigned <span style=" color: #808080;">index</span><span style=" color: #000;">) </span>const</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">index </span>&gt;= size) <span style=" color: #00F;">throw </span><span style=" color: #A21515;">&quot;invalid index&quot;</span>; <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">index</span>];}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//доступ к элементу по индексу чтение/запись</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double<span style=" color: #000;">&amp; Element(</span>unsigned <span style=" color: #808080;">index</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">index </span>&gt;= size) <span style=" color: #00F;">throw </span><span style=" color: #A21515;">&quot;invalid index&quot;</span>; <span style=" color: #00F;">return </span>data[<span style=" color: #808080;">index</span>];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//добавление элемента в конец</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">Add(</span>const double <span style=" color: #808080;">value</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">*newdata = </span>new double<span style=" color: #000;">[size+1]; </span>for<span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i&lt; size; i++)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">newdata[i] = data[i];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">newdata[size] = <span style=" color: #808080;">value</span>; <span style=" color: #00F;">delete</span>[] data;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">data = newdata; size++;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//удаление элемента по индексу</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">Del(</span>unsigned <span style=" color: #808080;">index</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">index </span>&gt;= size) <span style=" color: #00F;">throw </span><span style=" color: #A21515;">&quot;invalid index&quot;</span>; <span style=" color: #00F;">if </span>(size == 1)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Clear(); <span style=" color: #00F;">return</span>;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">double </span>*newdata = <span style=" color: #00F;">new double</span>[size-1]; <span style=" color: #00F;">for</span>(<span style=" color: #00F;">unsigned </span>i = 0; i&lt; <span style=" color: #808080;">index</span>; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">newdata[i] = data[i];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for</span>(<span style=" color: #00F;">unsigned </span>i = <span style=" color: #808080;">index</span>+1; i&lt; size; i++)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">newdata[i-1] = data[i];</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">delete<span style=" color: #000;">[] data; data = newdata; size--;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//возврат размера</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unsigned <span style=" color: #000;">GetSize() </span>const <span style=" color: #000;">{</span>return <span style=" color: #000;">size;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>PrintArray(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">Array </span>&amp;<span style=" color: #808080;">a</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(<span style=" color: #808080;">a</span>.GetSize() == 0) printf(<span style=" color: #A21515;">&quot;Array is empty...&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">for </span>(<span style=" color: #00F;">unsigned </span>i = 0; i&lt; <span style=" color: #808080;">a</span>.GetSize(); i++) printf(<span style=" color: #A21515;">&quot;%lf &quot;</span>, <span style=" color: #808080;">a</span>.Element(i)); printf(<span style=" color: #A21515;">&quot;\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Array <span style=" color: #000;">a;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">for <span style=" color: #000;">(</span>unsigned <span style=" color: #000;">i = 0; i&lt; 10; i++) a.Add((</span>double<span style=" color: #000;">)i/(i+1)); PrintArray(a);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">a.Del(5);PrintArray(a); a.Del(7); PrintArray(a); a.Del(0); PrintArray(a); a.Clear(); PrintArray(a); a.Add(1);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">a.Add(2);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">a.Add(3); PrintArray(a); getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В данном примере мы рассмотрели достаточно «наивный» подход к управлению размером   хранилища: при каждой операции добавления хранилище увеличивается на один элемент, при удалении соответственно уменьшается, такое частое выделение памяти и копирование её содержимого достаточно затратный подход. В</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">действительности при необходимости увеличения размера контейнера (в случае с массивами) обычно используют</p><h3 style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">ступенчатое приращение <span class="p">- сразу на несколько элементов. При уменьшении, например, при удалении элемента -фактический размер хранилища не изменяется, уменьшается (очищается) хранилище только при вызове метода очистки. Такой подход используют для оптимизации работы с памятью - нет необходимости в частом выделении памяти и копировании данных. В таком случае требуется хранить как фактический размер хранилища данных -</span>capacity<span class="p">, так и используемый - </span>size<span class="p">. Несмотря на некоторое усложнение такой подход позволяет значительно</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">сократить описанные выше издержки. Действительно, если приращение производится сразу на 32 элемента, то после его выполнения ближайшие 32 операции добавления элемента в конец массива реализуются</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">следующим оператором data[size++] = value, не требуя выделения памяти и копирования данных.</p><p style="padding-top: 9pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s14" style=" background-color: #0F0;">Лекция 13 Преобразование типов данных</span></p><p style="padding-top: 9pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">Разные типы данных могут представлять одно значение по-разному, например, значение 4 типа int и значение 4.0 типа float имеют совершенно разные двоичные представления. Процесс конвертации значений из одного типа данных в другой называется <b>преобразованием типов</b>. Преобразование типов может выполняться в следующих</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">случаях:</p><ol id="l15"><li data-list-text="1."><h3 style="padding-left: 18pt;text-indent: -11pt;line-height: 13pt;text-align: left;">Присваивание или инициализация переменной значением другого типа данных:</h3><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">k(4); </span><span style=" color: #008000;">// инициализация переменной типа double целым числом 4</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">k = 7; <span style=" color: #008000;">// присваиваем переменной типа double целое число 7</span></p></li><li data-list-text="2."><h3 style="padding-left: 18pt;text-indent: -11pt;line-height: 13pt;text-align: left;">Передача значения в функцию, где тип параметра отличается от указанного в описании:</h3><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">void <span style=" color: #000;">doSomething(</span>long <span style=" color: #000;">l)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">doSomething(4); <span style=" color: #008000;">// передача числа 4 (тип int) в функцию с параметром типа long</span></p></li><li data-list-text="3."><h3 style="padding-left: 18pt;text-indent: -11pt;line-height: 13pt;text-align: left;">Возврат из функции значения отличающегося по типу данных от типа возврата указанного в описании:</h3><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">float <span style=" color: #000;">doSomething()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return <span style=" color: #000;">4.0; </span><span style=" color: #008000;">// передача значения 4.0 (тип double) из функции, которая возвращает</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">float</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p></li><li data-list-text="4."><h3 style="padding-left: 18pt;text-indent: -11pt;text-align: left;">Использование бинарного оператора с операндами разных типов:</h3><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">result = 5.0 / 4; </span><span style=" color: #008000;">// операция деления со значениями типов double и int</span></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Во всех указанных случаях используется преобразование типов. Выделяют два способа преобразования типов:</p><ul id="l16"><li data-list-text=""><h3 style="padding-left: 15pt;text-indent: -7pt;text-align: left;">Неявное преобразование типов<span class="p">, когда компилятор автоматически конвертирует один тип данных в другой.</span></h3></li><li data-list-text=""><h3 style="padding-left: 15pt;text-indent: -7pt;text-align: left;">Явное преобразование типов<span class="p">, когда разработчик использует один из операторов явного преобразования для</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">выполнения конвертации объекта из одного типа данных в другой. При наследовании также говорят о направлении преобразования:</p></li><li data-list-text=""><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Повышающее преобразование <span class="p">(upcasting) — это преобразование от типа порожденного класса (от подкласса) к базовому (суперклассу). Такое преобразование допустимо всегда. На него нет никаких ограничений и для его</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">проведения не требуется применять никаких дополнительных синтаксических конструкций. Это связано с тем, что объект подкласса всегда в себе содержит как свою часть объект суперкласса.</p></li><li data-list-text=""><h3 style="padding-left: 15pt;text-indent: -7pt;text-align: left;">Понижающее преобразование <span class="p">(downcasting) — это преобразование от суперкласса к подклассу. Такое</span></h3><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">преобразование имеет ряд ограничений. Во-первых, оно может задаваться только явно при помощи операции преобразования типов. Во-вторых, объект, подвергаемый преобразованию, реально должен быть того класса, к которому он преобразуется.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Неявное преобразование типов</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Для фундаментальных типов данных используется два типа неявного преобразования:</p></li><li data-list-text=""><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Числовое расширение<span class="p">, когда значение из одного типа данных конвертируется в другой тип данных больший (по размеру и по диапазону значений). Например, тип char может быть расширен в тип int, тип int может быть расширен в тип long, а тип float может быть расширен в тип double;</span></h3></li><li data-list-text=""><h3 style="padding-left: 15pt;text-indent: -7pt;line-height: 14pt;text-align: left;">Числовая конверсия<span class="p">, когда значение одного типа данных преобразуется в другой – меньший по размеру и</span></h3></li></ul></li></ol><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">диапазону значений. например преобразование значения типа int в значение типа short. В отличие от расширений, которые всегда безопасны, конверсии могут (но не всегда) привести к потере данных. Поэтому в любой программе, где выполняется неявная конверсия, компилятор будет выдавать предупреждение. Для объектных типов данных</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">неявно допускается выполнять <b>только повышающее </b>преобразование. Рассмотрим неявные преобразования на примере:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">void </span>Print() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;A::print()\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">B </span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>Print() <span style=" color: #00F;">const </span>{printf(<span style=" color: #A21515;">&quot;B::print()\n&quot;</span>);}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">void <span style=" color: #000;">PrintShort(</span>const short <span style=" color: #808080;">a</span><span style=" color: #000;">)</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, <span style=" color: #808080;">a</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>PrintA(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">A </span>&amp;<span style=" color: #808080;">a</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><ol id="l17"><li data-list-text="a."><p class="s4" style="padding-left: 18pt;text-indent: -10pt;text-align: left;">Print();</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span style=" color: #00F;">void </span>PrintB(<span style=" color: #00F;">const </span><span style=" color: #2B91AE;">B </span>&amp;<span style=" color: #808080;">b</span>)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p></li><li data-list-text="b."><p class="s4" style="padding-left: 18pt;text-indent: -10pt;text-align: left;">Print();</p></li></ol><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">char <span style=" color: #000;">c = 5;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">PrintShort(c); <span style=" color: #008000;">//расширение</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">i = 65537;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">PrintShort(i); <span style=" color: #008000;">//конверсия (потеря данных)</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A <span style=" color: #000;">a;</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">B <span style=" color: #000;">b; PrintA(a);</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">PrintA(b); <span style=" color: #008000;">//повышающее преобразование</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">PrintB(a); <span style=" color: #008000;">//Ошибка компиляции: PrintB: невозможно преобразовать параметр 1 из &quot;A&quot; в &quot;const B &amp;&quot;. Что бы это сработало понадобится явное понижающее преобразование.</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">PrintB(b); getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">}<span class="p">Как видно по выводу конверсия в строке PrintShort(i) привела к потере данных. Вызов PrintB(a) пришлось</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">закомментировать, т.к. в этом случае требуется выполнить выполнять понижающее преобразование, которое производится <b>только явным образом</b>. А вызов PrintA(a) и PrintA(b) привели к выводу одной и той-же строки</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">«A::print()», <b>объясните почему</b>.</p><p class="s2" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Явное преобразование типов</p><p class="s12" style="padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Преобразование типов в стиле языка C (C-style cast)</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Приведение типов в стиле языка C может привести выражение любого типа к любому другому типу данных</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">(исключение это приведение пользовательских типов по значению, если не определены правила их приведения, а также приведение вещественного типа к указателю или наоборот). К примеру, unsigned int может быть преобразован к указателю на double. Данный метод приведения типов может быть использован в языке C++. Синтаксис:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">(&lt;тип&gt;) &lt;выражение&gt;</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">где &lt;тип&gt; – новый тип, к которому приводим, а &lt;выражение&gt; – выражение, которое приводится к новому типу. Т.к. данный оператор не имеет зарезервированного ключевого слова найти все места приведения типов в тексте программы будет не очень удобно, если это потребуется. Метод приведения типов в стиле языка C не выполняет</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">проверки типов на совместимость, как это могут сделать рассматриваемые далее операторы приведения static_cast и dynamic_cast на этапе</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">компиляции и на этапе выполнения соответственно, поэтому преобразование типов таким образом потенциально небезопасно и лучше его не использовать.</p><p class="s12" style="padding-left: 7pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Оператор приведения типов static_cast</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Оператор приведения static_cast применяется для неполиморфного приведения типов на этапе компиляции</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">программы. Отличие static_cast от приведения типов в стиле языка C состоит в том, что данный оператор приведения может отслеживать недопустимые преобразования, такие как приведение указателя к значению или наоборот, а также приведение указателей и ссылок разных типов считается корректным только, если это приведение вверх или</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">вниз по одной иерархии наследования классов, либо это указатель на void. В случае фиксации отклонения от данных ограничений будет выдана ошибка при компиляции программы. Синтаксис:</p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">static_cast<b>&lt;</b>&lt;тип&gt;<b>&gt;</b>(&lt;выражение&gt;)</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">где &lt;тип&gt; – новый тип, к которому приводим, а &lt;выражение&gt; – выражение, которое приводится к новому типу.</p><p class="s12" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Оператор приведения типов <span class="s25">dynamic_cast</span></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Оператор приведения dynamic_cast применяется для полиморфного приведения типов на этапе выполнения</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">программы (класс считается полиморфным, если в нем есть хотя бы одна виртуальная функция). Если указатель, подлежащий приведению, ссылается на объект результирующего класса или объект класса производный от</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">результирующего то приведение считается успешным. То же самое для ссылок. Если приведение невозможно, то на этапе выполнения программы будет возвращен NULL, если приводятся указатели. Если приведение производится над ссылками, то будет сгенерировано исключение std::bad_cast. Несмотря на то, что dynamic_cast предназначен для</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">приведения полиморфных типов по иерархии наследования, он может быть использован и для обычных</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">неполиморфных типов вверх по иерахии. В этом случае ошибка будет получена на этапе компиляции. Оператор</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">приведения dynamic_cast может приводить к указателю на void, но не может приводить указатель на void к другому типу. Способность dynamic_cast приводить полиморфные типы обеспечивается системой RTTI (Run-Time Type</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Identification), которая позволяет идентифицировать тип объекта в процессе выполнения программы. <span class="s26">Общий вид приведения:</span></p><p class="s9" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">dynamic_cast <b>&lt;</b>&lt;тип&gt;<b>&gt;</b>(&lt;выражение&gt;)</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">где &lt;тип&gt; – новый тип, к которому приводим, а &lt;выражение&gt; – выражение, которое приводится к новому типу. Рассмотрим разницу на примерах:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">id; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">A(<span style=" color: #00F;">int </span><span style=" color: #808080;">id</span>): id(<span style=" color: #808080;">id</span>) {}</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">virtual int <span style=" color: #000;">GetId() </span>const <span style=" color: #000;">{</span>return <span style=" color: #000;">id;}</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">B </span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">protected<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">double <span style=" color: #000;">value; </span>public<span style=" color: #000;">:</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">B(<span style=" color: #00F;">int </span><span style=" color: #808080;">id</span>, <span style=" color: #00F;">double </span><span style=" color: #808080;">value</span>): <span style=" color: #2B91AE;">A</span>(<span style=" color: #808080;">id</span>), value(<span style=" color: #808080;">value</span>) {} <span style=" color: #00F;">double </span>GetValue() <span style=" color: #00F;">const </span>{<span style=" color: #00F;">return </span>value;}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">A <span style=" color: #000;">*a = </span><span style=" color: #00F;">new </span>B<span style=" color: #000;">(1, 0.5);</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">//хотим распечатать value, что делать?</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">B <span style=" color: #000;">*b;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">b = (<span style=" color: #2B91AE;">B</span>*)a;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;The value is: %.2lf\n&quot;</span>, b-&gt;GetValue()); b = <span style=" color: #00F;">static_cast</span>&lt;<span style=" color: #2B91AE;">B</span>*&gt;(a);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;The value is: %.2lf\n&quot;</span>, b-&gt;GetValue()); b = <span style=" color: #00F;">dynamic_cast</span>&lt;<span style=" color: #2B91AE;">B</span>*&gt;(a);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;The value is: %.2lf\n&quot;</span>, b-&gt;GetValue()); <span style=" color: #00F;">delete </span>b;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}<span class="p">Как видим разницы не заметно, результат всех трёх вариантов преобразования типов отработал корректно. Теперь рассмотрим случай, когда объект будет иметь фактический тип класса-предка:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">srand((<span style=" color: #00F;">unsigned</span>)time(<span style=" color: #6E0089;">NULL</span>)); <span style=" color: #2B91AE;">A </span>*a = <span style=" color: #00F;">new </span><span style=" color: #2B91AE;">A</span>(1);</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//хотим распечатать value, что делать?</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">B <span style=" color: #000;">*b;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">b = (<span style=" color: #2B91AE;">B</span>*)a;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;The value is: %.2lf\n&quot;</span>, b-&gt;GetValue());</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">b = <span style=" color: #00F;">static_cast</span>&lt;<span style=" color: #2B91AE;">B</span>*&gt;(a);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;The value is: %.2lf\n&quot;</span>, b-&gt;GetValue()); b = <span style=" color: #00F;">dynamic_cast</span>&lt;<span style=" color: #2B91AE;">B</span>*&gt;(a);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;The value is: %.2lf\n&quot;</span>, b-&gt;GetValue()); <span style=" color: #00F;">delete </span>b;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">В этом случае два первых варианта отработали и программа вывела какие-то некорректные данные, а вот</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">преобразование через dynamic_cast не сработало – программа завершилась с ошибкой. Если быть точнее, то</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">преобразование сработало – ошибка возникла в строке printf(&quot;The value is: %.2lf\n&quot;, b-&gt;GetValue()), т.к. результатом dynamic_cast в этом случае был</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">нулевой указатель и ошибка была вызвана попыткой разыменования нулевого указателя при обращении к методу GetValue. В этой связи желательно производить проверку результата динамического преобразования на нулевой указатель:<span class="s3">int </span><span class="s4">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A <span style=" color: #000;">*a = </span><span style=" color: #00F;">new </span>A<span style=" color: #000;">(1);</span></p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">//хотим распечатать value, что делать?</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">B <span style=" color: #000;">*b;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">b = (<span style=" color: #2B91AE;">B</span>*)a;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(b != <span style=" color: #6E0089;">NULL</span>) printf(<span style=" color: #A21515;">&quot;The value is: %.2lf\n&quot;</span>, b-&gt;GetValue()); <span style=" color: #00F;">else </span>printf(<span style=" color: #A21515;">&quot;Incorrect object type\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">b = <span style=" color: #00F;">static_cast</span>&lt;<span style=" color: #2B91AE;">B</span>*&gt;(a);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(b != <span style=" color: #6E0089;">NULL</span>) printf(<span style=" color: #A21515;">&quot;The value is: %.2lf\n&quot;</span>, b-&gt;GetValue()); <span style=" color: #00F;">else </span>printf(<span style=" color: #A21515;">&quot;Incorrect object type\n&quot;</span>);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">b = <span style=" color: #00F;">dynamic_cast</span>&lt;<span style=" color: #2B91AE;">B</span>*&gt;(a);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">if </span>(b != <span style=" color: #6E0089;">NULL</span>) printf(<span style=" color: #A21515;">&quot;The value is: %.2lf\n&quot;</span>, b-&gt;GetValue()); <span style=" color: #00F;">else </span>printf(<span style=" color: #A21515;">&quot;Incorrect object type\n&quot;</span>);</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">delete <span style=" color: #000;">b; getchar(); </span>return <span style=" color: #000;">0;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Как видим такой подход работает только с использованием оператора dynamic_cast, C-style конвертация и оператор преобразования static_cast вернули ненулевые указатели. Хотя во всех примерах, приведенных выше, мы</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">использовали динамическое приведение с указателями (что является наиболее распространенным вариантом), оператор dynamic_cast также может использоваться и со ссылками. Работа dynamic_cast со ссылками аналогична работе с указателями, однако, поскольку в языке C++ не существует «нулевой ссылки» - ссылки всегда</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">инициализированы, то при недопустимом преобразовании dynamic_cast генерирует исключение типа <b>std::bad_cast</b>.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Рассмотрим пример работы со ссылками для тех же классов:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">B <span style=" color: #000;">obj = </span>B<span style=" color: #000;">(1, 0.5);</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">A <span style=" color: #000;">&amp;a = obj; </span><span style=" color: #00F;">try</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">B </span>&amp;b = <span style=" color: #00F;">dynamic_cast</span>&lt;<span style=" color: #2B91AE;">B</span>&amp;&gt;(a);</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;The value is: %.2lf\n&quot;</span>, b.GetValue());</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">catch</span>(std::<span style=" color: #2B91AE;">exception </span>&amp;exception)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%s\n&quot;</span>, exception.what());</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">}<span class="p">В этом случае преобразование типа корректно, т.к. фактический тип obj это B – исключения не будет.</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">A <span style=" color: #000;">obj = </span>A<span style=" color: #000;">(1); </span>A <span style=" color: #000;">&amp;a = obj; </span><span style=" color: #00F;">try</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #2B91AE;">B </span>&amp;b = <span style=" color: #00F;">dynamic_cast</span>&lt;<span style=" color: #2B91AE;">B</span>&amp;&gt;(a);</p><p class="s4" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;The value is: %.2lf\n&quot;</span>, b.GetValue());</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span style=" color: #00F;">catch</span>(std::<span style=" color: #2B91AE;">exception </span>&amp;exception)</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%s\n&quot;</span>, exception.what());</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">}</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">getchar(); <span style=" color: #00F;">return </span>0;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В этом случае преобразование типа не будет корректным, т.к. фактический тип obj это А – выводится сообщение об ошибке.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Рассмотрим пример, иллюстрирующий различия static_cast и C-style преобразования:</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">short int <span style=" color: #000;">a;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">class <span style=" color: #2B91AE;">AA</span><span style=" color: #000;">: </span>public <span style=" color: #2B91AE;">A</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">double <span style=" color: #000;">aa;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">class <span style=" color: #2B91AE;">B</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">char <span style=" color: #000;">b;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">};<span style=" color: #00F;">class </span><span style=" color: #2B91AE;">BB</span>: <span style=" color: #00F;">public </span><span style=" color: #2B91AE;">B</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">{</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">public<span style=" color: #000;">:</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">char <span style=" color: #000;">bb;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">};</p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">int <span style=" color: #000;">main()</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">{</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A<span style=" color: #000;">* pa = </span><span style=" color: #00F;">new </span>A<span style=" color: #000;">();</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">pa-&gt;a = 777; <span style=" color: #008000;">//это 00001001 00000011 с учетом порядка байт little endian</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">BB <span style=" color: #000;">*pb;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">pb = (<span style=" color: #2B91AE;">BB</span>*)pa;</p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, pb-&gt;b); <span style=" color: #008000;">//9 это 00001001</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">printf(<span style=" color: #A21515;">&quot;%d\n&quot;</span>, pb-&gt;bb); <span style=" color: #008000;">//3 это 00000011</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">pb = <span style=" color: #00F;">static_cast</span>&lt;<span style=" color: #2B91AE;">BB</span>*&gt;(pa); <span style=" color: #008000;">// static_cast: невозможно преобразовать &quot;A *&quot; в &quot;BB *&quot;</span></p><p class="s3" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">delete <span style=" color: #000;">pa; getchar(); </span>return <span style=" color: #000;">0;</span></p><p class="s4" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;">}</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В данном примере C-style конвертация позволила нам преобразовать указатель на экземпляр класса A к указателю на экземпляр класса BB - совершенно не связанного с классом A, и даже получилось прочитать значения полей данных b и bb по этому указателю. Фактически C-style конвертация выполняет реинтерпретацию (см. иллюстрацию) некоторой области памяти со всеми вытекающими проблемами (возможна некорректная интерпретация памяти или доступ к</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">«чужим» областям памяти).</p><h3 style="padding-left: 7pt;text-indent: 0pt;text-align: left;">До преобразования типа:</h3><p class="s27" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">... 00001001</p><p class="s27" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">00000011</p><p class="s27" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">...</p><h3 style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">После преобразования типа:</h3><p class="s27" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">... 00001001</p><p class="s27" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">00000011</p><p class="s27" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">...</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В то же время с использованием static_cast такое некорректное преобразование выполнить не удалось, что с точки зрения безопасности кода более предпочтительно.</p><p class="s28" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">pa-&gt;a pa pb-&gt;b pb</p><p class="s28" style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">pb-&gt;bb<span class="s2">Заключение</span></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Так как C-style конвертация не контролирует допустимость преобразования. что потенциально чревато ошибками, то вместо неё рекомендуется использовать оператор преобразования static_cast. Оператор dynamic_cast следует</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">использовать при необходимости выполнения понижающего преобразования типов, во всех остальных случаях следует использовать оператор</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">static_cast. При этом следует помнить, что во многих случаях грамотное использование виртуальных функций</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">позволяет избежать применения понижающего преобразования. Понижающее преобразование также может быть выполнено и с помощью оператора static_cast, но этот оператор не выполняет проверку фактического типа объекта и соответственно</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">допустимость преобразования. Это позволяет оператору static_cast быть быстрее, но потенциально опаснее</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">оператора dynamic_cast. Если вы будете конвертировать Parent* в Child*, то операция будет «успешной», даже если указатель класса Parent не будет указывать на объект класса Child. А проблемы могут возникнуть, когда попытаетесь получить доступ к этому указателю (который после конвертации должен быть класса Child, но, фактически, указывает на объект класса Parent).</p><h1 style="padding-top: 4pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">Список вопросов для подготовки к экзамену по дисциплине</h1><h1 style="padding-left: 7pt;text-indent: 0pt;line-height: 16pt;text-align: left;">«Объектно-ориентированное программирование»</h1><ol id="l18"><li data-list-text="1."><p style="padding-left: 18pt;text-indent: -10pt;line-height: 13pt;text-align: left;">Задание параметров функции по умолчанию.</p></li><li data-list-text="2."><p style="padding-left: 18pt;text-indent: -10pt;text-align: left;">Перегрузка функций.</p></li><li data-list-text="3."><p style="padding-left: 18pt;text-indent: -10pt;text-align: left;">Работа с динамической памятью в C++.</p></li><li data-list-text="4."><p style="padding-left: 18pt;text-indent: -10pt;text-align: left;">Ссылки.</p></li><li data-list-text="5."><p style="padding-left: 18pt;text-indent: -10pt;text-align: left;">Основные понятия ООП (ООП, класс, поле, метод, объект, интерфейс)</p></li><li data-list-text="6."><p style="padding-left: 18pt;text-indent: -10pt;text-align: left;">Основные принципы ООП (абстракция, инкапсуляция, полиморфизм, наследование).</p></li><li data-list-text="7."><p style="padding-left: 18pt;text-indent: -10pt;line-height: 13pt;text-align: left;">Синтаксис описания классов и объектов.</p></li><li data-list-text="8."><p style="padding-left: 18pt;text-indent: -10pt;line-height: 13pt;text-align: left;">Спецификаторы доступа.</p></li><li data-list-text="9."><p style="padding-left: 18pt;text-indent: -10pt;text-align: left;">Плюсы инкапсуляции.</p></li><li data-list-text="10."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Функции доступа, указатель this.</p></li><li data-list-text="11."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Конструкторы.</p></li><li data-list-text="12."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Конструктор по умолчанию.</p></li><li data-list-text="13."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Параметрический конструктор.</p></li><li data-list-text="14."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Конструктор копирования.</p></li><li data-list-text="15."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Деструкторы.</p></li><li data-list-text="16."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Список инициализации.</p></li><li data-list-text="17."><p style="padding-left: 24pt;text-indent: -16pt;line-height: 13pt;text-align: left;">Константные объекты.</p></li><li data-list-text="18."><p style="padding-left: 24pt;text-indent: -16pt;line-height: 13pt;text-align: left;">Константные ссылки на объекты.</p></li><li data-list-text="19."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Константные методы классов.</p></li><li data-list-text="20."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Раздельное объявление и определение классов.</p></li><li data-list-text="21."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Статические поля.</p></li><li data-list-text="22."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Статические методы.</p></li><li data-list-text="23."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Дружественные функции и методы.</p></li><li data-list-text="24."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Дружественные классы.</p></li><li data-list-text="25."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Наследование, правила наследования.</p></li><li data-list-text="26."><p style="padding-left: 24pt;text-indent: -16pt;line-height: 13pt;text-align: left;">Одиночное наследование, атрибуты наследования.</p></li><li data-list-text="27."><p style="padding-left: 24pt;text-indent: -16pt;line-height: 13pt;text-align: left;">Совместимость типов при наследовании.</p></li><li data-list-text="28."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Виртуальные методы.</p></li><li data-list-text="29."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Виртуальные деструкторы.</p></li><li data-list-text="30."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Чисто виртуальные функции и абстрактные классы.</p></li><li data-list-text="31."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Множественное наследование.</p></li><li data-list-text="32."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Проблемы множественного наследования.</p></li><li data-list-text="33."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Виртуальное наследование.</p></li><li data-list-text="34."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Интерфейсы и множественное наследование.</p></li><li data-list-text="35."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Классические способы оповещения вызывающей стороны об ошибках и их недостатки.</p></li><li data-list-text="36."><p style="padding-left: 24pt;text-indent: -16pt;line-height: 13pt;text-align: left;">Генерация и обработка исключений.</p></li><li data-list-text="37."><p style="padding-left: 24pt;text-indent: -16pt;line-height: 13pt;text-align: left;">Классы исключений.</p></li><li data-list-text="38."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Обработка классов-исключений.</p></li><li data-list-text="39."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Базовый класс исключений std::exception.</p></li><li data-list-text="40."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Повторная генерация исключений.</p></li><li data-list-text="41."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Генерация исключений в конструкторах и деструкторах.42. Отношения между классами.</p></li></ol><ol id="l19"><li data-list-text="43."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Классы-контейнеры.</p></li><li data-list-text="44."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Преобразование типов данных общие сведения.</p></li><li data-list-text="45."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Неявное преобразование типов.</p></li><li data-list-text="46."><p style="padding-left: 24pt;text-indent: -16pt;text-align: left;">Явное преобразование типов.</p></li></ol><ol id="l20"><li data-list-text="1."><p style="padding-top: 1pt;padding-left: 17pt;text-indent: -9pt;text-align: left;"><span class="h2" style=" background-color: #F00;">Взаимоотношения Руси и Орды.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: justify;">При изучении вопроса о взаимоотношении Руси и Орды необходимо отметить, что смертельную опасность для Руси представляли не монголы, а «латинский мир». С начала XIII в. «начался великий натиск на восток»,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Единственным союзником для Северо-Восточной Руси могли быть монголо-татары. Союз Руси с Ордой стал третьей (после разгрома шведов и немцев ) победой святого благоверного великого князя Александра Невского – победой геополитической!</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p style="padding-top: 2pt;padding-left: 16pt;text-indent: -8pt;text-align: left;"><span class="s29" style=" background-color: #F00;">Причины возвышения Московского княжества и основные этапы складывания Русского государства.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s30" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Причины возвышения Москвы:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l21"><li data-list-text="1."><p class="s31" style="padding-left: 16pt;text-indent: -8pt;text-align: left;">Удачное географическое положение. Прикрытость русскими княжествами с Юга и с Северо-Запада.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s31" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Затрудненность проникновения татар, а следовательно приток населения и превращения в крупный ремесленный центр Северо-Востока.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s31" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Тонкая осторожная, дальновидная политика московских князей, привлекающих на свою сторону горожан, мелких и средних феодалов, а главное церковь.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s31" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Включения в свой состав мелких княжеств (добровольное вхождение, бездетность феодалов, покупка территорий и прямые захваты).</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5."><p class="s31" style="padding-left: 17pt;text-indent: -9pt;text-align: left;">Успешная политика московских князей, направленная на расширение территорий своего княжества.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="6."><p class="s31" style="padding-left: 18pt;text-indent: -10pt;text-align: left;">Москва получила поддержу от церкви.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="7."><p class="s31" style="padding-left: 17pt;text-indent: -9pt;text-align: left;">Княжества достаточно густо населено.</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s30" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Этапы складывания Московского государства:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l22"><li data-list-text="1"><p class="s30" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">этап: конец 13- начало 14 века. На 1 этапе наблюдается рост московского княжества.  К Москве присоединяются Коломна, Можайск, Переяславль. В 1327 в Твери вспыхивают восстания против баскака Чилхана, в подавлении восстания принимает участие И. Калита.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2"><p class="s30" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">этап: вторая половина 14 века. В 1380 году Д. Донской собирает огромное войско со всех русских земель против «Золотой Орды». 8 сентября 1380 года состоялась Куликовская битва против Золотой Орды. Войско Донского одержало победу. После Куликовской битвы в 1382 году Хан Тохтамыш совершает поход на Русь, он сжигает Москву.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3"><p class="s30" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">этап: первая половина 15 века. Главным событием стала война 1425-1453 года. Война была между московским князем Василием Темным и коалицией удельных князей. В этой войне одерживает победу московский князь.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4"><p class="s30" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">этап: вторая половина 15 века – начало 16 века. Идет этап завершения объединения русских земель вокруг Москвы, во время правления Ивана 3 и Василия 3 (1462-1505). В 1478 году к Москве был присоединен Новгород. Во время правления Ивана 3 было покончено с ордынским игом в 1480 году. Происходит</p></li></ol><p class="s30" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">формирование великой державы, с середины 16 века которая именовалась Россией.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p style="padding-top: 2pt;padding-left: 16pt;text-indent: -8pt;text-align: left;"><span class="s29" style=" background-color: #F00;">Иосифляне и нестяжатели.</span></p></li></ol><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">В самой Русской Православной Церкви . Здесь столкнулись две правды: правда иосифлян и правда нестяжателей.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">Иосиф Волоцкий призвание Церкви видел в социальном служении народу. Его идеал – хождение в народ, у которого и нравственные устои недостаточно крепки, и тяготы жизни сверх сил. По его мнению, Церковь должна помогать вдовам, сиротам, бездомным и нищим. В его монастыре кормили бедных, давали приют бездомным и</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">странствующим, раздавали милостыню нищим.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">Правда нестяжателей состояла в духовном и нравственном служении христианской личности, в преодолении мирских пристрастий, в монашеском исходе. Именно в этом видели они призвание Церкви. Но раз так, то Церкви не нужны</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">богатства. Нет богатства – следовательно, и не за что потакать князю: он подзаконен Богу и только в пределах Закона Божия и заповедей обладает своей властью, а «неправедному» и строптивому царю вовсе не подобает повиноваться, так как «такой царь – не Божий слуга, но дьявол, и не царь, а мучитель». В отношении еретиков Нил Сорский</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">призывал проводить политику не казней, а убеждения и перевоспитания: «Бог хочет не смерти грешника, но его раскаяния». Как крайнюю меру заволжские старцы предлагали высылать еретиков из страны.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Победа иосифлян во многом определила последующую историю России. Церковь, где верх взяли потакатели, не</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">смогла противостоять опричнине Ивана Грозного – антисистеме, нанёсшей сокрушительный удар и по политической системе Русского государства, и по самой Русской Православной Церкви, и по нравственности русского народа.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s32" style=" background-color: #F00;">Т</span><span class="h4" style=" background-color: #F00;">ЕМА </span><span class="s32" style=" background-color: #F00;">2. Р</span><span class="h4" style=" background-color: #F00;">ОССИЯ В </span><span class="s32" style=" background-color: #F00;">XVII </span><span class="h4" style=" background-color: #F00;">В</span><span class="s32" style=" background-color: #F00;">.</span></p><p style="padding-top: 7pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s32" style=" background-color: #F00;">Вопросы семинарского занятия</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l23"><li data-list-text="1."><p style="padding-top: 4pt;padding-left: 23pt;text-indent: -15pt;text-align: left;"><span class="s33" style=" background-color: #F00;">Основные тенденции политического развития России в XVII в.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">При ответе на первый вопрос необходимо иметь четкое представление, что красной нитью через весь XVII в. проходит тенденция трансформации сословно-представительной монархии в абсолютную.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">судьба главного сословно-представительного органа Русского государства – Земского Собора.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">В1613 г. именно Земский Собор избрал Михаила Фёдоровича Романова на престол. В состав Земских соборов входили выборные представители практически всех сословий – самая уважаемая и лучшая часть населения. В первые годы царствования Михаила Фёдоровича соборы действовали практически постоянно и решали все насущные</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">вопросы: внутриполитические, хозяйственные, военные, дипломатические. Затем, когда внутриполитическая</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">ситуация в стране стабилизировалась, был наведён относительный порядок, надобность в Земских соборах отпала и их функции перешли к приказам. в 1649 г., когда принималось Соборное Уложение, так было и в 1653 г., когда</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">решался вопрос о присоединении к России Малороссии (Украины). Даже вступление на престол Алексея</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Михайловича Романова в 1645 г. было оформлено как его избрание на царство Земским собором. После 1653 г. Земские Соборы не созываются. Но память о них ещё живёт в народе.</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Наряду с умалением роли Земских соборов падает и значение Боярской Думы. Царь учредил приказ Тайных дел (не позже 1658 г.), во главе которого стоял особый дьяк, подчиняющийся лично государю. Ни бояре, ни думные люди не</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">имели к этому приказу никакого доступа и отношения. Подьячие приказа Тайных дел следили за воеводами, послами и доносили обо всём лично Алексею Михайловичу. Если царю требовалось провести какое-либо решение в обход Боярской Думы, то он делал это через приказ Тайных дел.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Об абсолютистских устремлениях первых Романовых свидетельствует и добавление в пышный царский титул слова</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">«самодержец». Да</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">ицерковный раскол необходимо рассматривать не столько в контексте конфликта «старого» и «нового» обрядов, сколько в контексте вопроса о взаимоотношении «Священства» и «Царства».</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p style="padding-top: 4pt;padding-left: 23pt;text-indent: -15pt;text-align: left;"><span class="s33" style=" background-color: #F00;">Церковный раскол.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">При подведении итогов обсуждения темы раскола бакалавры должны прийти к выводу, что в ходе церковной реформы чётко обозначились три основные позиции.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l24"><li data-list-text="1."><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Протопоп Аввакум и его сторонники отстаивали превосходство местного варианта православия, сложившегося в Северо-Восточной Руси в XIV в., над традицией вселенского (греческого) православия. Эта позиция была платформой для узкого московского национализма и соответствовала идеологии «Москва – третий Рим». Такая позиция вела к</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">изоляции России и не могла удовлетворить ни царя, ни патриарха.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Патриарх Никон мечтал о вселенской теократической монархии, вкоторой «Священство» стоит над «Царством». Для Никона главным в реформе было унифицировать православные обряды и церемонии, при этом за образец брались</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">греческие обряды, а весь старорусский чин и обряд огульно отрицался, объявлялся ложным, почти нечестивым.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Царь Алексей Михайлович отстаивал идеал абсолютной монархии. Стремясь к росту и расширению своей власти, он, как и Никон, ориентировался на вселенское (греческое) православие. Именно вмешательство царя в церковные дела и привело к расколу Русской Православной Церкви.</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">«Отступление от православия» патриарха Никона не сильно встревожило староверов. Более того, в 1664 г. царь Алексей Михайлович предложил протопопу Аввакуму занять место своего духовника.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">Но в 1666 г. царь собирает в Москве церковный Собор. И вот это событие было воспринято старообрядцами, как отступление царя от истинной веры и наступление «царства Антихриста». Антихрист пришел и властвует, Третий Рим пал, четвертому не быть, правда ушла в пресветлые небеса, кривда правит на Земле, священство иссякло, служба Божья уже невозможна. Необходимо бежать из царства Антихриста в пустыню. Протопоп Аввакум, сосланный в 1667</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">г. в Пустозерск, одобрил это «второе неоскверняемое крещение огнем», как одно из средств борьбы с никонианцами. И запылали по России костры.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p style="padding-left: 16pt;text-indent: -8pt;text-align: left;"><span class="s33" style=" background-color: #F00;">Социально-экономическое развитие России в XVII в.</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 7pt;line-height: 106%;text-align: left;">Первое. XVII в. – это время, когда господствовало барщинное хозяйство. Его черты достаточно полно были раскрыты еще в советской историографии:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l25"><li data-list-text="1)"><p style="padding-left: 16pt;text-indent: -9pt;text-align: left;">земля находится в собственности помещика и делится на барскую и крестьянскую запашки;</p></li><li data-list-text="2)"><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 211%;text-align: left;">крестьяне обрабатывают землю довольно примитивными орудиями труда, находящимися в их собственности; 3)хозяйство носит натуральный характер;</p></li></ol><ol id="l26"><li data-list-text="4)"><p style="padding-left: 16pt;text-indent: -9pt;text-align: left;">преобладает отработочная рента (барщина);</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5)"><p style="padding-left: 16pt;text-indent: -9pt;text-align: left;">крестьяне прикреплены к земле (внеэкономическое принуждение).</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Второе. XVII в. – это время, когда в России появились первые мануфактуры. С экономической точки зрения крепостная мануфактура была бесперспективна: крепостные работники не были заинтересованы в труде и росте его</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">производительности, а хозяева мануфактуры – в использовании технических новшеств.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">Третье. XVII в. – это время зарождения капиталистических отношений в российской экономике. Генезис капитализма был связан с формированием общероссийского рынка и начавшимся периодом первоначального накопления капитала. Между областями увеличивался обмен, росло товарообращение, небольшие местные рынки</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: justify;">концентрировались в один всероссийский рынок. по которому иностранным купцам запрещалось вести розничную торговлю в России. Всё русское купечество было объединено в корпорации «гостей», «гостиной сотни» и «суконной сотни».</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Развитию русского купечества мешали отсутствие выхода к морям, засилье иностранного капитала, стремившегося захватить внутренний рынок России, государева казна, бесцеремонно забиравшая купеческий капитал и</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">устанавливавшая государственную монополию на торговлю многими выгодными товарами. Все это сдерживало развитие в России буржуазных отношений вплоть до отмены крепостного права.</p><p style="padding-top: 9pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s32" style=" background-color: #F00;">Т</span><span class="h4" style=" background-color: #F00;">ЕМА </span><span class="s32" style=" background-color: #F00;">3. XVIII </span><span class="h4" style=" background-color: #F00;">ВЕК В РОССИЙСКОЙ ИСТОРИИ</span></p><p style="padding-top: 7pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s32" style=" background-color: #F00;">Вопросы семинарского занятия</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l27"><li data-list-text="1."><p style="padding-top: 4pt;padding-left: 23pt;text-indent: -15pt;text-align: left;"><span class="s33" style=" background-color: #F00;">Первая попытка модернизации России. Необходимость и противоречивость реформ Петра I.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 5pt;line-height: 106%;text-align: left;">В начале XVIII века в соответствии с представлениями того времени мощь государства связывалась с обладанием военным и торговым флотами, с развитием металлургического производства для выпуска вооружения. Представляет интерес высказывание В.О. Ключевского: «Война указала порядок реформы, сообщила ей темп и самые приёмы.</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Преобразовательные меры следовали одна за другой в том порядке, в каком вызывали их потребности, навязанные войной».</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">Характерной чертой модернизации России начала XVIII века являлось интенсивное проникновение государства в различные сферы экономики и жизни российского общества в целом. За период его царствования было издано около 300 законодательных актов, в корне изменивших жизнь страны.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Важно отметить, что Пётр придерживался протекционистской политики. Но доминирование принудительного труда в промышленности превращало промышленные предприятия в крепостные. Модернизационные процессы в силу</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">сохранения крепостничества становились противоречивыми и половинчатыми. Это сказывалось на судьбе последующих реформ.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p style="padding-top: 4pt;padding-left: 23pt;text-indent: -15pt;text-align: left;"><span class="s33" style=" background-color: #F00;">Особенности и значение преобразований Петра I. Оформление абсолютной монархии.</span></p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">Реформы Петра I связывались с коренной реконструкцией социального строя страны. Следует подчеркнуть, что</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">«регул» («правило») не только характеризовал принцип управления, но и выступал элементом социальной политики.</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Введённая подушная система обложения просуществовала до 1887 г. В «регулярном государстве» никто из подданных не мог оказаться вне трёх систем: крепостной, податной и служилой.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Административные преобразования завершили оформление абсолютной монархии в политическом строе России. Губернская реформа 1708–1710 гг. изменила систему местных органов власти.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">Важнейшей чертой абсолютизма являлось наличие регулярной армии. Была введена система рекрутских наборов. Были разработаны новые основы комплектования, организации, снабжения, обучения войск. А гвардия стала играть роль своеобразного параллельного аппарата управления, возвышаясь над гражданской администрацией.</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Увеличивался и деспотизм единоличной власти царя.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Титулование Петра I императором всероссийским, провозглашение Российского государства империей стали</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">проявлением существенных изменений, отражением нового положения страны в системе европейских государств. Из своего изолированного положения Россия вступила в Европу, приобщилась к передовым достижениям западной культуры.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p style="padding-top: 4pt;padding-left: 23pt;text-indent: -15pt;text-align: left;"><span class="s33" style=" background-color: #F00;">Политика «просвещённого абсолютизма» Екатерины II.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">Царствование Екатерины II (1762–1796) отмечено усилением могущества Российской империи, укреплением абсолютизма и позиций его социальной опоры – дворянства. Со второй половины XVIII века начинаются процессы разложения феодального и формирования капиталистического общества в России, что обусловило проведение</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">императрицей политики «просвещенного абсолютизма» на первом этапе своего правления. Необходимо понять цель этой политики: в рамках существующей социально-экономической и политической системы феодализма дать</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">больший простор для развития общественнополитической мысли, либерализма. Для сохранения господства старых социальных порядков правящее сословие начинает выступать от имени всего общества.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">В рамках идеологии российского «просвещённого абсолютизма» монархическая форма правления считается неизменной, неотъемлемой и единственно приемлемой для России. Обратите внимание на внутреннюю</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">противоречивость политики «просвещённого абсолютизма» в России: декларирование верности идеям Просвещения с одной стороны, а с другой – сохранение самодержавия, господства дворянства, крепостного права.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">Рубежом второго этапа правления Екатерины II, характеризующегося отказом от политики «просвещённого абсолютизма», стала крестьянская война под предводительством Е. Пугачёва (1773–1775). Объясните предпосылки, цели, состав участников, ход, причины поражения и последствия этой войны. Отказу от политики «просвещённого абсолютизма» способствовала также Великая Французская буржуазная революция, породившая опасения о</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">возможности распространения революционных настроений в России. Следствием этого явилось утверждение во внутренней политике Екатерины II консерватизма, направленного на сохранение и укрепление существующей феодальной общественно-политической системы.</p></li><li data-list-text="4."><p style="padding-top: 8pt;padding-left: 16pt;text-indent: -8pt;text-align: left;"><span class="s33" style=" background-color: #F00;">Внешняя политика России в XVIII в.</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Внешняя политика Петра 1</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">Царь Пётр Алексеевич проводил весьма активную внешнюю политику, пытаясь, как и правители до него, расширить государственные границы России.</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Но, самым желанным для Петра Первого являлся выход к незамерзающим морям, что открывало практически бесконечные возможности развития страны, которая бы вошла в число мировых морских держав.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Решение вопроса с выходом в Чёрное или Балтийское море позволяло расширить внешние торговые связи славянского государства, а также укрепить авторитет России на политической мировой арене, восстановить истощавшую экономику государства и обеспечить полную безопасность.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">В 1698 году государь посещает немало правителей стран, предлагая им выступить против укрепившейся на побережье Балтики Швеции, становящейся с каждым днём всё более агрессивным и мощным государством.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">При этом, каждая из стран преследовала собственные цели.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">Желание русского царя получить доступ к торговым путям с западом являлось не единственной причиной выйти против Карла Двенадцатого, учитывая то, что Швеция в данный период находилась на пике своего могущества.</p><p style="padding-top: 9pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s32" style=" background-color: #F00;">Т</span><span class="h4" style=" background-color: #F00;">ЕМА </span><span class="s32" style=" background-color: #F00;">4. Р</span><span class="h4" style=" background-color: #F00;">ОССИЯ В ПЕРВОЙ ПОЛОВИНЕ </span><span class="s32" style=" background-color: #F00;">XIX </span><span class="h4" style=" background-color: #F00;">ВЕКА</span></p><p style="padding-top: 7pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s32" style=" background-color: #F00;">Вопросы семинарского занятия</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l28"><li data-list-text="1."><p style="padding-top: 4pt;padding-left: 23pt;text-indent: -15pt;line-height: 13pt;text-align: justify;"><span class="s33" style=" background-color: #F00;">Власть и общество в России в первой четверти XIX века.</span></p><p class="s34" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">В первой четверти XIX века в России не появились ещё идеологически оформленные общественно-политические  течения.  Приверженцы  разного  рода  политических  систем  зачастую  развивали  свою деятельность в пределах одного общества, в конфликтах борясь за своё мнение о судьбе России. Тем не менее, представители радикального течения оказались более активными. Они раньше всех обнародовали свой план изменений экономической и социально-политической системы страны. Стремясь провести его, они подняли бунт против царского режима и крепостного права.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s34" style="padding-left: 7pt;text-indent: 3pt;text-align: justify;">Тем не менее, в общественной деятельности России была своя особенность. Она проявлялась в том, что в России на самом деле не было буржуазии способной защищать свои интересы и демократические реформы. Народ в большинстве своём был груб, дремуч, неграмотен и невежественен. В связи с этим революционные взгляды, сознание неизбежности модернизации России возникали в начале XIX века только у сознательной части аристократии, пошедшей против интересов своего класса. Число повстанцев было очень небольшим по большому счёту, представители благородной аристократии и престижного офицерского корпуса. Большое влияние на возникновение вольнодумства оказала Отечественная война 1812 года. Декабристы заявляли о себе как о &lt;&lt;детях 1812 года», считая этот год началом своего политического развития (более ста мятежников были её участниками).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s34" style="padding-left: 7pt;text-indent: 0pt;text-align: justify;">Зарубежная  кампания  русской  армии  1813-1814  годов  дала  им  возможность  увидеть  социально-политические развитие в Европе после Французской революции конца XVIII века, подарила им новые ощущения, новые мысли и актуальный житейский опыт.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p style="padding-top: 4pt;padding-left: 16pt;text-indent: -8pt;text-align: left;"><span class="s33" style=" background-color: #F00;">Внутренняя политика и общественные идеи в России во второй четверти XIX века.</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Во втором вопросе необходимо изучить основное содержание внутренней политики Николая I и общественно-политическую ситуацию в России 30–50-х годов XIX века. Необходимо разобраться и в важнейших направлениях</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">властей политики николаевской России; при этом особое внимание надо обратить на Крымскую войну (1853– 1856</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">гг.), причины её возникновения, ход военных действий и итоги.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Восстание декабристов всколыхнуло российское общество, заставило власть искать новые пути управления страной.</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">Деятельность многочисленных секретных комитетов, разрабатывавших проекты реформирования экономики,</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">сословных отношений, кодификации законов, попытки разрешения крестьянского вопроса, носили характер полумер. Эти мероприятия не могли сгладить остроту социальных противоречий.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">На основе понимаемых изменений, происходивших в дореформенной России, сформировались в 30–50-е годы XIX века два основных течения, впоследствии получивших обобщённо-собирательные названия «западников» и</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">«славянофилов». Теоретики «русского социализма» генетически связаны с «западничеством» либералов.</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">«Славянофилы» оставались дворянскими реформаторами. Они подготовили и осуществили отмену крепостного права. Вместе с тем из их среды выходили не только реформаторы, но и консерваторы – охранители устоев</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">самодержавной, православной Руси.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Идеология (от консервативно-охранительной до революционнорадикальной) была страшно далека от народа и не соответствовала ни его социальным идеалам, ни политическим устремлениям. Крестьяне боролись за «землю и волю» сами по себе, «как знали и как могли». Идейные искания отечественной интеллигенции оставались им</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">чуждыми.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s32" style=" background-color: #F00;">Т</span><span class="h4" style=" background-color: #F00;">ЕМА </span><span class="s32" style=" background-color: #F00;">5. Р</span><span class="h4" style=" background-color: #F00;">ОССИЯ ВО ВТОРОЙ ПОЛОВИНЕ </span><span class="s32" style=" background-color: #F00;">XIX </span><span class="h4" style=" background-color: #F00;">ВЕКА</span></p><p style="padding-top: 7pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s32" style=" background-color: #F00;">Вопросы семинарского занятия</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l29"><li data-list-text="1."><p style="padding-top: 4pt;padding-left: 23pt;text-indent: -15pt;text-align: left;"><span class="s33" style=" background-color: #F00;">Эпоха великих реформ в истории России второй половины XIX в.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">В конце 50-х - начале 60-х гг XIX в. в России находилась в тяжелой общественно-политической ситуации. Общество</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">было разделено на несколько слоев: аристократическую верхушку, центральную и западную часть мещанства и массы крестьян. Общественное настроение было напряженным, так как многие люди недовольны длительными</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">реформами, которые проводились в стране.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">Также в это время в России происходили серьезные экономические проблемы, в результате чего страна уступала западным государствам. Долг России по отношению к западным странам вырос до неприемлемых размеров, а</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">производственные способности были слабыми.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Все это вынудило русское правительство выступить с идеей о скорейшей модернизации страны.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Отмена крепостного права в России второй половины XIX века являлась частью широкого движения реформ,</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">направленных на модернизацию страны. Программа отмены крепостного права разрабатывалась руководством царства и высшими чинами. Ее суть состояла в том, чтобы освободить крестьян от связи с землей и повысить их экономическую и социальную мобильность.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Отмена крепостного права произошла в 1861 году после длительных дискуссий и переговоров. Осуществлялась путем принятия закона, который определял условия и сроки освобождения крестьян от крепостного родства. После отмены крепостного права крестьяне стали свободными людьми и могли заниматься любым видом деятельности, в том числе и переезжать на другие территории.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">Политическая программа Лорис-Меликова была направлена на усиление централизации власти в правительстве и снижение влияния местной знати и бюрократии. Он стремился создать новую систему местного самоуправления и</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">улучшить отправление правосудия и финансовую систему государства. Реформы включали такие меры, как создание Государственного совета, создание современной системы выборов и введение земства, формы местного</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">самоуправления.</p><p style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">Во 2-й половине 19 в. в России стали распространяться идеи марксизма, во многом благодаря влиянию</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">революционных организаций и отдельных лиц, приобщившихся к марксистской мысли во время учебы за границей. Между тем российский либерализм также развивался, поскольку интеллектуалы и политические лидеры стремились решать социальные и политические проблемы, стоящие перед страной. В этот период все более очевидным</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">становилось несоответствие между быстро индустриализирующейся экономикой России и ее застойным политическим строем, в котором господствовали монархия и аристократия. Это подпитывало требования</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 107%;text-align: left;">политических и социальных перемен и помогло заложить основу для более поздних революционных движений, которые в конечном итоге привели к падению Российской империи.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Однако эти реформы не были реализованы в полной мере и столкнулись с противодействием консервативных сил России. Убийство Александра II 1 марта 1881 года членами революционной группы «Народная воля» положило конец усилиям по модернизации политической системы России, и реформы вскоре были свернуты. Реформы были</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">непоследовательными, незавершенными и внутренне противоречивыми, а политическая ситуация в России оставалась нестабильной.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p style="padding-left: 16pt;text-indent: -8pt;text-align: left;"><span class="s33" style=" background-color: #F00;">Власть и общественное движение во второй половине XIX в.</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">Во второй половине XIX века произошли значительные изменения как в политическом, так и в общественном устройстве России. Власть переходила от монархии к более демократической системе, и возникали социальные</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">движения, поскольку население стремилось к большим правам и свободам. Эпоха характеризовалась реформами, направленными на модернизацию страны и ликвидацию ее экономической и технологической отсталости. В этот</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">период произошли отмена крепостного права, введение местного самоуправления, создание Государственной думы, создание системы юридических прав и гарантий. Однако эти реформы были ограниченными и непоследовательными, что привело к противодействию со стороны консервативных элементов общества. Возможное убийство императора</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Александра II в 1881 году стало поворотным моментом, приведшим к временной остановке реформ и</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 106%;text-align: left;">восстановлению самодержавной власти. Тем не менее эпоха великих реформ заложила основу для дальнейших политических и социальных преобразований ХХ века.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s35" style=" background-color: #F00;">Тема 6. Россия в первой половине XX века: от распада империи до создания лагеря социализма</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="s36" style=" background-color: #F00;">1. Российская империя в начале ХХ века (1900 – начало 1917 гг.)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 7pt;text-indent: 0pt;line-height: 122%;text-align: left;"><span class="s36" style=" background-color: #F00;">2.1917 год в России: развитие революции от Февраля к Октябрю.</span><span class="s37"> </span><span class="s36" style=" background-color: #F00;">3.Становление советского общества (1917–1940 гг.).</span></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span class="s36" style=" background-color: #F00;">4.Внешняя политика СССР в 1919–1945 гг.</span></p></body></html>
